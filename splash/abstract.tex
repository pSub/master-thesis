\documentclass{acm_proc_article-sp}

\usepackage[utf8]{inputenc}

\usepackage{cite}

\begin{document}

\title{A Language for the Specification and Efficient Implementation
  of Type Systems}

\numberofauthors{1}

\author{
\alignauthor
Pascal Wittmann
}

\maketitle

\begin{abstract}
  Type systems are important tools to ensure partial correctness of
  programs, to establish abstractions and to guide the programmer in
  the development process. However, there is currently a lack of
  established tools supporting the development of type systems, as
  there are for lexers and parsers. We introduce a declarative
  specification language for type systems, that allows to type systems
  in a natural deduction style. Two results are generated from those
  specifications. A first-order formula representation to facilitate
  the use of automated theorem provers and an efficient type
  checker. Both results aim to support a faster development cycle for
  type systems.
 \end{abstract}

\section{Motivation}
Type systems ensure partial correctness of programs or in other words,
they try to ensure that programs have meaning in the sense of the
semantics of the programming language. The type systems we investigate
are static type systems and can also be thought of as a static
approximation of the program semantics. Besides ensuring partial
correctness, type systems are means to establish abstractions and to
enforce adherence to these abstractions. All in all this can help to
develop software more efficiently
(cf. \cite{Petersen:2014:ECS:2597008.2597152} and
\cite{Mayer:2012:ESI:2384616.2384666}).

Type systems are useful tools, if they fit to the programming language
and their use. To ensure that they fit to the programming language and
their use it makes sense to adapt and modify existing type system or
create new specialized type systems. Those specializations can lead to
better error messages, more expressive type systems and the detection
of more errors. Currently there are, to our best knowledge, no
established tools that generate usable type checkers from declarative
specification languages. Those generators could make the development
of type checkers faster and less error prone. Those generators would
fit well into the language development workbench besides the long
established lexer and parser generators.

The other advantage of generating a type checker from a declarative
specification language is that the specification is close to the
formal description of the type system and the generation of the type
checker can be verified in the absence of a concrete
specification. Often not only the verification of the implementation
is a concern, but also that the type system satisfies certain
properties. As the proofs of propositions about type systems change
when the type system changes, it is desirable to make most of these
changes automatically. Therefore an other motivation for a type
checker generator is to translate specifications into first-order
formulas which can be fed into automated theorem provers to prove
propositions. This establishes a direct connection between the
propositions and the generated type checker.

%% TODO: Mention the application to other kind of type systems?

\section{Research Problem}
The research problem we are trying to tackle is to create a tool that
allows to create an efficient type checker from a declarative
specification and that reduces the gap between formal reasoning about
type systems and their implementation. This problem splits up in
smaller problems.

The first problem is the design of a declarative specification
language that is close to the formalisms used for type systems. This
language should make it easy to use existing syntax definition of
realistic programming languages and the difference between typing
rules on paper and in the specification language should be small.

The next problem is to investigate a good first-order formula
representation of specification. This representation should be
designed such that it suits automated theorem proving and thus fast
proves. It should also be investigated to which extend theorem provers
for first order logic can be used for type checking.

The main problem is the generation of an efficient type checker. The
performance of the resulting type checker should be comparable with
type checkers that are implemented by hand. The generator should also
be able to cope with non-syntax directed typing rules in an efficient
manner. As one way to achieve this it should be investigated whether
facts proven by an automated theorem prover can be exploited.
\section{Related Work}
There are early approaches for the generation of type checkers that
were not particularly designed for that purpose. For example the
Synthesizer Generator \cite{Reps:1984:SG:800020.808247} which uses
attributes grammars and the ASF+SDF Meta-Environment
\cite{vandenBrand:2001:AMC:647477.727788} based on conditional term
rewriting. Later approaches use similar techniques, for example TCG
\cite{phd/de/Gast2005} which uses inference rules, but are specialized
for the generation of type system. Those approaches have a lower
performance handcrafted implementations, because they implement the
control-flow implied by the formalism used.

A recent approach (TyC \cite{ortin2014automatic}) has focused on the
generation of type checkers for object-oriented programming
languages. It provides a framework to build efficient type checkers
for object-oriented languages (without polymorphism) and uses for this
purpose, in most parts, normal program code to specify the type
system.

Ott \cite{journals/jfp/SewellNOPRSS10} is an other approach that
generates from a specification language code for proof assistants and
\LaTeX, it tries to reduce the gap between the hand-written on-paper
proofs and machine checkable proofs.
\section{Approach}
\section{Results and Contributions}

\bibliography{bibliography}{}
\bibliographystyle{plain}
\end{document}