\chapter{Formula Generation}
\label{ch:formula-generation}
Type systems in programming languages can be treated as black boxes
from a programmers point of view. The programmer interacts with the
type system for example via type annotations and receives feedback
from the type system in form of error messages. Errors in the type
system are hard to detect for the programmer, because he cannot be
sure if it is an error in his program or in the type system (or its
implementation). In addition he can only debug his program, because of
the black box view on the type system. Therefore it is desirable to
ensure that the type system has the intended semantics.

Mathematical proofs are used to ensure that a type system has the
intended semantics. A basic property of type systems is safety, which
roughly means ``a well-typed term can never reach a stuck state during
evaluation''\cite{Pierce:2002:TPL:509043}. Those properties can be
proven by hand or with the help of proof assistants. Both methods
require substantial manual effort. In accordance to the goal of the
automated generation of type checkers, we explore how well automated
theorem provers can solve simple propositions and how this can be
exploited in the type checker generation. We generate formulas from
type system specifications to interface with automated theorem
provers.
 
\section{Goals}
The generation of formulas from type system specifications pursues two
goals. The first goal is to resemble type system specifications in
formulas suitable for automated theorem provers and to use this as a
basis to prove simple properties. The second goal is to explore how
well automated theorem provers can check if a program is well-typed.

\section{Why First-Order Logic?}
\subsection{Expressiveness}
\subsection{Tool-Support}
\section{Translations}
\label{sec:translations}
We translate context declarations, rules and conjectures into
first-order formulas. The rest of the specification is not directly
translated into first-order formulas and it is only needed to ensure
that the generated formulas are well formed.

\todo[inline]{Implement imports and describe how they are handled.}

We translate context declarations in a uniform way into first-order
formulas. For every context we generate two formulas, which model the
look up of entries in the context recursively. In the base case the
element lookup to look up is the first element of the context. In the
step case the first element is different from the element we search,
therefore we have to search in the rest of the context for it.

\begin{figure}
\begin{multline}
  \forall e, x_1, \dots, x_n, y_1, \dots, y_m . \\
  (lookup_c(x_1,\dots,x_n,y_1,\dots,y_m,
  bind_c(x_1,\dots,x_n,y_1,\dots,y_m,e)))
\label{formula:context-base}
\end{multline}
\caption{Base case of context lookup}
\end{figure}

The Formula~\ref{formula:context-base} is the context look up base
case for a context declared as $c$. We translate all non-terminals in
the context declaration tagged as input into variables $x_1 \dots x_n$
and all tagged as output into variables $y_1 \dots y_m$,
respectively. The variable $e$ represents all possible contexts. For
each context declaration there is a specialized $bind_c$ predicate
which models the binding of an input/output pair to a context
$e$. There is also a specialized $lookup_c$ predicate for each context
declaration which models the actual look up in the context. This
predicate checks whether an input/output pair exists in a context. In
the base case we apply $lookup_c$ to a context that we extended with
$bind_c$ with exactly the element we want to look up. Therefore the
element is trivially contained in the context and the look up
succeeds.

\begin{figure}
\begin{multline}
  \forall e, x_1, \dots, x_n, x_1', \dots, x_n', y_1, \dots, y_m,
  y_1', \dots,
  y_m' . \\
  (x_1 \neq x_1') \land \dots \land (x_n \neq x_n') \land (lookup_c(x_1,
  \dots, x_n, y_1, \dots, y_m, e) \implies \\ lookup_c(x_1, \dots, x_n,
  y_1, \dots, y_m, bind_c(x_1',\dots,x_n',y_1',\dots,y_m',e))
\label{formula:context-step}
\end{multline}
\caption{Step case of context lookup}
\end{figure}

Formula~\ref{formula:context-step} models the context look up step
case of context $c$. We introduce for each non-terminal two variables,
$x_1,x_1', \dots, x_n,x_n'$ for non-terminals tagged as input and
$y_1,y_1', \dots, y_m,y_m'$ for non-terminals tagged as output. The
intuition of the formula is that if it is possible look up an
input/output pair in a context $e$ then we can also look it up in an
context that contains and additional input/output pair.

We translate the \gls{ast} nodes of the programming language directly
into predicates that resemble the program structure. For the
translation we use the following scheme. \gls{ast} nodes of the
following form $Cons(e_1, \dots, e_n)$ are translated into a predicate
of the form $cons(p_1, \dots, p_n)$, where we translate all
constituents $e_i$ into predicates $p_i$ recursively. We create for
each of those predicates injectivity and univalence
axioms. Injectivity and univalence holds by definition for those
predicates as we create those predicates from syntax. These axiom can
help theorem provers to conduct proofs, for examples see
Section~\ref{sec:constr-templ-optim}.

The most important part is the translation of the typing
rules. Depending on whether the typing rule has premises we use either
of the following schema:

\begin{figure}
\begin{align}
  &\forall FV(c) .& c \\
  &\forall FV(p_1,\dots, p_n, c) .& p_1 \land \dots \land p_n \implies
  c
\label{formula:typing-rule}
\end{align}
\caption{Formulas representing typing rules}
\end{figure}

The predicates $p_i$ represent the premises and $c$ is the conclusion
of the typing rules. What a typing rule intuitively expresses is that
the conclusion can be derived if all premises can be derived. In terms
of first-order logic ``derived'' means that there exists a proof for
the proposition. Therefore we translate a typing rule without premises
into a formula that consists of the conclusion and all-quantifies all
free variables of the conclusion. Free variables are all-quantified,
because we want that all possible variants of the conclusion are
derivable. Typing rules with premises translate into a single
implication. The premise of the implication is the conjunction of all
premises of the typing rule. This ensures that all premises need to be
derivable/satisfied. The conclusion of the implication is the
conclusion of the typing rule. This is a safe fact, because the
conclusion of the typing rule is derivable if all premises are
derivable, which is exactly the semantics of this implication.

We translate judgments in rules into predicates. The built-in
judgments for equality and inequality are translated into the
primitives of \gls{tptp}.
\section{Implementation}
\label{sec:implementation-fof}
This section describes the implementation details of the translation
from the specification language into first-order formulas.

\todo[inline]{Extend for imports.}

The implementation is organized in the following steps. At fist, the
module is split up into its components, then we transform contexts,
typing rules and conjectures into first-order formulas. After that we
create a file for each conjecture which contains all generated
formulas. In the following those steps will be explained in detail.

The strategy \code|make-context-formulas| generates axiom formulas for
each context declaration. For each distinct non-terminal in a context
definition we create a fresh variable name to ensure variable names
are compatible with \gls{tptp}. We transform every context declaration
into Formula~\ref{formula:context-base} and
Formula~\ref{formula:context-step} in our internal representation of
\gls{tptp} formulas. To adhere to the structure of the two formulas,
we split the non-terminals of a context declaration by its
input/output tags and put those tagged as input before those tagged as
outputs. In the generated formulas we replace the non-terminals by the
fresh variables. In case of Formula~\ref{formula:context-step} we
create additional fresh variables for input positions.

To rewrite typing rules into first-order formulas is a bit more
involved than the rewriting of context declarations. The strategy
\code|make-formula| transforms rules into first-order formulas in the
\gls{tptp} format. This strategy rewrites premises and conclusions
into first-order terms using the strategy \code|rewrite|. Premises
are, due to limitations of the \texttt{layout}-rules, not represented
as ordinary lists after parsing. Therefore premises are transformed
into ordinary lists by the generic \texttt{to-list} strategy. Now that
we have first-order terms for the premises and the conclusion, we
collect all free variables that occur in them. In rules variables are
not bound, thus all variables are free. However it is important to
collect only free variables, as conjectures may contain
quantifiers. At last, we put premises, conjecture and quantification
together to construct a formula in the \gls{tptp} format which has the
structure of Formula~\ref{formula:typing-rule}.

Now we present the details of the \texttt{rewrite} strategy, which
transforms premises and conclusions. We this strategy is defined as a
sequence of two top down traversals. The first traversal is the actual
rewrite of the typing judgments and the second is a special treatment
for strings. The second traversal is necessary to wrap all target
language constructs into the \code|Term| constructor.

We translate parts of the specification language into new \gls{sdf}
syntax definitions as described in
Section~\ref{sec:generate-sdf}. Therefore not all nodes contained in
the \gls{ast} of a specification are known at the time of
implementation. However all those nodes have a regular structure. That
is why it is possible to use the \code|cons#(args)| pattern to extract
the relevant parts in a generic manner. The rule \code|make-aux-cons|
wraps all generic nodes\footnote{Generic nodes of the specification
  language, i.e\ empty context, context binds, context look ups,
  typing judgment and meta-variable nodes.} into the auxiliary
constructor \code|AuxCons| with three parameters, the static part of
the constructor name, the generic part of the constructor name and the
arguments. After this transformation normal pattern matching on
\code|AuxCons| is possible. The strategy \code|rewrite-aux-cons|
transforms those auxiliary constructors into first-order terms.

All nodes in the \gls{ast} of a specification that are not wrapped
into auxiliary constructors are constructors of the target
language. Therefore we attempt to transform each node into an
auxiliary node, in case that succeeds, we rewrite the node into a
first-order term otherwise we wrap the node into the \code|Term|
constructor. It is important to wrap the nodes of the target language
to implement pretty printing.

The second top down traversal wraps all strings that occur in the
parameters of nodes into \code|Term| constructors. As the
specification language has no string nodes, it is safe to transform
all those strings into \code|Term| nodes. If there is no second
traversal a direct transformation leads to infinite recursion as every
string within a \code|Term| constructor would be wrapped again in a
\code|Term| constructor, therefore we need a second traversal.

Conjectures are essentially transformed following the same scheme as
rules, the only difference is that we tag the resulting formulas as
\code|conjecture| and not as \code|axiom|.
\section{Performance}
%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../report"
%%% End:
