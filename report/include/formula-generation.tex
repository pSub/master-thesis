\chapter{Formula Generation}
\label{ch:formula-generation}
Type systems in programming languages can be treated as black boxes
from a programmers point of view. The programmer interacts with the
type system for example via type annotations and receives feedback
from the type system in form of error messages. Errors in the type
system are hard to detect for the programmer, because he cannot be
sure if it is an error in his program or in the type system (or its
implementation). In addition he can only debug his program, because of
the black box view on the type system. Therefore it is desirable to
ensure that the type system has the intended semantics.

Mathematical proofs are used to ensure that a type system has the
intended semantics. A basic property of type systems is safety, which
roughly says ``a well-typed term can never reach a stuck state during
evaluation''\todo{Cite Pierce}. Those properties can be proven by
hand or with the help of proof assistants. Both methods require
substantial manual effort. In accordance to the goal of the automated
generation of type checkers, we explore how well automated theorem
provers can solve simple propositions and how this can be exploited in
the type checker generation. We generate formulas from type system
specifications to interface with automated theorem provers.
 
\section{Goals}
With generation formulas from type system specification we pursue two
goals. The first goal is to resemble type system specifications
in formulas suitable for automated theorem provers and to use this as
a basis to prove simple properties. The second goal is to explore how
well automated theorem provers can check if a program is well-typed.

\section{Why First-Order Logic?}
\subsection{Expressiveness}
\subsection{Tool-Support}
\section{Translations}
\label{sec:translations}
For the generation of first-order formulas not all sections of a
specification are important. The section that declares the
meta-variables and the section that declares the judgments are not
used at all. With regard to formula generation they are only used to
ensure correct syntax.

The following parts of a type system specification are translated into
first-order formulas as described below: Environments, AST nodes of
the programming language, meta-variables and typing rules.

\todo[inline]{Implement imports and describe how they are handled.}

Environments declarations are translated in a uniform way. For every
environment two formulas are generated. These two formulas model the
look-up of entries in the environment, which is equivalent to how they
are stored. Those formulas have an inductive nature, one formula
models the base case and the other one the step case for the lookup.

%% FIXME: This seems to be no good way to refer to formulas. How is it
%% done right? Haven't found an example in my bachelor thesis by chance.
\begin{figure}
\label{formula:environment-base}
\begin{multline}
  \forall e, x_1, \dots, x_n, y_1, \dots, y_m . \\
  (lookup_e(x_1,\dots,x_n,y_1,\dots,y_m,
  bind(x_1,\dots,x_n,y_1,\dots,y_m,e)))
\end{multline}
\end{figure}

The formula \ref{formula:environment-base} represents the base case of
environment look-ups. All non-terminals in the environment definition
tagged as input are translated into variables $x_1 \dots x_n$ and all
tagged as output are translated into variables $y_1 \dots y_m$,
respectively. The variable $e$ ranges over all possible
environments. The $bind$ predicate used in this formula models the
binding of new input/output pairs to the environment. In the
implementation the order of arguments is a bit different, but this
difference is for the discussion of the concept negligible. For
details see Section \ref{sec:implementation-fof}. The predicate
$lookup$ models the lookup in the environment. It is used to check
whether some input/output pair exists in the environment. In the base
case the an input/output pair is added to an environment $e$ and
looked-up directly afterwards. Therefore the look-up succeeds as the
required elements are directly given in the bind predicate.

\todo[inline]{Format look-up step formula nicely.}
\begin{figure}
\label{formula:environment-step}
\begin{multline}
  \forall e, x_1, \dots, x_n, x_1', \dots, x_n', y_1, \dots, y_m,
  y_1', \dots,
  y_m' . \\
  (x_1 \neq y_1) \land \dots \land (x_n \neq y_n) \land (lookup(x_1,
  \dots, x_n, y_1, \dots, y_m, e) \implies \\ lookup(x_1, \dots, x_n,
  y_1, \dots, y_m, bind(x_1',\dots,x_n',y_1',\dots,y_m',e))
\end{multline}
\end{figure}

Formula \ref{formula:environment-step} models the step case of
environment look-ups. The intuition is that if some input/output pair
is contained in an environment $e$ the it is also contained in an
environment in which in addition a different input/output pair is
stored. Variables $x_i$ and $x_i'$ are non-terminals from the
environment declaration tagged with input, $y_i$ and $y_i'$ are
non-terminals tagged with output respectively.

The AST nodes of the programming language are translated directly into
predicates. For the translation the following scheme is used. Assume
an AST node of the following form $Cons(e_1, \dots, e_n)$ is
translated into a predicate of the form $cons(p_1, \dots, p_n)$, where
all consituents $e_i$ are translated into predicates $p_i$
recursively. To help theorem provers for each of those predicates an
axiom for injectivity and univalence is created. Those hold by
definition of the AST nodes.

The most important part is the translation of the typing
rules. Depending on whether the typing rules has premises either of
the following schema is used:

\begin{figure}
\label{formula:typing-rule}
\begin{align}
  &\forall FV(c) .& c \\
  &\forall FV(p_1,\dots, p_n, c) .& p_1 \land \dots \land p_n \implies c
\end{align}
\end{figure}

\todo[inline]{In the following free variables are actually free
  meta-variables.}
The meta-variables $p_i$ are the premises and $c$ is the conclusion of
the typing rules. The intuition of a typing rule is that the
conclusion can be derived if all premises can be derived. In terms of
first-order logic ``derived'' means for arbitrary formulas that there
is a proof and for predicates that the predicate holds under the given
interpretation. Therefore a typing rule without premises is translated
into a formula that consists of the conclusion and all-quantifies all
free variables of the conclusion. Free variables are all-quantified,
because all possible variants of the conclusion have to be derivable.
Typing rules with premises are translated into a single
implication. The premise of the implication is the conjunction of all
premises of the typing rule. This ensures that all premises need to be
derivable/satisfied. The conclusion of the implication is the
conclusion of the typing rule. This makes sense as the intuition was,
that the conclusion of the typing rule is derivable if all premises
are derivable, which is exactly the semantics of this implication.

Type judgments are translated into simple predicates. Equality and
inequality can be expressed via judgments with the annotation ``is
Eq'' and ``is Neq'', respectively. Those judgments must have exactly
two non-terminals.
\section{Implementation}
\label{sec:implementation-fof}
The implementation details of the translation from the specification
language into first-order formula is described in this section.

\todo[inline]{Extend for imports.}
The implementation is organized in the following steps. Fist, the
module is split up into its components. Those are: module description,
imports, programming language, meta-variables, environments,
judgments, typing rules and conjectures. Second, environments, typing
rules and conjectures are transformed into first-order
formulas. Third, for each conjecture a file is created which contains
all generated formulas. In the following those steps are explained in
detail.

The module is split up by pattern matching. For formula generation
only the environment definitions, typing rules and conjectures are
used.

Formulas for the environment definitions are generated for each
environment definition separately and are added to the axioms. The
non-terminals of an environment definition are indexed with fresh
names. Those fresh names will be used as variables in the first-order
formulas. The structure of the formulas, as it is defined in
\ref{formula:environment-base} and \ref{formula-environment-step}, is
hard-coded in the internal representation for first-order formulas. To
adhere to this structure the variables representing the non-terminals
are split up by their input/output attribute. The counter parts for
the variables needed in the step case are created by appending an
underscore to the variable name, as a tick is not valid in TPTP.

Rewriting typing rules into first-order formulas is the most complex
process in the formula generation. The rewrite process is triggered
when a typing rule is encountered. When a typing rule with premises is
encountered the premises and conjectures are rewritten by the strategy
\texttt{rewrite}. Premises are, due to limitations of the
\texttt{layout}-rules, not represented as ordinary lists after
parsing. Therefore these special lists are transformed into an
ordinary list by the generic \texttt{to-list} strategy. Then the
free variables of premises and constraints are collected. Now an
implication is constructed from the list of premises and the
conclusion and in the case there are free variables, those variables
are all quantified. By now the constructed formula has the structure
shown in \ref{formula:typing-rule}.

Now the details of the \texttt{rewrite} strategy are presented. This
strategy is defined as a sequence of two top down traversals. The first
traversal is the actual rewrite of the typing judgments and the second
is a special treatment for strings. The first traversal is organized
as follows. An attempt to rewrite the current node into an auxiliary
constructor is made, if this attempt succeeds the auxiliary
constructor is rewritten into a term of the first-order formula
language, if it does not succeed it is wrapped into the \texttt{Term}
constructor. The reasoning is the following. Some AST nodes of the
specification language are generic, those referring to the environment
formulas, to the typing judgments and to the meta-variables. Those
consist of some constant string plus some user defined
string. Therefore it is not possible to use normal pattern matching on
them. The only chance to cope with them is to use the generic
\texttt{cons\#(args)} pattern, to access the name of the constructor
as a string. The auxiliary constructor \texttt{AuxCons} is used to
abstract over this generic pattern. The rule \texttt{makeAuxCons}
splits the constructor name into the constant string and the user
defined one and provides the arguments as they are. After this
transformation it is possible to use normal pattern matching on
\texttt{AuxCons}. \texttt{makeAuxCons} only succeeds on the
constructors mentioned before. If a node can be transformed into an
auxiliary constructor the constructor is rewritten immediately
afterwards into a constructor of the first-order logic target
language. These rewritings are trivial mappings from auxiliary
constructors to constructors of the target language. If a
transformation into an auxiliary constructor is not possible, the
current node is wrapped into a \texttt{Term} constructor if it is not
a constructor of the target language. The constructor \texttt{Term}
indicates that the wrapped constructor is a constructor of the
programming language, i.e. no constructor of the specification, nor of
the target language. This wrapping is needed for controlled pretty
printing of programming language constructors. In the second top down
traversal strings in the arguments of predicates (\texttt{Pred}) and
term (\texttt{Term}) constructors are wrapped into a \texttt{Term}
constructor to handle constructors without parameters. This wrapping
is needed later on to provide inequalities of constants symbols.

The rewriting of typing rules and conjectures is very similar,
therefore only the differences to the rewriting of typing rules are
described. Conjectures are as their name suggests rewritten into
formulas tagged as conjectures and are therefore also named
\texttt{goal} if no name is specified. \todo[inline]{Are there more
  differences}

\section{Performance}
%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../report"
%%% End: 
