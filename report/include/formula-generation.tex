\chapter{Formula Generation}
\label{ch:formula-generation}
When developing type systems it is desirable to be able to prove
propositions about those type systems. Those help to understand the
type system better and help to prevent errors. Those propositions are
often proven by hand, but those proves are error prone, hard to extend
and time expensive. Prove assistants help to gain extensibility and
eliminate error. Using automated prove assistants can reduce the time
effort for suitable propositions. This chapter describes how
first-order formulas are generated from type system specifications and
that these formulas can be used to type check programs.
 
\section{Goals}
\section{Why First-Order Logic?}
\subsection{Expressiveness}
\subsection{Tool-Support}
\section{Translations}
\label{sec:translations}
For the generation of first-order formulas not all sections of a
specification are important. The section that declares the
meta-variables and the section that declares the judgments are not
used at all. With regard to formula generation they are only used to
ensure correct syntax.

\todo[inline]{Implement imports and describe how they are handled.}

Environments declarations are translated in a uniform way. For every
environment two formulas are generated. These two formulas model the
look-up of entries in the environment, which is equivalent to how they
are stored. Those formulas have an inductive nature, one formula
models the base case and the other one the step case for the lookup.

%% FIXME: This seems to be no good way to refer to formulas. How is it
%% done right? Haven't found an example in my bachelor thesis by chance.
\begin{figure}
\label{formula:environment-base}
\begin{multline}
  \forall e, x_1, \dots, x_n, y_1, \dots, y_m . \\
  (lookup_e(x_1,\dots,x_n,y_1,\dots,y_m,
  bind(x_1,\dots,x_n,y_1,\dots,y_m,e)))
\end{multline}
\end{figure}

The formula \ref{formula:environment-base} represents the base case of
environment look-ups. All non-terminals in the environment definition
tagged as input are translated into variables $x_1 \dots x_n$ and all
tagged as output are translated into variables $y_1 \dots y_m$,
respectively. The variable $e$ ranges over all possible
environments. The $bind$ predicate used in this formula models the
binding of new input/output pairs to the environment. In the
implementation the order of arguments is a bit different, but this
difference is for the discussion of the concept negligible. For
details see Section \ref{sec:implementation-fof}. The predicate
$lookup$ models the lookup in the environment. It is used to check
whether some input/output pair exists in the environment. In the base
case the an input/output pair is added to an environment $e$ and
looked-up directly afterwards. Therefore the look-up succeeds as the
required elements are directly given in the bind predicate.

\todo[inline]{Format look-up step formula nicely.}
\begin{figure}
\label{formula:environment-step}
\begin{multline}
  \forall e, x_1, \dots, x_n, x_1', \dots, x_n', y_1, \dots, y_m,
  y_1', \dots,
  y_m' . \\
  (x_1 \neq y_1) \land \dots \land (x_n \neq y_n) \land (lookup(x_1,
  \dots, x_n, y_1, \dots, y_m, e) \implies \\ lookup(x_1, \dots, x_n,
  y_1, \dots, y_m, bind(x_1',\dots,x_n',y_1',\dots,y_m',e))
\end{multline}
\end{figure}

Formula \ref{formula:environment-step} models the step case of
environment look-ups. The intuition is that if some input/output pair
is contained in an environment $e$ the it is also contained in an
environment in which in addition a different input/output pair is
stored. Variables $x_i$ and $x_i'$ are non-terminals from the
environment declaration tagged with input, $y_i$ and $y_i'$ are
non-terminals tagged with output respectively.

The AST nodes of the programming language are translated into
predicates. To help theorem provers for each of those predicates an
axiom for injectivity and univalence is created. Those hold by
definition of the AST nodes.

The most important part is the translation of the typing
rules. Depending on whether the typing rules has premises either of
the following schema is used:

\begin{align}
  &\forall FV(c) &.\,& c \\
  &\forall FV(p_1,\dots, p_n) &.\,& p_1 \land \dots \land p_n \implies c
\end{align}

\todo[inline]{In the following free variables are actually free
  meta-variables.}
The meta-variables $p_i$ are the premises and $c$ is the conclusion of
the typing rules. The intuition of a typing rule is that the
conclusion can be derived if all premises can be derived. In terms of
first-order logic ``derived'' means for arbitrary formulas that there
is a proof and for predicates that the predicate holds under the given
interpretation. Therefore a typing rule without premises is translated
into a formula that consists of the conclusion and all-quantifies all
free variables of the conclusion. Free variables are all-quantified,
because all possible variants of the conclusion have to be derivable.
Typing rules with premises are translated into a single
implication. The premise of the implication is the conjunction of all
premises of the typing rule. This ensures that all premises need to be
derivable/satisfied. The conclusion of the implication is the
conclusion of the typing rule. This makes sense as the intuition was,
that the conclusion of the typing rule is derivable if all premises
are derivable, which is exactly the semantics of this implication.

Type judgments are translated into simple predicates. Equality and
inequality can be expressed via judgments with the annotation ``is
Eq'' and ``is Neq'', respectively. Those judgments must have exactly
two non-terminals.
\section{Implementation}
\label{sec:implementation-fof}
The implementation details of the translation from the specification
language into first-order formula is described in this section.

\todo[inline]{Extend for imports.}
The implementation is organized in the following steps. Fist, the
module is split up into its components. Those are: module description,
programming language, meta-variables, environments, judgments, typing
rules and conjectures. 

\section{Performance}
%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../report"
%%% End: 
