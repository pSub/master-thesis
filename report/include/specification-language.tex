\chapter{Specification Language}
Our type system specification language is a domain-specific language
for people who work on type systems or type checkers. It was created
with the following characteristics in mind:

\begin{itemize}
\item Close to the formal or mathematical notations that are commonly
  used to narrow the gap between the formal model and the
  implementation side.
\item Purely declarative to increase maintainability and readability of
  specifications.
\item Modular to combine type systems and increase reuse.
\item Use existing syntax definitions of programming with minor
  modifications.
\end{itemize}

Those characteristics fit well to the goals of making it easy to
experiment with type systems and to create type systems from a
high-level specification.
\section{Design \& Architecture}
In this sections we introduce the architecture of the specification
language with references to a small example specification and argue
how this architecture reflects the characteristics mentioned above.

A specification is divided into eight sections, of which two are
optional.

\paragraph{Modulename} The first section declares the name of the
specification module. This name is a unique identifier and used for
imports.

\paragraph{Imports} The second section declares which other
specifications are imported and is optional.

\paragraph{Language} The third section declares the language for which
a type system should be specified. This language needs to be present
as an \gls{sdf} module located at the specified path. This language is
from now on called \textit{target language}.

\paragraph{Meta-variables} In the fourth section meta-variables are
declared. The declaration of a meta-variable consists of a class
\refcallout{ex:spec:class}, of a prefix \refcallout{ex:spec:prefix}
and of a set of non-terminals of the target language
\refcallout{ex:spec:scope}. The class can be used to distinguish
different kinds of meta-variables, e.g.\ for optimization
purposes. \todo{Give an example optimization}

The set of non-terminals defines the scope of the meta-variable. Every
non-terminal that is contained in this set is extended with
meta-variables. In other words, a meta-variable is a substitute for
every terminal that can be produced from the
non-terminal. Section~\ref{sec:generate-sdf} explains in detail how
the target language is extended.

Syntactically a meta-variable is a string of numbers and letters that
is prefixed with the prefix of the meta-variable definition. The sole
purpose of the prefix is to avoid ambiguities while parsing. The
prefix itself can consist of numbers, letters and the following
symbols \verb|~|, \verb|$|, \verb|%|, \verb|&| and \verb|?|.
\todo{Is this list complete?} Usually a prefix is chosen such that it
is not a prefix of a construct of the target language.

\paragraph{Contexts} The fifth section defines all contexts used in
the typing rules. Informally these contexts are declared as
cross-products of non-terminals, i.e.\ an context is a set consisting
of pairs of terminals that can be produced by the non-terminals in the
declaration. Every context has a name, which can be used in further
declarations. Lookups may differ for contexts and use cases, therefore
one has to annotate the non-terminals with input and output
tags. Terminals at positions that are tagged with input are used to
look up terminals tagged with output that are saved in the context. An
context for which all non-terminals are tagged with input, is
equivalent to a normal look up in a set and will return whether the
tuple could be found. An context with only outputs acts as a sink, one
can put things into it, but never retrieve anything back.

\paragraph{Judgments} The sixth section of the module declares
judgments. Judgments in our specification language are the basic
building blocks of the rules defined in the next section, as it is
common in deduction systems. They are the ``syntax'' of the type
system, the semantics is defined by the rules.

A judgment can be defined rather arbitrarily from a combination of
strings of letters and numbers, non-terminals of the target language
and the names of the contexts. Those can be mixed freely, as long as a
string separates the non-terminals and context names. This restriction
is only needed to reduce the number of syntactic ambiguities in the
language. Judgments do not have a name and each judgment must be
closed with a dot.

Non-terminals of the target language and context names need to be
annotated with input/output-tags. Those tags describe which parts of
the judgment need to be computed by rule application and which are
provided as input parameters to the rule application. Contexts
currently only support the input tag.

\begin{example}{~}
\begin{verbatim}
judgments Context{I} "|-" Exp{I} ":" Type{O}.
          Type{I} "<:" Type{I}.
\end{verbatim}
\label{ex:judgment-section}
\end{example}

Example~\ref{ex:judgment-section} shows two judgments. The first could
be the typing judgment of a variant of the simply typed lambda
calculus with a context and an expression of the target language as
input and a type of the target language as output. The second judgment
defines a relation between the types of the target language, i.e.\ it
has only input positions. This judgment could represent a subtyping
relation.

\paragraph{Rules} The seventh section of the module declares the
(typing) rules. These rules define the semantics for the judgments
declared in the previous section. The syntax of the rules replicates
the form of inference rules: A (possibly empty) list of premisses
separated from a conclusion by a horizontal line. Premisses and
conclusion are instantiated judgments. All meta-variables that occur
in freely in rules are implicitly all-quantified. This means that all
meta-variables are all-quantified, as there is not mechanism to bind
variables in typing rules.

Rules can be annotated with a name. This increases the readability of
the specification and allows to create human readable derivation
traces. The rules have also support for custom error messages. There
are two kinds of error annotation. Premisses can be annotated with
\verb|@error msg|, where \verb|msg| can contain meta-variables and the
special symbol \verb|INFTYPE| interleaved with arbitrary
strings. Those errors are thrown if the premise could not be derived
or if the calculated output does not match the expected output. The
meta-variables are instantiated with the appropriate terms and
\verb|INFTYPE| with the expected output. The other kind of error
messages can also be annotated on the conclusion. Those errors are
prefixed with \verb|@implicit| and are thrown if an implicit equality
between two meta-variables cannot be satisfied. The meta-variables are
distinguished in the error message by \verb|@[number]|
annotations. How error messages are implemented in the type checker
generator is explained in Section~\ref{sec:constr-gener} and
Section~\ref{sec:constraint-solving}.

\begin{example}{~}
\begin{verbatim}
judgments
TermBinding{I} "|" TypeBinding{I} "|-" Exp{I} ":" Type{O}.
Type{O} "= [" ID{I} "->" Type{I} "]" Type{I}.

rules

===================== Subst-Eq
~S = [ %x -> ~S ] %x@1    @implicit %x " does not equal " %x@1.

~U = [ %x -> ~S ] ~T @error ~U "is not" ~T "where" %x "is
                            replaced by" ~S.
$C1 | $C2 |- ~e : all %x . ~T 
@error ~e "should have type all" %x "." %~T "but has type" { }.
============================== T-Tapp
$C1 | $C2 |- ~e [ ~S ] : ~U
\end{verbatim}
\label{ex:rules}
\end{example}

In Example~\ref{ex:rules} the rules \verb|Subst-Eq| and \verb|T-Tapp|
from the SystemF \todo{Reference} implementation are
shown. \verb|Subst-Eq| has no premisses and an implicit equality in
the conclusion. Rule \verb|T-Tapp| show how the expected output is
used in the error messages and how premisses are annotated with error
messages. All error message annotation belong to the preceding
premise.

\paragraph{Conjectures} Tests for a specification are called
\textit{conjectures}. Their syntax is similar to the syntax of rules,
with two exceptions. It is not possible to annotate premisses or
conclusions with error messages and a conjecture can be marked as
\textit{not derivable} by prepending the separating line with a
slash. Marking conjectures not derivable allows to formulate negative
tests.

\begin{example}
\begin{verbatim}
===
() |- let fac : int -> int = 
  fix f : int -> int (
    fun n : int (
      ifz n then 1 
      else n * (f (n - 1))
    )
  )
 in (fac 3) : int

/===========================
() |- fun x : int (x) : int
\end{verbatim}
\label{ex:conjecture-section}
\end{example}

In Example~\ref{ex:conjecture-section} two conjectures of the PCF
implementation are shown. They use the judgment shown in
Example~\ref{ex:judgment-section}. The first conjecture asserts that
the type of the faculty function apply to three is \verb|int| and the
second conjecture asserts that \verb|fun x : int (x)| does not have
type \verb|int|

\begin{figure}
\scriptsize
\begin{verbatim}
module example
imports common
language syntax/simply-typed-lambda-calculus
meta-variables 	Term !callout`ex:spec:class' "~" !callout`ex:spec:prefix' { Type Exp } !callout`ex:spec:scope'
                Ctx "$" { Context }
                Id "%" { ID }
contexts Context := ID{I} x Type{O}
judgments Context{I} "|-" Exp{I} ":" Type{O}.
rules

%x : ~T in $C @error %x "should have type" ~T "but has" INFTYPE
============== T-Var
$C |- ~x : ~T

(%x : ~T ; $C) |- ~t : ~T @error ~t "should have type ~T" "but has" INFTYPE
================================= T-Abs
$C |- \ %x : ~T . ~t : ~T -> ~T

$C |- ~t1 : ~T11 -> ~T12 @error ~t1 "should have type" ~T11 "->" ~T12 "but has" INFTYPE
$C |- ~t2 : ~T2          @error ~t2 "should have type" ~T2 "but has" INFTYPE
========================= T-App
$C |- ~t1 ~t2 : ~S
\end{verbatim}
\caption{Specification for a type system for the simply typed lambda calculus}
\end{figure}

How does this design reflect the goals declared above?

\begin{description}
\item[Usage] Mathematical definitions of type systems usually consist
  of judgment, rules and auxiliary definitions for contexts. All
  those elements can be represented in a natural way in the
  specification language. Judgments can be defined as an arbitrary, as long
  as this syntax does not create ambiguities, combination of
  non-terminals and separation symbols. Rules are written in a natural
  deduction style, because this is the most common representation for
  typing rules and acknowledges the deductive nature of typing rules
  in general. Contexts can be defined using a set like
  notation. This is close to the intuitive semantics of contexts
  and allows to generate commonly used syntax.
\item[Declarative] Everything that can be defined in the specification
  language has no side effects or possibilities to embed executable
  code.
\item[Modularity] \todo[inline]{Imports are not implemented yet.}
\item[Integration] Type systems can be defined for every programming
  language for which a SDF syntax definition exists. These definitions
  can in most cases be used in the specification language without
  modifications. Modifications are needed if one wants to use a
  language concept inductively in the type system, but has not
  implemented this concept with explicit induction in the
  syntax.\todo[inline]{Given an example.}
\end{description}
\section{Implementation}
\label{sec:generate-sdf}
\todo[inline]{Integration with sugar-lang is not done yet.}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../report"
%%% End: 
