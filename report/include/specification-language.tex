\chapter{Specification Language}
\label{cha:spec-lang}
Our type system specification language is a \gls{dsl} for people
familiar with type systems or type theory. While developing it, we had
the following goals in mind. The specification language should be

\begin{itemize}
\item Close to text-book formalisms used in the type system community
\item Purely declarative
\item Modular
\item Usable with existing syntax definitions of programming languages
\end{itemize}

Those characteristics fit well to the goals of making it easy to
experiment with type systems and to create type systems from a
high-level specification.
\section{Design \& Architecture}
\label{sec:design--architecture}
In this sections we introduce the architecture of the specification
language with references to a small example specification and argue
how this architecture reflects the goals mentioned above.

A specification is divided into eight sections, of which two are
optional.

\paragraph{Modulename} The first section declares the name of the
specification module. This name is a unique identifier and used for
imports.

\paragraph{Imports} The second section declares which other
specifications are imported and is optional.

\paragraph{Language} The third section declares the language for which
a type system should be specified. This language needs to be present
as an \gls{sdf} module located at the specified path. We call this
language from now on \textit{target language}.

\begin{example}{~}
\begin{lstlisting}[language=sltc]
language specifications/simply-typed-lambda-calculus/syntax
\end{lstlisting}
\label{ex:language-section}
\end{example}

In Example~\ref{ex:language-section} the language definition at
\lstinline[breaklines=true]|specifications/simply-typed-lambda-calculus/syntax.sdf|
is used, this path is relative to the syntax folder of the Spoofax
project.

\paragraph{Contexts} The fifth section declares the contexts that can
be used in the judgments and rules. Informally these contexts are
declared as cross-products of non-terminals, i.e.\ an context is a set
consisting of pairs of terminals that can be produced by the
non-terminals in the declaration. Every context has a name, which can
be used in further declarations. Lookups may differ for contexts and
use cases, therefore one has to annotate the non-terminals with input
and output tags. Terminals at positions that are tagged with input are
used to look up terminals tagged with output that are saved in the
context. An context for which all non-terminals are tagged with input,
is equivalent to a normal look up in a set and will return whether the
tuple could be found. An context with only outputs acts as a sink, one
can put things into it, but never retrieve anything back.

\paragraph{Meta-variables} The fourth section declares
meta-variables. The declaration of a meta-variable consists of a
class, a prefix and a set of non-terminals from the target
language. We use this class to distinguish different kinds of
meta-variables. Currently we use them only for merging meta-variables
definitions when resolving imports. For details
see~\ref{sec:generate-sdf}.

The set of non-terminals defines the scope of a meta-variable. Every
non-terminal from the target language contained in this set is
extended with meta-variables. In other words, a meta-variable is a
substitute for every terminal that can be produced from one of the
non-terminals. We explain the extension of the target language in
detail in Section~\ref{sec:generate-sdf}.

Syntactically a meta-variable is a string of numbers and letters that
is prefixed with the prefix of the meta-variable definition. The sole
purpose of the prefix is to avoid syntactic ambiguities. The prefix
itself can consist of numbers, letters and the following symbols
\verb|~|, \verb|$|, \verb|%|, \verb|&| and \verb|?|.
\todo{Is this list complete?} Usually a prefix is chosen such that it
is not a prefix of a construct of the target language.

\begin{example}{~}
\begin{lstlisting}[language=sltc]
meta-variables 	Term "~" { Type Exp }
                Ctx "$" { Context }
                Id "%" { ID }
\end{lstlisting}
\label{ex:meta-variable-section}
\end{example}

Example~\ref{ex:meta-variable-section} declares three classes of
meta-variables. The first class is called \verb|Term| and each
meta-variable of this class has the prefix \verb|"~"|. Productions
that produce meta-variables of this class are added to the
non-terminals \verb|Type| and \verb|Exp|.

\paragraph{Judgments} The sixth section of the module declares
judgments. Judgments in our specification language are the basic
building blocks of the rules defined in the next section, as it is
common in deduction systems. They are the ``syntax'' of the type
system, the semantics is defined by the rules.

A judgment can be defined rather arbitrarily from a combination of
strings of letters and numbers, non-terminals of the target language
and the names of the contexts. Those can be mixed freely, as long as a
string separates the non-terminals and context names. This restriction
is only needed to reduce the number of syntactic ambiguities in the
language. Judgments do not have a name and each judgment must be
closed with a dot.

Non-terminals of the target language and context names need to be
annotated with input/output-tags. Those tags describe which parts of
the judgment need to be computed by rule application and which are
provided as input parameters to the rule application. Contexts
currently only support the input tag.

\begin{example}{~}
\begin{lstlisting}[language=sltc]
judgments Context{I} "|-" Exp{I} ":" Type{O}.
          Type{I} "<:" Type{I}.
\end{lstlisting}
\label{ex:judgment-section}
\end{example}

Example~\ref{ex:judgment-section} shows two judgments. The first could
be the typing judgment of a variant of the simply typed lambda
calculus with a context and an expression of the target language as
input and a type of the target language as output. The second judgment
defines a relation between the types of the target language, i.e.\ it
has only input positions. This judgment could represent a subtyping
relation.

\paragraph{Rules} The seventh section of the module declares the
(typing) rules. These rules define the semantics for the judgments
declared in the previous section. The syntax of the rules replicates
the form of inference rules: A (possibly empty) list of premisses
separated from a conclusion by a horizontal line. Premisses and
conclusion are instantiated judgments. All meta-variables that occur
in freely in rules are implicitly all-quantified. This means that all
meta-variables are all-quantified, as there is not mechanism to bind
variables in typing rules.

Rules can be annotated with a name. This increases the readability of
the specification and allows to create human readable derivation
traces. The rules have also support for custom error messages. There
are two kinds of error annotation. Premisses can be annotated with
\verb|@error msg|, where \verb|msg| can contain meta-variables and the
special symbol \verb|INFTYPE| interleaved with arbitrary
strings. Those errors are thrown if the premise could not be derived
or if the calculated output does not match the expected output. The
meta-variables are instantiated with the appropriate terms and
\verb|INFTYPE| with the expected output. The other kind of error
messages can also be annotated on the conclusion. Those errors are
prefixed with \verb|@implicit| and are thrown if an implicit equality
between two meta-variables cannot be satisfied. The meta-variables are
distinguished in the error message by \verb|@[number]|
annotations. How error messages are implemented in the type checker
generator is explained in Section~\ref{sec:constr-gener} and
Section~\ref{sec:constraint-solving}.

\begin{example}{~}
\begin{lstlisting}[language=sltc]
judgments
TermBinding{I} "|" TypeBinding{I} "|-" Exp{I} ":" Type{O}.
Type{O} "= [" ID{I} "->" Type{I} "]" Type{I}.

rules

===================== Subst-Eq
~S = [ %x -> ~S ] %x@1    @implicit %x " does not equal " %x@1.

~U = [ %x -> ~S ] ~T @error ~U "is not" ~T "where" %x "is
                            replaced by" ~S.
$C1 | $C2 |- ~e : all %x . ~T 
@error ~e "should have type all" %x "." %~T "but has type" { }.
============================== T-Tapp
$C1 | $C2 |- ~e [ ~S ] : ~U
\end{lstlisting}
\label{ex:rules}
\end{example}

In Example~\ref{ex:rules} the rules \verb|Subst-Eq| and \verb|T-Tapp|
from the SystemF \todo{Reference} implementation are
shown. \verb|Subst-Eq| has no premisses and an implicit equality in
the conclusion. Rule \verb|T-Tapp| show how the expected output is
used in the error messages and how premisses are annotated with error
messages. All error message annotation belong to the preceding
premise.

\paragraph{Conjectures} Tests for a specification are called
\textit{conjectures}. Their syntax is similar to the syntax of rules,
with two exceptions. It is not possible to annotate premisses or
conclusions with error messages and a conjecture can be marked as
\textit{not derivable} by prepending the separating line with a
slash. Marking conjectures not derivable allows to formulate negative
tests.

\begin{example}{~}
\begin{lstlisting}[language=sltc]
============================
() |- let fac : int -> int = 
  fix f : int -> int (
    fun n : int (
      ifz n then 1 
      else n * (f (n - 1))
    )
  )
 in (fac 3) : int

/===========================
() |- fun x : int (x) : int
\end{lstlisting}
\label{ex:conjecture-section}
\end{example}

In Example~\ref{ex:conjecture-section} two conjectures of the PCF
implementation are shown. They use the judgment shown in
Example~\ref{ex:judgment-section}. The first conjecture asserts that
the type of the faculty function apply to three is \verb|int| and the
second conjecture asserts that \verb|fun x : int (x)| does not have
type \verb|int|.

Line comments (\verb|//|) and block comments (\verb|/* â€¦ */|) can be
insert everywhere in the module.

How does this design reflect the characteristics from the beginning of
this chapter? We will address this point by point.

\begin{description}
\item[Usage] Formal definitions of type systems usually consist of
  judgment, rules and auxiliary definitions for contexts. All those
  elements can be represented in a natural way in the specification
  language. Judgments can be defined as an arbitrary, as long as this
  syntax does not create ambiguities, combination of non-terminals and
  separation symbols. Rules are written in a natural deduction style,
  because this is the most common representation for typing rules and
  acknowledges the deductive nature of typing rules in
  general. Contexts can be defined using a set like notation. This is
  close to the intuitive semantics of contexts and allows to generate
  commonly used syntax.
\item[Declarative] Everything that can be defined in the specification
  language has no side effects or possibilities to embed executable
  code.
\item[Modularity] \todo[inline]{Imports are not implemented yet.}
\item[Integration] Type systems can be defined for every programming
  language for which a \gls{sdf} syntax definition exists. These
  definitions can be used in most cases without further
  modifications. One requirement is that they introduce for every
  context-free production a constructor. Modifications are also needed
  if one wants to use a language concept inductively in the type
  system, but has not implemented this concept with explicit induction
  in the syntax. An example for this is the implementation of records
  in the simply typed lambda calculus. \todo{Reference}
\end{description}
\section{Implementation}
\label{sec:generate-sdf}
In this section we describe how the specification language is
implemented and how the new syntactic constructs that can be defined
in a specification are integrated.

The specification language is itself defined in \gls{sdf} and consists
of four \gls{sdf} modules. The module \verb|Common| which consists of
lexical definitions that are used in multiple modules, the module
\verb|BaseLanguage| which defines the syntax of the specification
language, the module \verb|Generated| which contains new syntax that
was define in a specification and the main module \verb|SLTC| that
combines the previous modules.

The module \verb|Common| is not particularly interesting therefore we
will not explain it in detail but mention it when it is used in other
modules.

The syntax of the specification language is defined in the module
\verb|BaseLanguage|, which is parameterized by the non-terminals
\verb|TypingJudgment| and \verb|MetaVariable|. Those non-terminals
depend on the actual target language and are therefore defined in
\verb|Generated|. \todo[inline]{What is interesting of the
  implementation?}

In a fresh project the module \verb|Generated| does not exist in the
syntax folder, as no specification was activated. If the project is
build, a dummy module is copied from the resource folder. This module
contains empty productions for the non-terminals \verb|TypingJudgment|
and \verb|MetaVariable|. This dummy module ensures that a compilation
of the whole project is possible, without a specification (e.g.\ to
run tests). The strategy \verb|toSdf| generates a specification
specific \verb|Generated| module. 

\todo[inline]{Insert description of the generate-sdf module here}

The module \verb|SLTC| plugs all modules together. It imports the
module \verb|Generated| and instantiates the parameters of module
\verb|BaseLanguage|.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../report"
%%% End: 
