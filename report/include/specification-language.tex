\chapter{Specification Language}
\label{cha:spec-lang}
Our type system specification language is a \gls{dsl} for people
familiar with type systems or type theory. While developing it, we had
the following goals in mind that will be described below. The
specification language should be

\begin{itemize}
\item close to text-book formalisms used in the type system community
\item purely declarative
\item modular
\item usable with existing syntax definitions of programming languages
\end{itemize}

Those characteristics fit well with the goals of making it easy to
experiment with type systems and to create type systems from a
high-level specification.
\section{Design \& Architecture}
\label{sec:design--architecture}
In this sections we introduce the architecture of the specification
language with references to a small examples and argue how this
architecture reflects the goals mentioned above.

Specifications in our specification language are divided into eight
sections, of which two are optional. The sections have to be present
in the order they are introduced.

\paragraph{Module name} The first section declares the name of the
specification module. This name is a unique identifier and used for
imports.

\paragraph{Imports} The second section declares which other type
system specifications are imported and is optional. It is possible to
prevent sections of a module from being imported. Sections that shall
be excluded have to be listed in parenthesis after the module name.

\begin{example}{}
\begin{lstlisting}[language=sltc]    
import some-specification (language contexts)
\end{lstlisting}
\label{ex:import-section}
\end{example}

Example~\ref{ex:import-section} imports the specification module
\code|some-specification| without the sections \code|language| and
\code|contexts|.

\paragraph{Language} The third section declares the language for which
a type system should be specified. This language needs to be present
as an \gls{sdf} module located at the specified path. We call this
language from now on \emph{target language}. If other modules are
imported the target language must be defined only once.

\begin{example}{~}
\begin{lstlisting}[language=sltc]
language specifications/simply-typed-lambda-calculus/syntax
\end{lstlisting}
\label{ex:language-section}
\end{example}

In Example~\ref{ex:language-section} the language definition at
\code|specifications/simply-typed-lambda-calculus/syntax.sdf|
is used, this path is relative to the \code|syntax| folder of the Spoofax
project.

\paragraph{Contexts} The fifth section declares the contexts that can
be used in the judgments and rules. Informally these contexts are
declared as cross-products of non-terminals, i.e.\ a context is a set
consisting of tuples of terminals that can be produced by the
non-terminals in the declaration. Every context has a name, which can
be used as a non-terminal in the specification.

Contexts serve in most use cases as bindings for variables. Therefore
it is necessary to be able to look up terminals in a context. In the
context declaration each non-terminal is annotated with an input
(\code|{I}|) and output \code|{O}| tag. Those tags specify the key and
value positions of the context. Depending on those annotations we
generate look up functions. If all non-terminals are tagged as inputs
the generated look up function will perform a normal membership
test. However a context with only output tags is not useful as it is
not possible to add elements to it.

Given a context declaration \code|Z := A{I} x B{I} x C{O} x D{O}| an
instance of this context looks like \code|(a : b : c : d) ; z| where
\code|a|, \code|b|, \code|c| and \code|d| are terminals produced from
the non-terminals \code|A|, \code|B|, \code|C|, \code|D|,
respectively. \code|z| is an other instance of context \code|Z| or the
empty context, which is written \code|()|.

\begin{example}
\begin{lstlisting}[language=sltc]
contexts Binding := ID{I} x Type{O}
\end{lstlisting}
\label{ex:context-section}
\end{example}

Example~\ref{ex:context-section} shows a context called \code|Binding|
that consists of a non-terminal \code|ID| tagged as input and a
non-terminal \code|Type| tagged as output. This contexts models a type
binding for identifiers. We generate from this context declaration a
look up function of the form \code|i : t in c| where \code|i|
represents a terminal produced from \code|ID|, \code|t| a terminal
produced from \code|Type| and \code|c| represents an instance of
context \code|Binding|. 

\paragraph{Meta-variables} The fourth section declares
meta-variables. In specifications meta-variables are used to refer to
expressions of the target language and to contexts. The declaration of
a meta-variable consists of a class, a prefix and a set of
non-terminals from the target language. We use the class to
distinguish different kinds of meta-variables. Currently we use
classes only for merging meta-variable declarations when resolving
imports. For details see~\ref{sec:generate-sdf}.

The set of non-terminals defines the scope of a meta-variable. Every
non-terminal from the target language contained in this set is
extended with meta-variables. In other words, a meta-variable is a
substitute for every terminal that can be produced from one of the
non-terminals. We explain the extension of the target language in
detail in Section~\ref{sec:generate-sdf}.

Syntactically a meta-variable is a string of numbers and letters that
is prefixed with the prefix of the meta-variable definition. The sole
purpose of the prefix is to avoid syntactic ambiguities. The prefix
itself can consist of numbers, letters and the following symbols
\code|~|, \code|$|, \code|%|, \code|&| and \code|?|. %% $
There is currently no way to add new symbols to that list, but editing
the syntax definition of the specification language. Usually a prefix
is chosen such that it is not a prefix of a construct of the target
language.

\begin{example}{~}
\begin{lstlisting}[language=sltc]
meta-variables 	Term "~" { Type Exp }
                Ctx "$" { Context }
                Id "%" { ID }
\end{lstlisting}
\label{ex:meta-variable-section}
\end{example}

Example~\ref{ex:meta-variable-section} declares three classes of
meta-variables. The first class is called \code|Term| and each
meta-variable of this class has the prefix \code|"~"|. Productions for
meta-variables of this class are added to the non-terminals
\code|Type| and \code|Exp|.

\paragraph{Judgments} The sixth section of a type system specification
module declares judgments. In our specification language judgments are
the basic building blocks of the rules defined in the next
section. This is common in the specification of deduction systems in
general. Judgments can be thought of as the ``syntax'' of the type
system, the semantics is defined by the rules.

A judgment can be defined rather arbitrarily from a combination of
strings of letters and numbers, non-terminals of the target language
and the names of the contexts. Those can be mixed freely, as long as a
string separates the non-terminals and context names. This restriction
is only needed to reduce the number of syntactic ambiguities in the
language. Judgments do not have a name as it is not possible to
quantify over them. To separate judgment declarations from each other,
each declaration must be finalized with a dot.

Non-terminals of the target language and context names need to be
annotated with input/output-tags. Those tags describe which parts of
the judgment need to be computed by rule applications and which are
provided as input parameters to the rule application. Contexts
currently only support the input tag.

\begin{example}{~}
\begin{lstlisting}[language=sltc]
judgments Context{I} "|-" Exp{I} ":" Type{O}.
          Type{I} "<:" Type{I}.
\end{lstlisting}
\label{ex:judgment-section}
\end{example}

Example~\ref{ex:judgment-section} shows two judgments. The first could
be the typing judgment of a variant of the simply typed lambda
calculus with a context and an expression of the target language as
input and a type of the target language as output. The second judgment
defines a relation between the types of the target language, i.e.\ it
has only input positions. This judgment could represent a subtyping
relation.

\paragraph{Rules} The seventh section of the module declares the
(typing) rules. These rules define the semantics for the judgments
declared in the previous section. The syntax of the rules replicates
the form of inference rules: A (possibly empty) list of premises
separated from a conclusion by a horizontal line. Premises and
conclusion are instantiated judgments. All meta-variables that occur
free in rules are implicitly all-quantified. This means that all
meta-variables are all-quantified, as there is no mechanism to bind
variables in typing rules.

Rules can be annotated with a name. The names increase the readability
of the specification and allow to create human readable derivation
traces. The rules have also support for custom error messages. There
are two kinds of error annotations. Premises can be annotated with
\code|@error msg|, where \code|msg| can contain meta-variables and
holes (written \code|{}|) interleaved with arbitrary strings. Those
errors are thrown if the premise could not be derived or if the
calculated output does not match the expected output. The
meta-variables are instantiated with the appropriate terms and the
hole with the expected output. The other kind of errors are prefixed
with \code|@implicit| and are thrown if an implicit equality between
two meta-variables cannot be satisfied. The meta-variables are
distinguished in the error message by \code|@[number]| annotations,
where \code|number| is a natural number. The conclusion can also be
annotated with error messages for implicit
equalities. Section~\ref{sec:constr-gener} and
Section~\ref{sec:constraint-solving} explain how error messages are
implemented in the type checker generator.

\begin{example}{~}
\begin{lstlisting}[language=sltc]
judgments
TermBinding{I} "|" TypeBinding{I} "|-" Exp{I} ":" Type{O}.
Type{O} "= [" ID{I} "->" Type{I} "]" Type{I}.

rules

===================== Subst-Eq
~S = [ %x -> ~S ] %x@1    @implicit %x " does not equal " %x@1.


~U = [ %x -> ~S ] ~T @error ~U "is not" ~T "where" %x "is
                            replaced by" ~S.
$C1 | $C2 |- ~e : all %x . ~T 
@error ~e "should have type all" %x "." %~T "but has type" { }.
============================== T-Tapp
$C1 | $C2 |- ~e [ ~S ] : ~U
\end{lstlisting}
\label{ex:rules}
\end{example}

Example~\ref{ex:rules} shows the rules \code|Subst-Eq| and
\code|T-Tapp| from the SystemF \todo{Reference}
implementation. \code|Subst-Eq| has no premises and an implicit
equality in the conclusion. Rule \code|T-Tapp| shows how the expected
output is used in the error messages and how premises are annotated
with error messages. All error message annotations belong to the
preceding premise.

\paragraph{Conjectures} Tests for a specification are called
\textit{conjectures}. Their syntax is similar to the syntax of rules,
with two exceptions. It is not possible to annotate premises or
conclusions with error messages and a conjecture can be marked as
\textit{not derivable} by prepending the separating line with a
slash. Marking conjectures not derivable allows to formulate negative
tests.

\begin{example}{~}
\begin{lstlisting}[language=sltc]
============================
() |- let fac : int -> int = 
  fix f : int -> int (
    fun n : int (
      ifz n then 1 
      else n * (f (n - 1))
    )
  )
 in (fac 3) : int

/===========================
() |- fun x : int (x) : int
\end{lstlisting}
\label{ex:conjecture-section}
\end{example}

Example~\ref{ex:conjecture-section} shows two conjectures of the PCF
implementation. They use the judgment shown in
Example~\ref{ex:judgment-section}. The first conjecture asserts that
the type of the faculty function applied to \code|3| is \code|int| and
the second conjecture asserts that \code|fun x : int (x)| has type
\code|int| is not derivable.

Line comments (\code|//|) and block comments (\code|/* ... */|) can be
inserted everywhere in the module.

How does this design reflect the characteristics from the beginning of
this chapter? We will address this point by point.

\begin{description}
\item[Usage] Formal definitions of type systems usually consist of
  judgment, rules and auxiliary definitions for contexts. All those
  elements can be represented in a natural way in the specification
  language. Judgments can be defined as an arbitrary combination of
  non-terminals and separation symbols, as long as the syntax does not
  create ambiguities. Rules are written in a natural deduction style,
  because this is the most common representation of typing rules and
  it acknowledges the deductive nature of typing rules in
  general. Contexts can be defined using a set like notation. This is
  close to the intuitive semantics of contexts and allows to generate
  commonly used syntax.
\item[Declarative] Everything that can be defined in the specification
  language has no side effects or possibilities to embed executable
  code.
\item[Modularity] Type system specifications are organized in
  composeable modules. A module can import other modules or even only
  parts of other modules. This enables the reuse of existing type
  specifications and the separation of orthogonal features.
\item[Integration] Type systems can be defined for every programming
  language for which a \gls{sdf} syntax definition exists. These
  definitions can be used in most cases without further
  modifications. One of the requirements is that they introduce a
  constructor for every context-free production. Modifications are
  also needed if one wants to use a language concept inductively in
  the type system, but has not implemented this concept with explicit
  induction in the syntax. The implementation of records in the simply
  typed lambda calculus is an example for this. \todo{Reference}
\end{description}
\section{Implementation}
\label{sec:generate-sdf}
In this section we describe how the specification language is
implemented and how the new syntactic constructs that can be defined
in a specification are integrated.

The specification language itself is defined in \gls{sdf} and consists
of four \gls{sdf} modules. The module \code|Common| which consists of
lexical definitions that are used in multiple modules, the module
\code|BaseLanguage| which defines the syntax of the specification
language, the module \code|Generated| which contains new syntax that
was defined in a specification and the main module \code|SLTC| that
combines the previous modules.

The module \code|Common| only defines character classes and lexical
restrictions therefore we will not explain it in detail.

The syntax of the specification language, which is independent of the
target language, is defined in the module \code|BaseLanguage|, which
is parameterized by the non-terminals \code|TypingJudgment| and
\code|MetaVariable|. These non-terminals depend on the actual target
language and are therefore defined in \code|Generated|.

In a new project the module \code|Generated| does not exist in the
syntax folder, as no specification is in use. Building a project
copies a dummy \code|Generated| module from the resource folder into
the syntax folder. Module \code|Generated| contains empty productions
for the non-terminals \code|TypingJudgment| and \code|MetaVariable|
and it ensures that a compilation of the whole project is possible
without a specification (e.g.\ to run tests). The strategy
\code|toSdf| generates a specification specific \code|Generated|
module.

The strategy \code|toSdf| transforms a specification into a \gls{sdf}
\gls{ast} which is then pretty printed and saved in the syntax
folder. The generated module \code|Generated| imports module
\code|Common| and the \gls{sdf} file of the target language. Module
\code|Generated| also contains context-free grammars for context,
meta-variables and judgment declarations.

For each context declaration the strategy \code|make-contexts|
generates productions for the empty context, context bindings and
context look ups. Figure~\ref{fig:context-productions} shows the
resulting productions. Furthermore \textit{Name} is the name of the
context declaration and \code|n| the position of the context
declaration.

\todo{Increase space between figures}

\begin{figure}
\begin{grammar}
  <Name> ::= `ContextEmpty-n'
  \alt `ContextBind-n' <Elem> <Name>
  \alt `ContextLookup-n' <Elem> <Name>
  \alt `(' <Name> `)'

  <Elem> ::= <String> | <String> `:' <Elem>
\end{grammar}
\caption{Context productions}
\label{fig:context-productions}
\end{figure}

Figure~\ref{fig:meta-variable-productions} shows the productions
created by \code|make-variable| for meta-variables. A meta-variable
consists of its prefix, a name and of an optional error
annotation. There are two productions for meta-variables. The first
extends the non-terminal \textit{Scope} of the target language and the
second enables the use of meta-variables in error messages. In the
constructor of meta-variables \code|m| is either the context number in
case \textit{Scope} is a context and otherwise the meta-variable
class.

\begin{figure}
\begin{grammar}
  <Scope> ::= `MetaVariable-m' <Prefix> <MetaVariableName> <Anno>

  <MetaVariable> ::= `MetaVariable-m' <Prefix> <MetaVariableName>
  <Anno>

  <Anno> ::= $\epsilon$ | `@' <ErrorNumber>
\end{grammar}
\caption{Meta-variable productions}
\label{fig:meta-variable-productions}
\end{figure}

Strategy \code|make-judgment| creates productions for judgment
declarations. For each judgment we generate a production that consists
of all non-terminals separated by the separators from the
declaration. In case of a built-in the constructor of the constructor
has the name of the built-in, otherwise it is the judgment position
append to the string \code|TypingJudgment|.

The module \code|SLTC| plugs all modules together. It imports the
module \code|Generated| and instantiates the parameters of module
\code|BaseLanguage|.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../report"
%%% End: 
