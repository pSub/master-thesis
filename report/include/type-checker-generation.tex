\chapter{Type Checker Generation}
\todo[inline]{Terminology: Type Checker vs. Type Inference}
\section{Goals}
This section briefly describes and motivates the design goals of the
type check generator.

The first goal is to produce fast type checkers, even if the type
system specification is not geared towards performance. Mainly this
means to try to deal with non-syntax directed typing rules without
backtracking. The motivation for this is, that non-syntax directed
typing rules are often more readable and changes have mainly local
effects.

The second goal is to design a modular type checker generator. A type
checker generator that can be easily adapted and that facilitates the
exchange of components. This modularity is desirable because it
increases the reusability and makes it possible to combine projects.

The third goal is to generate type checkers emit readable error
messages if a program is not well-typed. This is essential to make the
type checker usable in any way.
\section{Architecture}
The type checker generator has two phases: Template generation and
template optimization. In the template generation phase the type
system specification is transformed with minor modifications into
templates. A template is different representation for a typing rule,
which is better suited for type checking. Templates will be introduced
in detail in Section~\ref{sec:constraint-templates}. In the template
optimization phase, those templates are optimized. Those optimizations
aim to reduce the amount of non-determinism in the type system and
therefore reduce the amount of backtracking in the type checker. The
end product after those two phases, is a file that contains the
optimized templates.

The templates are the input for the next two phases, which are located
in the type checker. Instead of generating the type checker directly
from the specification, a generic type checker is that takes the
templates as input. The generic type checker has two phases:
Constraint generation and constraint solving. The constraint
generation phase has the templates and the program expression that shall be type
checked as inputs. To generate the constraints the program expression
is traversed according to the templates and the emitted constraints
are collected. Those constraints are then solved in the constraint
solving phase.

The four phases correspond to modules. Each phase has a well-defined
interface, therefore the implementation can be exchanged freely. This
makes it possible to use different constraint solvers, constraint
generators or template optimizers.

\begin{figure}
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,align=center,node distance=2cm,
  thick,main node/.style={rectangle,fill=blue!20,draw,font=\small\bfseries}]

  \node[main node] (1) {Template Generation};
  \node[main node] (2) [right=3cm of 1] {Template Optimization};
  \node[main node] (3) [below of=2] {Constraint Generation};
  \node[main node] (4) [below of=1] {Constraint Solving};

  \path[every node/.style={font=\small}]
    (1) edge node [right, below] {Templates} (2)
    (2) edge node [right] {Extended Templates} (3)
    (3) edge node [right, below] {Constraints} (4);
\end{tikzpicture}
\caption{Phases of the type checker generator}
\label{fig:phases}
\end{figure}
\section{Implementation}
\label{sec:implementation}
\subsection{Constraint Templates}
\label{sec:constraint-templates}
\subsection{Constraint Template Optimization}
\label{sec:constr-templ-optim}
\subsection{Constraint Generation}
\label{sec:constr-gener}
\subsection{Constraint Solving}
\label{sec:constraint-solving}
\section{Performance}
\label{sec:performance}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../report"
%%% End: 
