\chapter{Type Checker Generation}
\todo[inline]{Terminology: Type Checker vs. Type Inference}
\section{Goals}
This section briefly describes and motivates the design goals of the
type check generator.

The first goal is to produce fast type checkers, even if the type
system specification is not geared towards performance. Mainly this
means to try to deal with non-syntax directed typing rules without
backtracking. The motivation for this is, that non-syntax directed
typing rules are often more readable and changes have mainly local
effects.

The second goal is to design a modular type checker generator. A type
checker generator that can be easily adapted and that facilitates the
exchange of components. This modularity is desirable because it
increases the reusability and makes it possible to combine projects.

The third goal is to generate type checkers emit readable error
messages if a program is not well-typed. This is essential to make the
type checker usable in any way.
\section{Architecture}
\todo[inline]{Describe more explicitly that we use constraint solving}
The type checker generator has two phases: Template generation and
template optimization. In the template generation phase the type
system specification is transformed with minor modifications into
templates. A template is different representation for a typing rule,
which is better suited for type checking. Templates will be introduced
in detail in Section~\ref{sec:constraint-templates}. In the template
optimization phase, those templates are optimized. Those optimizations
aim to reduce the amount of non-determinism in the type system and
therefore reduce the amount of backtracking in the type checker. The
end product after those two phases, is a file that contains the
optimized templates.

The templates are the input for the next two phases, which are located
in the type checker. Instead of generating the type checker directly
from the specification, a generic type checker is that takes the
templates as input. The generic type checker has two phases:
Constraint generation and constraint solving. The constraint
generation phase has the templates and the program expression that shall be type
checked as inputs. To generate the constraints the program expression
is traversed according to the templates and the emitted constraints
are collected. Those constraints are then solved in the constraint
solving phase.

The four phases correspond to modules. Each phase has a well-defined
interface, therefore the implementation can be exchanged freely. This
makes it possible to use different constraint solvers, constraint
generators or template optimizers.

\begin{figure}
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,align=center,node distance=2cm,
  thick,main node/.style={rectangle,fill=blue!20,draw,font=\small\bfseries}]

  \node[main node] (1) {Template Generation};
  \node[main node] (2) [right=3cm of 1] {Template Optimization};
  \node[main node] (3) [below of=2] {Constraint Generation};
  \node[main node] (4) [below of=1] {Constraint Solving};

  \path[every node/.style={font=\small}]
    (1) edge node [right, below] {Templates} (2)
    (2) edge node [right] {Extended Templates} (3)
    (3) edge node [right, below] {Constraints} (4);
\end{tikzpicture}
\caption{Phases of the type checker generator}
\label{fig:phases}
\end{figure}
\section{Implementation}
\label{sec:implementation}
The following sections describe the implementation of the type checker
generator, one section per phase.

\subsection{Constraint Templates}
\label{sec:constraint-templates}
In the first phase type system specifications are translated into
templates. A template is a intermediate representation of a typing
rule that is more suitable for the constraint generation process and
defined as following.

\begin{definition}{Template}
  \todo[inline]{Complete this grammar and synchronize it with the
    stratego source code}
  \begin{grammar}
    <Template> ::= `Template__' <Vars> <Premisses> <Conjecture>

    <Conjecture> ::= `Conjecture__' <Int> <Name> <Pattern> <Outputs> <Constraints>

    <Name> ::= `Some' <String> | `None'
  \end{grammar}
\end{definition}

Before describing the structure of templates in depth, we want to
highlight the conceptual differences between templates and typing
rules. First templates take advantage of the input/output tags of
typing judgments an second they already carry a set of constraints.

The structure of a template is close to the structure of a typing
rule, there are premisses and a conjecture. In addition to those there
is a list of variables for ever premise. Those variables correspond to
the output positions of the premisses in the typing rule, for each
output position there exists one variable. They are used to bind the
output of evaluating the premisses to the expected output.

Premisses in templates have multiple shapes: Judgments, context
lookups, equalities and inequalities.

\begin{description}
\item[Judgments] are the user defined judgments form the
  specification. They consist of the judgment
  number \refcallout{judgment:number}, the positions of the judgment
  that are marked as inputs \refcallout{judgment:inputs} and a description of context
  modifications \refcallout{judgment:context}. There are three types of context modifications.
  Example:
\begin{verbatim}
Judgment__(
          1 !callout`judgment:number'
        , [Var__("X219")] !callout`judgment:inputs'
        , [ (1, [Var__("X217")], [Var__("X218")])
          , Ctx__(1)
          , Ctx__(2)
          ] !callout`judgment:context'
        )
\end{verbatim}
\item[Context lookups] consist of the context number
  \refcallout{lookup:ctx} and of the input positions of the context
  lookup \refcallout{lookup:inputs}. Example:
\begin{verbatim}
Lookup__(1 !callout`lookup:ctx', [Var__("X213")] !callout`lookup:inputs')
\end{verbatim}
\item[(In)equalities] are predefined judgments and therefore treated
  separately. As they have no outputs the error messages are stored
  directly in the premise. Apart from that they behave like normal
  judgments. Example:
\begin{verbatim}
Neq__(Var__("X241"), Var__("X240"), None())
\end{verbatim}
\end{description}

\begin{figure}
  \centering
  \begin{minipage}{.45\linewidth}
\begin{verbatim}
%x : ~T in $C1
=============== T-Var
$C1 | $C2 |- %x : ~T
\end{verbatim}
  \end{minipage}
  \begin{minipage}{.45\linewidth}
\begin{verbatim}
Template__(
    [[Var__("X212")]]
  , [(Lookup__(
        1,
       [Var__("X213")]),
       [])]
  , Conjecture__(
      1
    , Some("T-Var")
    , ([Var(Var__("X213"))],
       [Ctx__(1), Ctx__(2)])
    , [Var__("X214")]
    , [ CEq__(
          Var__("X212")
        , Var__("X214")
        , None
        )
      ]
    )
  )
\end{verbatim}
  \end{minipage}
  \caption{Typing rule and template of T-Var}
  \label{fig:template-example}
\end{figure}
\subsection{Constraint Template Optimization}
\label{sec:constr-templ-optim}
\subsection{Constraint Generation}
\label{sec:constr-gener}
\subsection{Constraint Solving}
\label{sec:constraint-solving}
\section{Performance}
\label{sec:performance}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../report"
%%% End: 
