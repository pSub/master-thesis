\chapter{Type Checker Generation}
\todo[inline]{Terminology: Type Checker vs. Type Inference}
\section{Goals}
This section briefly describes and motivates the design goals of the
type check generator.

The first goal is to produce fast type checkers, even if the type
system specification is not geared towards performance. Mainly this
means to try to deal with non-syntax directed typing rules without
backtracking. The motivation for this is, that non-syntax directed
typing rules are often more readable and changes have mainly local
effects.

The second goal is to design a modular type checker generator. A type
checker generator that can be easily adapted and that facilitates the
exchange of components. This modularity is desirable because it
increases the reusability and makes it possible to combine projects.

The third goal is to generate type checkers emit readable error
messages if a program is not well-typed. This is essential to make the
type checker usable in any way.
\section{Architecture}
\todo[inline]{Describe more explicitly that we use constraint solving}
The type checker generator has two phases: Template generation and
template optimization. In the template generation phase the type
system specification is transformed with minor modifications into
templates. A template is different representation for a typing rule,
which is better suited for type checking. Templates will be introduced
in detail in Section~\ref{sec:constraint-templates}. In the template
optimization phase, those templates are optimized. Those optimizations
aim to reduce the amount of non-determinism in the type system and
therefore reduce the amount of backtracking in the type checker. The
end product after those two phases, is a file that contains the
optimized templates.

The templates are the input for the next two phases, which are located
in the type checker. Instead of generating the type checker directly
from the specification, a generic type checker is that takes the
templates as input. The generic type checker has two phases:
Constraint generation and constraint solving. The constraint
generation phase has the templates and the program expression that shall be type
checked as inputs. To generate the constraints the program expression
is traversed according to the templates and the emitted constraints
are collected. Those constraints are then solved in the constraint
solving phase.

The four phases correspond to modules. Each phase has a well-defined
interface, therefore the implementation can be exchanged freely. This
makes it possible to use different constraint solvers, constraint
generators or template optimizers.

\begin{figure}
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,align=center,node distance=2cm,
  thick,main node/.style={rectangle,fill=blue!20,draw,font=\small\bfseries}]

  \node[main node] (1) {Template Generation};
  \node[main node] (2) [right=3cm of 1] {Template Optimization};
  \node[main node] (3) [below of=2] {Constraint Generation};
  \node[main node] (4) [below of=1] {Constraint Solving};

  \path[every node/.style={font=\small}]
    (1) edge node [right, below] {Templates} (2)
    (2) edge node [right] {Extended Templates} (3)
    (3) edge node [right, below] {Constraints} (4);
\end{tikzpicture}
\caption{Phases of the type checker generator}
\label{fig:phases}
\end{figure}
\section{Implementation}
\label{sec:implementation}
The following sections describe the implementation of the type checker
generator, one section per phase.

\subsection{Template Generation}
\label{sec:constraint-templates}
In the first phase type system specifications are translated into
templates.

\subsubsection{Templates}
A template is a intermediate representation of a typing rule that is
more suitable for the constraint generation process and defined as
following.

\begin{definition}{Template}
  \todo[inline]{Complete this grammar and synchronize it with the
    stratego source code}
  \begin{grammar}
    <Template> ::= `Template__' <Vars> <Premisses> <Conjecture> <Constraints>

    <Conjecture> ::= `Conjecture__' <Int> <Name> <Pattern> <Outputs>

    <Name> ::= `Some' <String> | `None'
  \end{grammar}
\end{definition}

Before describing the structure of templates in depth, the conceptual
differences between templates and typing rules are highlighted.
Templates take advantage of the input/output tags of typing judgments
by splitting everything up into an input and output part. This will
become handy in the constraint generation phase. An other difference
is that they already carry some constraints and that the dependencies
between the premisses are resolved.

The structure of a template is close to the structure of a typing
rule, there are premisses and a conjecture. In addition to those there
is a list of variables for ever premise. Those variables correspond to
the output positions of the premisses in the typing rule, for each
output position there is one variable. Further there is a set of
constraints. This set contains equalities that bind the variables of
the premisses to the expected outputs.

\paragraph*{Premisses}
Premisses in templates have multiple shapes: Judgments, context
lookups, equalities and inequalities.

\begin{description}
\item[Judgments] are the user defined judgments form the
  specification. They consist of the judgment number
  \refcallout{judgment:number}, the positions of the judgment that are
  marked as inputs \refcallout{judgment:inputs} and context
  modifications \refcallout{judgment:context}. A context modification
  can either be a addition to a context \refcallout{judgment:bind}
  which is a triple of a context identifier a list of inputs and a
  list of outputs, a context identity \refcallout{judgment:identity}
  which corresponds to the context meta-variables in the specification
  and a reset operation \refcallout{judgment:reset} which resets the given context and corresponds
  to the empty context. Those context modifications are meant to be
  executed from right to left. A detail explanation of the semantics
  will follow in Section~\ref{sec:constr-gener}.

\begin{example}{~}
\begin{verbatim}
Judgment__(
          1 !callout`judgment:number'
        , [Var__("X219")] !callout`judgment:inputs'
        , [ (1, [Var__("X217")], [Var__("X218")]) !callout`judgment:bind'
          , Reset__(1) !callout`judgment:reset'
          , Ctx__(2) !callout`judgment:identity'
          ] !callout`judgment:context'
        )
\end{verbatim}
\label{ex:judgment}
\end{example}

  In example~\ref{ex:judgment} we have judgment one that has only one input
  position and that leaves context as it is, resets context one and
  adds then the input/output pair \verb|Var__("X217")| and
  \verb|Verb__("X218")| to context one.

\item[Context lookups] consist of the context number
  \refcallout{lookup:ctx} and of the input positions of the context
  lookup \refcallout{lookup:inputs}.

\begin{example}
\begin{verbatim}
Lookup__(1 !callout`lookup:ctx', [Var__("X213")] !callout`lookup:inputs')
\end{verbatim}
\label{ex:lookup}
\end{example}

  In example~\ref{ex:lookup} we look up \verb|Var__("X213")| from
  context one.

\item[(In)equalities] are predefined judgments and therefore treated
  separately. As they have no outputs the error messages are stored
  directly in the premise. Apart from that they behave like normal
  judgments.

\begin{example}
\begin{verbatim}
Neq__(Var__("X241"), Var__("X240"), None())
\end{verbatim}
\label{ex:neq}
\end{example}

  In example~\ref{ex:neq} we compare \verb|Var__("X241")| and
  \verb|Var__("X240")| for inequality and provide no error message.
\end{description}

There are cases, in which it is relevant in which order the premisses
are evaluated. Therefore every premise has a list of premisses on
which it depends. Essentially this list contains the position of the
dependency and its output positions. The following example will
illustrate why such dependencies occur and how this is solved in the
template language.

\begin{example}{~}
\begin{verbatim}
judgments
TermBinding{I} "|" TypeBinding{I} "|-" Exp{I} ":" Type{O}.
Type{O} "= [" ID{I} "->" Type{I} "]" Type{I}.

rules
~U = [ %x -> ~S ] ~T
$C1 | $C2 |- ~e : all %x . ~T 
============================== T-Tapp
$C1 | $C2 |- ~e [ ~S ] : ~U
\end{verbatim}
\label{ex:premise-dependencies}
\end{example}

Example~\ref{ex:premise-dependencies} shows the type application rule
of SystemF \todo{Citation} together with the judgment
declarations. One can easily see, that the first premise has an input
positions, namely \verb|%x|, that is part of the output position of
the second premise. Therefore the second premise needs to be evaluated
first to provide the output for the first premise. In the template
generation process the premisses are sorted topologically and are
annotated with the indices and outputs of their dependencies. The
output positions are to know which terms are actually provided by the
dependency. For the first premise the dependency would look like
\verb|(1, [TAll(Var__("X150"), Var__("X149"))])|, where \verb|1|
refers to the second premise in example~\ref{ex:premise-dependencies}
because of the topological sort.

\paragraph{Conclusion}
Conclusions contain the judgment identifier
\refcallout{conclusion:number}, the name of the typing rule (which may
be empty) \refcallout{conclusion:name}, the input positions of the
judgment \refcallout{conclusion:inputs}, the context modifications
\refcallout{conclusion:ctx} as well as the output positions of the
conclusion \refcallout{conclusion:outputs}.

\begin{example}{~}
\begin{verbatim}
Conclusion__(
      3 !callout`conclusion:number'
    , None() !callout`conclusion:name'
    , ( [Var__("X177")] !callout`conclusion:inputs'
      , [(2, [Var__("X178")], []), Ctx__(2)] !callout`conclusion:ctx'
      )
    , [] !callout`conclusion:outputs'
    )
\end{verbatim}
\end{example}

In this example judgment number three is in the conclusion and the
typing rule has no name. There is only one input position and there
has to be at least one element in the second context. The judgment
three has no outputs.

\subsubsection{Generation}
Template generation is mainly done by the Stratego rule
\verb|to-template| that takes a typing rule and returns a
template. The first step in the conversion is the elimination of
implicit equalities in the premisses and the conclusion.

Implicit equalities are transformed in to explicit equalities, by
collecting all variables that occur more than once in an input
position, rename them and create premisses that state the equality of
the newly created variables. Example~\ref{ex:implicit-equalities}
shows this for a typing rule of the judgment

\begin{verbatim}
Type{O} "= [" ID{I} "->" Type{I} "]" Type{I}
\end{verbatim}

which is used for type substitution in the SystemF specification. On
the left of example~\ref{ex:implicit-equalities} you see the typing
rule with implicit equalities and on the right the transformed version
without implicit equalities.

\begin{example}{~}
\newline
  \begin{minipage}[b]{.45\linewidth}
    \begin{verbatim}
=====================
~S = [ %x -> ~S ] %x
\end{verbatim}
  \end{minipage}
  \begin{minipage}[b]{.45\linewidth}
    \begin{verbatim}
%y = %z
=====================
~S = [ %y -> ~S ] %z
\end{verbatim}
  \end{minipage}
\label{ex:implicit-equalities}
\end{example}

If a variable occurs more than twice the equalities for the new
variables are defined transitively.

\todo[inline]{Implicit equalities between inputs and outputs and
  between the contexts}
\todo[inline]{Describe the fiddeling with @implicit}

After this step, there are no implicit equalities left. Now the
premisses of the typing rule are analyzed for inter-dependencies. A
premise depends on an other, if it uses variables in input positions
that occur in an output position of an other premise. As we need to
supply the input positions with concrete terms to check if a premise
holds, a dependency can only be evaluated if all its dependencies are
evaluated. In the generation process we do two things, sort the
premisses according to their dependencies and annotate them with the
output positions of the dependencies, as described in the previous
paragraph. The implementation of this ordering is straightforward,
first the dependencies are collected for each premise. This creates an
transposed dependency graph, that is topologically sorted with the
algorithm by Kahn \cite{Kahn:1962:TSL:368996.369025}. The resulting
topological order is reversed as we look at the transposed dependency
graph.

Now variables for the outputs of the premisses are generated, bound to
the expected outputs. Premisses and conclusions are split up into
inputs, outputs, and context parts and placed at the appropriate
places in the template.

\begin{figure}
  \centering
  \begin{minipage}{.45\linewidth}
\begin{verbatim}
%x : ~T in $C1
=============== T-Var
$C1 | $C2 |- %x : ~T
\end{verbatim}
  \end{minipage}
  \begin{minipage}{.45\linewidth}
\begin{verbatim}
Template__(
    [[Var__("X212")]]
  , [(Lookup__(
        1,
       [Var__("X213")]),
       [])]
  , Conjecture__(
      1
    , Some("T-Var")
    , ([Var(Var__("X213"))],
       [Ctx__(1), Ctx__(2)])
    , [Var__("X214")]
    , [ CEq__(
          Var__("X212")
        , Var__("X214")
        , None
        )
      ]
    )
  )
\end{verbatim}
  \end{minipage}
  \caption{Typing rule and template of T-Var}
  \label{fig:template-example}
\end{figure}
\subsection{Constraint Template Optimization}
\label{sec:constr-templ-optim}
\subsection{Constraint Generation}
\label{sec:constr-gener}
\subsection{Constraint Solving}
\label{sec:constraint-solving}
\todo[inline]{What else should be contained in this section?}
Constraint solving is the last phase of the type checker. As the
constraint language is with only three constructs simple, the
algorithm to solve a constraint set is simple as well.

Unification is used to solve the constraint set. Precisely we use a
variant of Robinson unificiation \todo{Citation}. During the
unification an most general unifier (mgu) is computed to instantiate
the variables in the outputs and (in case of not well-typed programs)
in the error messages.
\section{Performance}
\label{sec:performance}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../report"
%%% End: 
