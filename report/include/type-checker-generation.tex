\chapter{Type Checker Generation}
\todo[inline]{Terminology: Type Checker vs. Type Inference}
\section{Goals}
This section briefly describes and motivates the design goals of the
type check generator.

The first goal is to produce fast type checkers, even if the type
system specification is not geared towards performance. Mainly this
means to try to deal with non-syntax directed typing rules without
backtracking. The motivation for this is, that non-syntax directed
typing rules are often more readable and changes have mainly local
effects.

The second goal is to design a modular type checker generator. A type
checker generator that can be easily adapted and that facilitates the
exchange of components. This modularity is desirable because it
increases the reusability and makes it possible to combine projects.

The third goal is to generate type checkers emit readable error
messages if a program is not well-typed. This is essential to make the
type checker usable in any way.
\section{Architecture}
\todo[inline]{Describe more explicitly that we use constraint solving}
The type checker generator has two phases: Template generation and
template optimization. In the template generation phase the type
system specification is transformed with minor modifications into
templates. A template is different representation for a typing rule,
which is better suited for type checking. Templates will be introduced
in detail in Section~\ref{sec:constraint-templates}. In the template
optimization phase, those templates are optimized. Those optimizations
aim to reduce the amount of non-determinism in the type system and
therefore reduce the amount of backtracking in the type checker. The
end product after those two phases, is a file that contains the
optimized templates.

The templates are the input for the next two phases, which are located
in the type checker. Instead of generating the type checker directly
from the specification, a generic type checker is that takes the
templates as input. The generic type checker has two phases:
Constraint generation and constraint solving. The constraint
generation phase has the templates and the program expression that shall be type
checked as inputs. To generate the constraints the program expression
is traversed according to the templates and the emitted constraints
are collected. Those constraints are then solved in the constraint
solving phase.

The four phases correspond to modules. Each phase has a well-defined
interface, therefore the implementation can be exchanged freely. This
makes it possible to use different constraint solvers, constraint
generators or template optimizers.

\begin{figure}
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,align=center,node distance=2cm,
  thick,main node/.style={rectangle,fill=blue!20,draw,font=\small\bfseries}]

  \node[main node] (1) {Template Generation};
  \node[main node] (2) [right=3cm of 1] {Template Optimization};
  \node[main node] (3) [below of=2] {Constraint Generation};
  \node[main node] (4) [below of=1] {Constraint Solving};

  \path[every node/.style={font=\small}]
    (1) edge node [right, below] {Templates} (2)
    (2) edge node [right] {Extended Templates} (3)
    (3) edge node [right, below] {Constraints} (4);
\end{tikzpicture}
\caption{Phases of the type checker generator}
\label{fig:phases}
\end{figure}
\section{Implementation}
\label{sec:implementation}
The following sections describe the implementation of the type checker
generator, one section per phase.

\subsection{Template Generation}
\label{sec:constraint-templates}
In the first phase type system specifications are translated into
templates. A template is a intermediate representation of a typing
rule that is more suitable for the constraint generation process and
defined as following.

\begin{definition}{Template}
  \todo[inline]{Complete this grammar and synchronize it with the
    stratego source code}
  \begin{grammar}
    <Template> ::= `Template__' <Vars> <Premisses> <Conjecture>

    <Conjecture> ::= `Conjecture__' <Int> <Name> <Pattern> <Outputs> <Constraints>

    <Name> ::= `Some' <String> | `None'
  \end{grammar}
\end{definition}

Before describing the structure of templates in depth, the conceptual
differences between templates and typing rules are highlighted.
Templates take advantage of the input/output tags of typing judgments
by splitting everything up into an input and output part. This will
become handy in the constraint generation phase. An other difference
is that they already carry some constraints and that the dependencies
between the premisses are resolved.

The structure of a template is close to the structure of a typing
rule, there are premisses and a conjecture. In addition to those there
is a list of variables for ever premise. Those variables correspond to
the output positions of the premisses in the typing rule, for each
output position there is one variable. Further there is a set of
constraints. This set contains equalities that bind the variables of
the premisses to the expected outputs.

Attached to premisses Context operations are transformed slightly. Context binds are
transformed in a tuple that consists of the context identifier

Premisses in templates have multiple shapes: Judgments, context
lookups, equalities and inequalities.

\begin{description}
\item[Judgments] are the user defined judgments form the
  specification. They consist of the judgment number
  \refcallout{judgment:number}, the positions of the judgment that are
  marked as inputs \refcallout{judgment:inputs} and context
  modifications \refcallout{judgment:context}. A context modification
  can either be a addition to a context \refcallout{judgment:bind}
  which is a triple of a context identifier a list of inputs and a
  list of outputs, a context identity \refcallout{judgment:identity}
  which corresponds to the context meta-variables in the specification
  and a reset operation \refcallout{judgment:reset} which resets the given context and corresponds
  to the empty context. Those context modifications are meant to be
  executed from right to left. A detail explanation of the semantics
  will follow in Section~\ref{sec:constr-gener}.

\begin{verbatim}
Judgment__(
          1 !callout`judgment:number'
        , [Var__("X219")] !callout`judgment:inputs'
        , [ (1, [Var__("X217")], [Var__("X218")]) !callout`judgment:bind'
          , Reset__(1) !callout`judgment:reset'
          , Ctx__(2) !callout`judgment:identity'
          ] !callout`judgment:context'
        )
\end{verbatim}

  In the above example we have judgment one that has only one input
  position and that leaves context as it is, resets context one and
  adds then the input/output pair \verb|Var__("X217")| and
  \verb|Verb__("X218")| to context one.

\item[Context lookups] consist of the context number
  \refcallout{lookup:ctx} and of the input positions of the context
  lookup \refcallout{lookup:inputs}.

\begin{verbatim}
Lookup__(1 !callout`lookup:ctx', [Var__("X213")] !callout`lookup:inputs')
\end{verbatim}

  In the above example we look up \verb|Var__("X213")| from context
  one.

\item[(In)equalities] are predefined judgments and therefore treated
  separately. As they have no outputs the error messages are stored
  directly in the premise. Apart from that they behave like normal
  judgments.
\begin{verbatim}
Neq__(Var__("X241"), Var__("X240"), None())
\end{verbatim}

  In the above example we compare \verb|Var__("X241")| and
  \verb|Var__("X240")| for inequality and provide no error message.
\end{description}

\begin{figure}
  \centering
  \begin{minipage}{.45\linewidth}
\begin{verbatim}
%x : ~T in $C1
=============== T-Var
$C1 | $C2 |- %x : ~T
\end{verbatim}
  \end{minipage}
  \begin{minipage}{.45\linewidth}
\begin{verbatim}
Template__(
    [[Var__("X212")]]
  , [(Lookup__(
        1,
       [Var__("X213")]),
       [])]
  , Conjecture__(
      1
    , Some("T-Var")
    , ([Var(Var__("X213"))],
       [Ctx__(1), Ctx__(2)])
    , [Var__("X214")]
    , [ CEq__(
          Var__("X212")
        , Var__("X214")
        , None
        )
      ]
    )
  )
\end{verbatim}
  \end{minipage}
  \caption{Typing rule and template of T-Var}
  \label{fig:template-example}
\end{figure}
\subsection{Constraint Template Optimization}
\label{sec:constr-templ-optim}
\subsection{Constraint Generation}
\label{sec:constr-gener}
\subsection{Constraint Solving}
\label{sec:constraint-solving}
\section{Performance}
\label{sec:performance}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../report"
%%% End: 
