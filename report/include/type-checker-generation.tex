\chapter{Type Checker Generation}
\todo[inline]{Terminology: Type Checker vs. Type Inference}
\section{Goals}
This section briefly describes and motivates the design goals of the
type check generator.

The first goal is to produce fast type checkers, even if the type
system specification is not geared towards performance. Mainly this
means to try to deal with non-syntax directed typing rules without
backtracking. The motivation for this is, that non-syntax directed
typing rules are often more readable and changes have mainly local
effects.

The second goal is to design a modular type checker generator. A type
checker generator that can be easily adapted and that facilitates the
exchange of components. This modularity is desirable because it
increases the reusability and makes it possible to combine projects.

The third goal is to generate type checkers emit readable error
messages if a program is not well-typed. This is essential to make the
type checker usable in any way.
\section{Architecture}
\todo[inline]{Describe more explicitly that we use constraint solving}
The type checker generator has two phases: Template generation and
template optimization. In the template generation phase the type
system specification is transformed with minor modifications into
templates. A template is different representation for a typing rule,
which is better suited for type checking. Templates will be introduced
in detail in Section~\ref{sec:constraint-templates}. In the template
optimization phase, those templates are optimized. Those optimizations
aim to reduce the amount of non-determinism in the type system and
therefore reduce the amount of backtracking in the type checker. The
end product after those two phases, is a file that contains the
optimized templates.

The templates are the input for the next two phases, which are located
in the type checker. Instead of generating the type checker directly
from the specification, a generic type checker is that takes the
templates as input. The generic type checker has two phases:
Constraint generation and constraint solving. The constraint
generation phase has the templates and the program expression that shall be type
checked as inputs. To generate the constraints the program expression
is traversed according to the templates and the emitted constraints
are collected. Those constraints are then solved in the constraint
solving phase.

The four phases correspond to modules. Each phase has a well-defined
interface, therefore the implementation can be exchanged freely. This
makes it possible to use different constraint solvers, constraint
generators or template optimizers.

\begin{figure}
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,align=center,node distance=2cm,
  thick,main node/.style={rectangle,fill=blue!20,draw,font=\small\bfseries}]

  \node[main node] (1) {Template Generation};
  \node[main node] (2) [right=3cm of 1] {Template Optimization};
  \node[main node] (3) [below of=2] {Constraint Generation};
  \node[main node] (4) [below of=1] {Constraint Solving};
  \coordinate [below right of=3] (5);

  \path[every node/.style={font=\small}]
    (1) edge node [right, below] {Templates} (2)
    (2) edge node [right] {Extended Templates} (3)
    (5) edge node [right] {Program} (3)
    (3) edge node [right, below] {Constraints} (4);
\end{tikzpicture}
\caption{Phases of the type checker generator}
\label{fig:phases}
\end{figure}
\section{Implementation}
\label{sec:implementation}
The following sections describe the implementation of the type checker
generator, one section per phase.

\subsection{Template Generation}
\label{sec:constraint-templates}
In the first phase type system specifications are translated into
templates.

\subsubsection{Templates}
A template is a intermediate representation of a typing rule that is
more suitable for the constraint generation process and defined as
following.

\begin{definition}{Template}
  \todo[inline]{Complete this grammar and synchronize it with the
    stratego source code}
  \begin{grammar}
    <Template> ::= `Template__' <Vars> <Premisses> <Conjecture> <Constraints>

    <Conjecture> ::= `Conjecture__' <Int> <Name> <Pattern> <Outputs>

    <Name> ::= `Some' <String> | `None'
  \end{grammar}
\end{definition}

Before describing the structure of templates in depth, the conceptual
differences between templates and typing rules are highlighted.
Templates take advantage of the input/output tags of typing judgments
by splitting everything up into an input and output part. This will
become handy in the constraint generation phase. An other difference
is that they already carry some constraints and that the dependencies
between the premisses are resolved.

The structure of a template is close to the structure of a typing
rule, there are premisses and a conjecture. In addition to those there
is a list of variables for ever premise. Those variables correspond to
the output positions of the premisses in the typing rule, for each
output position there is one variable. Further there is a set of
constraints. This set contains equalities that bind the variables of
the premisses to the expected outputs.

\paragraph*{Premisses}
Premisses in templates have multiple shapes: Judgments, context
lookups, equalities and inequalities.

\begin{description}
\item[Judgments] are the user defined judgments form the
  specification. They consist of the judgment number
  \refcallout{judgment:number}, the positions of the judgment that are
  marked as inputs \refcallout{judgment:inputs} and context
  modifications \refcallout{judgment:context}. A context modification
  can either be a addition to a context \refcallout{judgment:bind}
  which is a triple of a context identifier a list of inputs and a
  list of outputs, a context identity \refcallout{judgment:identity}
  which corresponds to the context meta-variables in the specification
  and a reset operation \refcallout{judgment:reset} which resets the given context and corresponds
  to the empty context. Those context modifications are meant to be
  executed from right to left. A detail explanation of the semantics
  will follow in Section~\ref{sec:constr-gener}.

\begin{example}{~}
\begin{verbatim}
Judgment__(
          1 !callout`judgment:number'
        , [Var__("X219")] !callout`judgment:inputs'
        , [ (1, [Var__("X217")], [Var__("X218")]) !callout`judgment:bind'
          , Reset__(1) !callout`judgment:reset'
          , Ctx__(2) !callout`judgment:identity'
          ] !callout`judgment:context'
        )
\end{verbatim}
\label{ex:judgment}
\end{example}

  In example~\ref{ex:judgment} we have judgment one that has only one input
  position and that leaves context as it is, resets context one and
  adds then the input/output pair \verb|Var__("X217")| and
  \verb|Verb__("X218")| to context one.

\item[Context lookups] consist of the context number
  \refcallout{lookup:ctx} and of the input positions of the context
  lookup \refcallout{lookup:inputs}.

\begin{example}
\begin{verbatim}
Lookup__(1 !callout`lookup:ctx', [Var__("X213")] !callout`lookup:inputs')
\end{verbatim}
\label{ex:lookup}
\end{example}

  In example~\ref{ex:lookup} we look up \verb|Var__("X213")| from
  context one.

\item[(In)equalities] are predefined judgments and therefore treated
  separately. As they have no outputs the error messages are stored
  directly in the premise. Apart from that they behave like normal
  judgments.

\begin{example}
\begin{verbatim}
Neq__(Var__("X241"), Var__("X240"), None())
\end{verbatim}
\label{ex:neq}
\end{example}

  In example~\ref{ex:neq} we compare \verb|Var__("X241")| and
  \verb|Var__("X240")| for inequality and provide no error message.
\end{description}

There are cases, in which it is relevant in which order the premisses
are evaluated. Therefore every premise has a list of premisses on
which it depends. Essentially this list contains the position of the
dependency and its output positions. The following example will
illustrate why such dependencies occur and how this is solved in the
template language.

\begin{example}{~}
\begin{verbatim}
judgments
TermBinding{I} "|" TypeBinding{I} "|-" Exp{I} ":" Type{O}.
Type{O} "= [" ID{I} "->" Type{I} "]" Type{I}.

rules
~U = [ %x -> ~S ] ~T
$C1 | $C2 |- ~e : all %x . ~T 
============================== T-Tapp
$C1 | $C2 |- ~e [ ~S ] : ~U
\end{verbatim}
\label{ex:premise-dependencies}
\end{example}

Example~\ref{ex:premise-dependencies} shows the type application rule
of SystemF \todo{Citation} together with the judgment
declarations. One can easily see, that the first premise has an input
positions, namely \verb|%x|, that is part of the output position of
the second premise. Therefore the second premise needs to be evaluated
first to provide the output for the first premise. In the template
generation process the premisses are sorted topologically and are
annotated with the indices and outputs of their dependencies. The
output positions are to know which terms are actually provided by the
dependency. For the first premise the dependency would look like
\verb|(1, [TAll(Var__("X150"), Var__("X149"))])|, where \verb|1|
refers to the second premise in example~\ref{ex:premise-dependencies}
because of the topological sort.

\paragraph{Conclusion}
Conclusions contain the judgment identifier
\refcallout{conclusion:number}, the name of the typing rule (which may
be empty) \refcallout{conclusion:name}, the input positions of the
judgment \refcallout{conclusion:inputs}, the context modifications
\refcallout{conclusion:ctx} as well as the output positions of the
conclusion \refcallout{conclusion:outputs}.

\begin{example}{~}
\begin{verbatim}
Conclusion__(
      3 !callout`conclusion:number'
    , None() !callout`conclusion:name'
    , ( [Var__("X177")] !callout`conclusion:inputs'
      , [(2, [Var__("X178")], []), Ctx__(2)] !callout`conclusion:ctx'
      )
    , [] !callout`conclusion:outputs'
    )
\end{verbatim}
\end{example}

In this example judgment number three is in the conclusion and the
typing rule has no name. There is only one input position and there
has to be at least one element in the second context. The judgment
three has no outputs.

\subsubsection{Generation}
Template generation is mainly done by the Stratego rule
\verb|to-template| that takes a typing rule and returns a
template. The first step in the conversion is the elimination of
implicit equalities in the premisses and the conclusion.

Implicit equalities are transformed in to explicit equalities, by
collecting all variables that occur more than once in an input
position, rename them and create premisses that state the equality of
the newly created variables. Example~\ref{ex:implicit-equalities}
shows this for a typing rule of the judgment

\begin{verbatim}
Type{O} "= [" ID{I} "->" Type{I} "]" Type{I}
\end{verbatim}

which is used for type substitution in the SystemF specification. On
the left of example~\ref{ex:implicit-equalities} you see the typing
rule with implicit equalities and on the right the transformed version
without implicit equalities.

\begin{example}{~}
\newline
  \begin{minipage}[b]{.45\linewidth}
    \begin{verbatim}
=====================
~S = [ %x -> ~S ] %x
\end{verbatim}
  \end{minipage}
  \begin{minipage}[b]{.45\linewidth}
    \begin{verbatim}
%y = %z
=====================
~S = [ %y -> ~S ] %z
\end{verbatim}
  \end{minipage}
\label{ex:implicit-equalities}
\end{example}

If a variable occurs more than twice the equalities for the new
variables are defined transitively.

\todo[inline]{Implicit equalities between inputs and outputs and
  between the contexts}
\todo[inline]{Describe the fiddeling with @implicit}

After this step, there are no implicit equalities left. Now the
premisses of the typing rule are analyzed for inter-dependencies. A
premise depends on an other, if it uses variables in input positions
that occur in an output position of an other premise. As we need to
supply the input positions with concrete terms to check if a premise
holds, a dependency can only be evaluated if all its dependencies are
evaluated. In the generation process we do two things, sort the
premisses according to their dependencies and annotate them with the
output positions of the dependencies, as described in the previous
paragraph. The implementation of this ordering is straightforward,
first the dependencies are collected for each premise. This creates an
transposed dependency graph, that is topologically sorted with the
algorithm by Kahn \cite{Kahn:1962:TSL:368996.369025}. The resulting
topological order is reversed as we look at the transposed dependency
graph. Cycles are detected and reported.

Now variables for the outputs of the premisses are generated, bound to
the expected outputs. Premisses and conclusions are split up into
inputs, outputs, and context parts and placed at the appropriate
places in the template.

\begin{figure}
  \centering
  \begin{minipage}{.45\linewidth}
\begin{verbatim}
%x : ~T in $C1
=============== T-Var
$C1 | $C2 |- %x : ~T
\end{verbatim}
  \end{minipage}
  \begin{minipage}{.45\linewidth}
\begin{verbatim}
Template__(
    [[Var__("X212")]]
  , [(Lookup__(
        1,
       [Var__("X213")]),
       [])]
  , Conjecture__(
      1
    , Some("T-Var")
    , ([Var(Var__("X213"))],
       [Ctx__(1), Ctx__(2)])
    , [Var__("X214")]
    , [ CEq__(
          Var__("X212")
        , Var__("X214")
        , None
        )
      ]
    )
  )
\end{verbatim}
  \end{minipage}
  \caption{Typing rule and template of T-Var}
  \label{fig:template-example}
\end{figure}
\subsection{Constraint Template Optimization}
\label{sec:constr-templ-optim}
\subsection{Constraint Generation}
\label{sec:constr-gener}
Constraint generation is the first phase of the type checker. The
inputs of this phase are constraint templates and the expressions that
should be type checked. Currently those expressions are defined in the
conjecture section of the type system specification. \todo{Change
  this, at least for benchmarking it is nescessary to pass programs
  via stdin}

The constraint generation phase structured as follows. First, contexts
are intialized, then constraint are generated according to the
programs structure and the templates and at the end a constraint is
added that binds the infered type with the acutal type.

Lets first look on the implementation of the contexts. Contexts are
stored in a hashtable, with the context id as key. This implies that
at every point in the derivation, there is only one instance of each
context. This assumption is true for all type systems we have
investigated. Further a context is defined as a hashtable which keeps
track of the insertion order of the elements. The insertion order is
important for type systems that rely on the ordering of contexts
\todo{Example}. Keys of the hashtable are the input positions of the
context and values are the output positions. As we use a hashtable
rather than a hashmap it is also possible to store multiple values at
a single key. We decided to use hashtables instead of normal key-value
lists for the context representation to reduce the lookup time in
large programs with many identifiers. However we do not have
experimental evidence on this, because we do not have a key-value list
implementation of contexts.

However implementing contexts using extended hashtables forced us to
separate context operations from normal inputs. This creates on the
one hand many exceptional cases (e.g. the matching complex matching
algorithms described in section~\ref{sec:constr-templ-optim}) it lead
on the other hand to a modular context implementation with the
potential to exchange the implementation easily.

We now define the constraint language. It is a simple language
consisting of three constraints.

\begin{definition}{Constraint Language}
  \begin{grammar}
    <Constraint> ::= `CFail' <Error>
    \alt `CEq' <Term> <Term> <Error>
    \alt `CNeq' <Term> <Term> <Error>
  \end{grammar}
\end{definition}

\verb|CFail| is the constraint that cannot be unified and \verb|CEq|
and \verb|CNeq| are ordinary equality and inequality
constraints. \verb|Term| and \verb|Error| are arbitrary terms.

The program expression that is passed to the constraint generator is
wrapped in the desired typing judgment with initial contexts and
potentially with expected results. Every conjecture is provided with
an empty context-store. The context in this store are intialized with
the context information in the judgment.

After the context is intialized all terms at input positions of the
judgment are passed into the \verb|generate| rule, together with the
judgment number. Now the templates are searched for a template that has the
correct judgment identifier in its conclusion, matching input
positions and a context description that reflects the current state in
the store. The first template that matches is taken as we have ensured
in section~\ref{sec:constr-templ-optim} that there is only one such
rule. If no template matches those criteria the constraint that always
fails is return with an appropriate error message. In general
\verb|generate| returns a pair of the output and a constraint set,
where the output is optional. \todo{It is not so clear where the
  output comes from}

The rule \verb|generate'| evaluates the selected template according to
the given input. In case of \verb|Template__| the evaluation works as
follows. At first the contexts are updated according to the context
modifications in the conclusion. This means the description of the
context modifications is read from left to right. On a context bind,
the first element of the corresponding context is popped from the
context. To be able to access this element, it is appended to the
input. Context variables correspond to identity and \verb|Reset__|
clears the whole context, without making any element available.

Next all variables in the selected template are replaced by fresh
ones. This is also indicated visually, as all variables in the
template generation phase start with \verb|X| and all variables
generated in the constraint generation phase with \verb|Y|. This
renaming ensures that now collisions occur if a template is used more
than once.

Now that all variables are fresh, the context is modified in
accordance to the premisses the premisses of the template are
evaluated. A key element in the evaluation is the instantiation of the
variables in the premise patterns according to the conclusion pattern
and input term, because we need input terms to call \verb|generate| on
the premisses.

Variables in inputs of a judgment are initialized using a term and a
pattern which describes the structure of the term. Now every variable
in the inputs is searched in the pattern, by walking through the
abstract syntax tree of the pattern and recording the path to the
variable. As there are no implicit equalities in the templates we can
take the first and only occurrence of the variable. After a path was
found for every variable that occurs in the pattern, those paths are
used to retrieve terms from the corresponding term, by walking along
the path and fetching the node at its end. The variables in the inputs
are now replaced by the fetched nodes.

As the premisses were topologically sorted as described in
Section~\ref{sec:constraint-templates} they are evaluated in the
correct order. However, to ensure that the terms of all dependencies
are available during evaluation, we accumulate the outputs of the
evaluated premisses and add those to the pattern and term used for the
instantiation.

\begin{description}
\item[Lookup:] The inputs are instantiated, then the resulting term is
  looked up in the context. If the lookup succeeds the result is
  returned, together with an empty constraint set. Otherwise, no
  output is returned together with the \verb|CFail| constraint.
\item[(In)equality:] Equalities and inequalities are initialized and
  return as constraints.
\item[Judgment:] Judgments are instantiated, the store is updated
  according to the context bindings and \verb|generate| is called on
  the resulting terms. In addition constraints for the context
  bindings are generated. \todo{Examples}
\end{description}

\subsection{Constraint Solving}
\label{sec:constraint-solving}
\todo[inline]{What else should be contained in this section?}
Constraint solving is the last phase of the type checker. As the
constraint language is with only three constructs simple, the
algorithm to solve a constraint set is simple as well.

Unification is used to solve the constraint set. Precisely we use a
variant of Robinson unificiation \todo{Citation}. During the
unification an most general unifier (mgu) is computed to instantiate
the variables in the outputs and (in case of not well-typed programs)
in the error messages.
\section{Performance}
\label{sec:performance}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../report"
%%% End: 
