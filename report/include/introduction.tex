\chapter{Introduction}
\section{Motiviation}
Type systems ensure that programs are well-behaved. In other words,
they try to ensure that programs have meaning in the sense of the
semantics of the programming language. The type systems we focus on
are static type systems and can be thought of as a static
approximation of the program semantics. Besides ensuring that programs
are well-behaved, type systems are means to establish abstractions and
to enforce adherence to these abstractions. They can also serve as
documentation that cannot become obsolete and give hints for
optimization to the compiler. All in all type systems can help to
develop software more efficiently
(cf.~\cite{Petersen:2014:ECS:2597008.2597152}
and~\cite{Mayer:2012:ESI:2384616.2384666}).

Type systems are useful tools, particularly if they fit to the
programming language and the application scenario. Ensuring this,
e.g.\ in the context of a \gls{dsl}, it makes sense to adapt and
modify existing type systems or create new specialized type
systems. Those specializations can lead to better error messages, more
expressive type systems and the detection of more errors
\cite{Thiemann02programmabletype}. Currently there are no established
tools that could help with that by generating type checkers from a
type system specification. Such generators could make the development
of type checkers faster and less error prone. Those generators would
fit well into the language development workbench besides the long
established lexer and parser generators.

Type checker generators that use a high-level specification language
can also provide type theorists with a tool, that allows them play
with new type systems without long development delays. High-level
specifications that are close to the formalism used by type theorists
has also the advantage of narrowing the gap between the type system on
paper and the implementation. Results shown for the paper version can
easily be adapted for the implementation (depending on the correctness
of the type checker generator). Such adaptions are not possible with
traditional implementations. High-level specification languages are
also suited to specify type systems from other areas, like
language-based security.

To have more confidence into properties of a type system the
declarative specification can be translated into first-order formula
representation, which can be used to conduct proofs of these
properties. As the proofs of propositions about type systems change
when the type system changes, it is desirable to make most of these
changes automatically. Automated theorem provers can try to conduct
those proves automatically. If the proof search fails one can give
hints for proof search. This establishes a direct connection between
the specified type system, the proofs and the generated type checker.

The goal of this thesis is to close that gap in the tool chain. A
declarative specification language is developed, in which type systems
can be represented very close to the standard formalisms. Two things
are generated from those specifications. First, a representation of
the type system as first-order formulas, intended to support proving
properties of the type system. Second, an efficient type checker that
can be integrated in existing tool chains.
\section{Contributions}
The main contributions of this thesis are:
\begin{enumerate}
\item A declarative specification language for static type systems,
  with support for natural deductive style typing rules and error
  messages. A type system specification for a programming language
  requires that the syntax of the programming language is present as
  and \gls{sdf} file.
\item The transformation of a type system specification into
  equivalent an first-order formula representation in the \gls{tptp}
  format. The first-order formula representation is suitable for
  typing checking and theorem proving using theorem provers that
  support \gls{tptp}.
\item A generator that creates type checkers from type system
  specifications. This generator uses an intermediate representation
  for typing rules suitable for constraint generation and optimizes
  the transformed specification using automated theorem proving to
  check the applicability of the optimizations.
\end{enumerate}

\section{Structure}
\todo[inline]{Describe how the thesis is structured.}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../report"
%%% End: