% Things to be done before giving away for print
% - spell check
% - let others proof-read

\documentclass[a4paper,twoside]{report}

%% packages
%%%%%%%%%%%
\usepackage[utf8x]{inputenc}
\usepackage[USenglish]{babel}
\usepackage{amsbsy,amscd,amsfonts,amssymb,amstext,amsmath,amsthm,latexsym}
% Package mathpartir is currently not available in nixpkgs
%\usepackage{mathpartir}
\usepackage{stmaryrd}
\usepackage{dot2texi}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows}
\usepackage{url}
\usepackage[xindy]{glossaries}
\usepackage[nottoc]{tocbibind}
\usepackage{pdfpages}

\usepackage{todonotes}

%% options
%%%%%%%%%%
% Currently no such things seem to be needed.
% \newtheorem{definition}{Definition}
% \newtheorem{example}{Example}
% \newtheorem{lemma}{Lemma}
% \newtheorem{theorem}{Theorem}
% \newtheorem{claim}{Claim}
% \numberwithin{definition}{chapter}
\bibliographystyle{alphaurl}
\makeglossaries

\input{include/macros}
\input{include/glossary}

\begin{document}

% Title page
%%%%%%%%%%%%
\includepdf{titlepage.pdf}

\newpage
\thispagestyle{empty}
\mbox{}

% Erklärung
%%%%%%%%%%%
\input{include/erklaerung}

% Abstract
%%%%%%%%%%
\begin{abstract}
\input{include/abstract}
\end{abstract}

% Table of contents
%%%%%%%%%%%%%%%%%%%
\tableofcontents

\todo[inline]{Where do I put the "I would like to thank …"}
\todo[inline]{Search for a better word for 'goal'}
\todo[inline]{How do we refer to all the different types of
  languages? This should be done uniformly.}
\todo[inline]{Use glossary for abbreviations.}

% Content
%%%%%%%%%
\chapter{Introduction}
\section{Motiviation}
\todo[inline]{Somehow mention that we are always talking about static
  type systems}
\todo[inline]{Mention studies on type systems, e.g. by Hanenberg}

Type systems try to solve the problem of ensuring that programs have
meaning. They assign types to expressions and have rules that state
which expressions of which types can be combined. A type checker
ensures that the expressions of a program meet those rules, if those
rules are met, the program is called well-typed. Essentially a type
system ensures that a program has meaning, by approximating its
semantics. They also can be used to establish abstractions and to
enforce the adherence to these abstractions.

Although type systems are a useful tool increase software quality,
there is a lack of tools that help to create and modify type
checkers. Almost all type checkers are implemented by hand and are far
away from their formal models. In addition it is non-trivial to write
or even extend a type checker. Therefore current tools are not suited
for quick prototyping of type system features for new or existing
languages. This is also true for the development of domain specific
languages (DSL). In that sense type systems are underprivileged in
comparison to parsers. Parser generators are widely spread and
accepted tools.

The goal of this thesis is to close that gap in the tool chain. A
declarative specification language is developed, in which type systems
can be represented very close to the standard formalisms. Two things
are generated from those specifications. First, a representation of
the type system as first-order formulas, intended to support proving
properties of the type system. Second, an efficient type checker that
can be integrated in existing tool chains.
\section{Contributions}
The main contributions of this thesis are:
\begin{enumerate}
\item A declarative specification language for static type systems, in
  which typing rules can be written in the style of natural deduction
  and which builds SDF definitions of programming languages.
\item The transformation of type system specifications into equivalent
  first-order formulas in the TPTP format, suitable to be passed to
  automated theorem provers.
\item A generator that creates type checkers from type system
  specifications and which is designed for performance.
\end{enumerate}

\section{Structure}
\todo[inline]{Describe how the thesis is structured.}

\chapter{Preliminaries}
\section{Tools}
In this section the tools used in this thesis are introduced. Their
capabilities and usage is presented and it is argued for what purpose
they are used in the thesis and why they are suite for those.
\subsection{SDF}
\todo[inline]{Citations needed.}
The syntax definition formalism (SDF) is a formalism to define syntax
like the Backus-Naur-From (BNF). SDF allows to define lexical and
context-free grammars and is, in contrast to BNF, modular. This
modularity allows to compose SDF syntax definitions. SDF is also
supported by parser generators. In contrast to traditional parser
generators like YACC, SDF specifications are purely declarative, which
increases understandability of the specifications.

The modularity of SDF is a consequence of being a generalized LR
parsable. Generalized parsing means that parsing might be
indeterminate, i.e. ambiguities in the specifications are
allowed. This might not seem to be an advantage, but generalized
parsing has some nice implications. First the class of supported
grammars is bigger and therefore enforces less restrictions and allows
a natural definition of languages. Second, it enables the modularity
of SDF. The composition of normal LR grammars is not guaranteed to be
an LR grammar again, but this is guaranteed for generalized LR
grammars.

An other advantage is that SDF is also scannerless parsable, that
means that tokenization and parsing can be done in a single step.

\todo[inline]{Create and explain an small example}
\todo[inline]{Talk about layout constraints}

SDF is used in this thesis to define the syntax of the specification
language for type systems. Features like layout constraints make SDF a
good tool for defining complex syntax for natural deduction rules. The
modularity and composability make it possible to define that syntax of
the specification language independent of the language under
consideration.
\subsection{Stratego/XT}
Stratego is a framework for the development of transformation
systems. It consists of the transformation language Stratego and a set
of tools XT for tasks like parsing and pretty printing. The paradigm
of Stratego is to use user-definable strategies for
rewriting. In Stratego the following abstraction levels can be
distiguished.

\begin{description}
\item[Transformation rules] are basic rewrite rules on the structure
  of the abstract syntax tree (AST).
\item[Transformation strategies] are the glue between the
  transformation rules. They combine rules and define the order of
  application and the traversal order of the AST. These strategies can
  be defined generically. Context information are passed using
  \textit{scoped dynamic rewrite rules} during the traversal, as
  normal rewrite rules are context-free.
\item[Transformation tools] allow to compile transformation strategies
  into a stand-alone program. The interface between such programs is
  the ATerm format for ASTs.
\item[Transformation systems] describe a set of programs created by
  the transformation tools, that form a source-to-source
  transformation usually including a parser and pretty printer.
\end{description}

\todo[inline]{Create and explain an small example}

Stratego interacts well with SDF and has facilities to integrate
nicely into tool-chains. In addition it allows to write abstract and
generic transformation. That makes it a good choice for the
transformation system.
\subsection{Spoofax}
\todo[inline]{Citations needed.}
Spoofax started with the goal to provide an IDE for SDF and
Stratego. It was then developed to a language workbench for Eclipse
that allows language development with editor support for both, the
languages used for development and the developed language. Smooth
switching between both editor services. The editor for the developed
language can be deployed standalone. Those editor services provide
syntactic and semantic analysis based on live parses, with error
recovery and origin tracking. Those facilities are implemented
language pragmatic, which allows developers to focus on language
specific parts.

Spoofax is used in this thesis to provide editor support for the
specification language and as glue between SDF and Stratego in the
development of the specification language, the formula generator and
the type checker generator.
\subsection{Sugar-*}
\subsection{Alternatives}
\section{Type Systems}
\textit{Type theory} started as an attempt by Gottlob Frege to solve Russel's
paradox, that shows that \naive set theory is inconsistent. Frege
argued that a predicate requires an object as argument and cannot have
itself as an argument, as it is the subject.\todo{Make this more
  precise} So the initial motivation for type theory was to avoid
paradoxes and contradictions in logics and rewrite systems. The term
\textit{type system} refers to type theories whose logics rewrite
systems are programming languages. Type systems address therefore
similar problems as general type theory. The problem they address is
to ensure that programs have meaning, whereas in type theory the
problem is the ensure the consistency of a logic.

What does it mean to ``ensure that programs have meaning''. First, it
means that one wants to filter the useful programs. It is not useful
to have a syntactically valid program that has no semantics. This is
done by assigning types to the expressions of the program. A
\textit{type checker} can then check, whether those types match with
the expressions. If the type checker succeeds the program is
\textit{well-typed} and has meaning. Second, a type system allows to
establish abstractions through user definable data types. When type
checking a program, it is also ensured that those abstractions are not
violated.\footnote{This is only true for so called ``strong'' type
  systems.} In this thesis \textit{static} type systems are
considered. In a static type system types are checked prior to
execution. This early checks can provide guarantees about the programs
behavior 
\section{First-Order Logic}


\chapter{Specification Language}
The goal of this thesis is to create a generator for type checkers,
like there are generators for lexers and parers. Such a generator can
only be a useful tool, if the specifications from which the type
checkers are generated are easy to read and write for people who are
familiar with type systems and if the specification language is
expressible enough to handle real-world languages. As there is no
common format for type system specifications, a new specification
language was designed with the following goals in mind:

\begin{enumerate}
\item Close to the formal or mathematical notations that are commonly
  used to close the gap between the formal model and the
  implementation side.
\item Declarative, makes it easy to try things out and increases
  maintainability and readability of specifications.
\item Modularity, it should be possible to combine type systems to
  increase reuse.
\item Existing programming language definitions should integrate nicely.
\end{enumerate}
\section{Design \& Architecture}
A specification is divided into eight sections, of which two are
optional. The three sections are for organizational purposes. The
first section declare the name of the specification. This name is a
unique identifier and used for imports. The second section declares
which other specifications are imported. The third section declares
the language for which a type system should be specified. This
language needs to be present in SDF and there must be a module with
exactly that name. \todo[inline]{Does it make sense to allow imported
  files to declare a language?}

In the fourth section meta-variables are declared. The declaration of
a meta-variable consists of an identifier, of a prefix and of a set of
non-terminals of the base language. The identifier can be used to
distinguish different kinds of meta-variables.\todo{Currently this is
  not used} A meta-variable can consist of letters and numbers, to
ensure that we can parse meta-variables of different kinds
unambiguously every meta-variable must be prepended with the declared
prefix. As we want to introduce meta-variables at different positions
in the base language we need a way to extend the syntax of the base
language. The set of non-terminals in a meta-variable definition lists
the non-terminals that shall be extended.

\todo[inline]{Make up my mind about the name of those environments}
In the fifth section all environments that will be used in the
judgments are defined. Informally these environments are declared as
cross-products of non-terminals, i.e. an environment is a set
consisting of pairs of terminals that can be produced by the
non-terminals in the declaration. Every environment has a name, which
can be used in further declarations. Lookups may differ for
environments and use cases, therefore one has to annotate the
non-terminals with input and output tags. Terminals at positions that
are tagged with input are used to look up terminals tagged with output
that are saved in the environment. An environment for which all
non-terminals are tagged with input, is equivalent to a normal look up
in a set and will return whether the tuple could be found. An
environment with only outputs acts as a sink, one can put things into
it, but never retrieve anything back.

The sixth section declares type judgments. Type judgments can be
declared in a flexible way, non-terminals can be mixed arbitrarily
with separators. This allows the programmer\todo{Is this the right
  word?} to declare the type judgments as close to formalizations as
possible. As for environments the non-terminals in the type judgments
have to be annotated with input/output-tags to determine what should
be computed.

In the last two sections the typing rules and conjectures are
declared. Both typing rules and conjectures have the same
syntax. Typing rules specify the type system and conjectures are used
to provide test cases and are optional. A typing rule consists of a possible empty list
of typing judgments, an optional name and a typing judgment as
conclusion.
\section{Implementation}

\chapter{Formula Generation}
\section{Goals}
\section{Why First-Order Logic?}
\subsection{Expressiveness}
\subsection{Tool-Support}
\section{Translations}
\section{Implementation}
\section{Performance}

\chapter{Type Checker Generation}
\todo[inline]{Write a section for each approach that was attempted}
\section{Performance}

\chapter{Applications}
\section{Integration in Tool Chains}
\section{Security Type Systems}

\chapter{Summary}
\section{Conclusion}
\section{Future Work}
\section{Related Work}
\subsection{Specification Languages}
\subsection{Type Checker Generation}

% Bibliography
%%%%%%%%%%%%%%
\bibliography{bibliography}

\end{document}
