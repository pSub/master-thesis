% Things to be done before giving away for print
% - spell check
% - let others proof-read

\documentclass[a4paper,twoside]{report}

%% packages
%%%%%%%%%%%
\usepackage[utf8x]{inputenc}
\usepackage[USenglish]{babel}
\usepackage{amsbsy,amscd,amsfonts,amssymb,amstext,amsmath,amsthm,latexsym}
% Package mathpartir is currently not available in nixpkgs
%\usepackage{mathpartir}
\usepackage{stmaryrd}
\usepackage{dot2texi}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows}
\usepackage{url}
\usepackage[xindy]{glossaries}
\usepackage[nottoc]{tocbibind}
\usepackage{pdfpages}

\usepackage{todonotes}

%% options
%%%%%%%%%%
% Currently no such things seem to be needed.
% \newtheorem{definition}{Definition}
% \newtheorem{example}{Example}
% \newtheorem{lemma}{Lemma}
% \newtheorem{theorem}{Theorem}
% \newtheorem{claim}{Claim}
% \numberwithin{definition}{chapter}
\bibliographystyle{alphaurl}
\makeglossaries

\input{include/macros}
\input{include/glossary}

\begin{document}

% Title page
%%%%%%%%%%%%
\includepdf{titlepage.pdf}

\newpage
\thispagestyle{empty}
\mbox{}

% Erklärung
%%%%%%%%%%%
\input{include/erklaerung}

% Abstract
%%%%%%%%%%
\begin{abstract}
\input{include/abstract}
\end{abstract}

% Table of contents
%%%%%%%%%%%%%%%%%%%
\tableofcontents

\todo[inline]{Where do I put the "I would like to thank …"}
\todo[inline]{Search for a better word for 'goal'}

% Content
%%%%%%%%%
\chapter{Introduction}
\section{Motiviation}
\todo[inline]{Somehow mention that we are always talking about static
  type systems}

Type systems try to solve the problem of ensuring that programs have
meaning. They assign types to expressions and have rules that state
which expressions of which types can be combined. A type checker
ensures that the expressions of a program meet those rules, if those
rules are met, the program is called well-typed. Essentially a type
system ensures that a program has meaning, by approximating its
semantics. They also can be used to establish abstractions and to
enforce the adherence to these abstractions.


\todo[inline]{Extract everything useful from this text and
build a readable motivation from it}

Type systems are means to put focus on meaningful programs. In other
words they help the programmer to catch errors by helping building
abstractions and by enforcing those abstractions thorough the
program. We are dealing with static type systems, i.e. abstractions
are enforced before the execution. Those type systems help to reduce
development time and to reveal errors earlier. \todo{Cite Stefan
  Hanenberg}

Static type systems are typically integrated into the compiler of the
programming language. \todo{Proof this} This makes it hard to extend a
given type system or to implement a type system for an (embedded)
domain specific language. In addition the implementation of a type
system is time expensive and error prone.

The goal of this thesis is to design a language for the specification
of static type systems in the style of natural deduction and to
generate based on such specifications an efficient implementation.

\section{Contributions}
The main contributions of this thesis are:
\begin{enumerate}
\item A declarative specification language for static type systems, in
  which typing rules can be written in the style of natural deduction
  and which builds SDF definitions of programming languages.
\item The transformation of type system specifications into equivalent
  first-order formulas in the TPTP format, suitable to be passed to
  automated theorem provers.
\item A generator that creates type checkers from type system
  specifications and which is designed for performance.
\end{enumerate}

\section{Structure}
\todo[inline]{Describe how the thesis is structured.}

\chapter{Preliminaries}
\section{Tools}
\subsection{Spoofax}
\subsection{SDF}
\subsection{Stratego}
\subsection{Sugar-*}
\subsection{Alternatives}
\section{Type Systems}
\textit{Type theory} started as an attempt by Gottlob Frege to solve Russel's
paradox, that shows that \naive set theory is inconsistent. Frege
argued that a predicate requires an object as argument and cannot have
itself as an argument, as it is the subject.\todo{Make this more
  precise} So the initial motivation for type theory was to avoid
paradoxes and contradictions in logics and rewrite systems. The term
\textit{type system} refers to type theories whose logics rewrite
systems are programming languages. Type systems address therefore
similar problems as general type theory. The problem they address is
to ensure that programs have meaning, whereas in type theory the
problem is the ensure the consistency of a logic.

What does it mean to ``ensure that programs have meaning''. First, it
means that one wants to filter the useful programs. It is not useful
to have a syntactically valid program that has no semantics. This is
done by assigning types to the expressions of the program. A
\textit{type checker} can then check, whether those types match with
the expressions. If the type checker succeeds the program is
\textit{well-typed} and has meaning. Second, a type system allows to
establish abstractions through user definable data types. When type
checking a program, it is also ensured that those abstractions are not
violated.\footnote{This is only true for so called ``strong'' type
  systems.} In this thesis \textit{static} type systems are
considered. In a static type system types are checked prior to
execution. This early checks can provide guarantees about the programs
behavior 

\section{First-Order Logic}


\chapter{Specification Language}
\section{Goals}
\section{Design \& Architecture}
\section{Implementation}

\chapter{Formula Generation}
\section{Goals}
\section{Why First-Order Logic?}
\subsection{Expressiveness}
\subsection{Tool-Support}
\section{Translations}
\section{Implementation}
\section{Performance}

\chapter{Type Checker Generation}
\todo[inline]{Write a section for each approach that was attempted}
\section{Performance}

\chapter{Applications}
\section{Integration in Tool Chains}
\section{Security Type Systems}

\chapter{Summary}
\section{Conclusion}
\section{Future Work}
\section{Related Work}
\subsection{Specification Languages}
\subsection{Type Checker Generation}

% Bibliography
%%%%%%%%%%%%%%
\bibliography{bibliography}

\end{document}
