module BaseLanguage[TypingJudgment MetaVariable]
imports Common

exports
  context-free syntax
    "module" MID                            -> ModuleDec      {cons("ModuleDec")}
    "imports" MID*							-> Imports        {cons("Imports")}
    "language" MID							-> Language       {cons("Language")}
    "meta-variables" MetaVariableDefinition*-> MetaVariables  {cons("MetaVariables")}
    "contexts" ContextDefinition*		    -> Contexts       {cons("Contexts")}
    "judgments" Judgment*                   -> Judgments      {cons("Judgments")}
    "rules" ErrorTypingRule*                -> Rules          {cons("Rules")}
    "conjectures" TypingRule*               -> Conjectures    {cons("Conjectures")}
    
    %%TODO: When introducing imports it might make sense to treat most
    %% consituents as optional.
    ModuleDec Imports? Language MetaVariables Contexts Judgments Rules Conjectures? -> Module {cons("Module")}


  lexical syntax
	"\"" ~[\"]* "\"" -> Separator
	"I" -> Mode
	"O" -> Mode

  context-free syntax
	Name "{" Mode "}" -> Hole {cons("Hole")}

%% Meta-variables
  context-free syntax
  	"{" ID+ "}"-> Scope {cons("Scope")}
	"\"" PrefixChars "\"" -> Prefix {cons("MetaVariablePrefix")}
  	Name Prefix Scope -> MetaVariableDefinition {cons("MetaVariableDefinition")}
  	
%% Contexts
  context-free syntax
	ID ":=" {Hole "x"}+ -> ContextDefinition {cons("ContextDefinition")}
	
%% Judgments
  lexical syntax
    "Eq" -> Feature
    "Neq" -> Feature
    "Not" -> Feature

  context-free syntax
    %%FIXME: How do I avoid this warning: Non-terminal used as a list separator (use round braces for grouping non-terminals)
	Separator? {Hole Separator}+ Separator? BuiltIn? "." -> Judgment {cons("Judgment")}
	"is" Feature-> BuiltIn {cons("BuiltIn")}

%% Errors
  lexical syntax
    "INFTYPE" -> MessagePart

  context-free syntax
    Separator -> MessagePart
    MetaVariable -> MessagePart
    "@error" MessagePart+ "." -> Error {cons("Error")}
    "@implicit" MessagePart + "." -> Error {cons("Implicit")}
    %% FIXME: Why is `(Error+)?' not directly possible?
    Error+ -> ErrorList
    TypingJudgment ErrorList? -> ErrorTypingJudgment {cons("ErrorTypingJudgment")}

%% Typing Rules
  lexical syntax
    "===" "="*     -> RuleSep
    
  lexical restrictions
    RuleSep -/- [\=]

  context-free syntax
    RuleSep Name?                                                     -> RuleSepName                {cons("RuleName"), layout("1.first.line == 2.last.line")}
    ErrorTypingRulePremiseList RuleSepName ErrorTypingRuleConsequence -> ErrorTypingRule            {cons("TypingRule"), layout("1.first.col == 2.first.col && 2.first.col == 3.first.col")}
    ErrorTypingJudgment                                               -> ErrorTypingRuleConsequence
                                                                      -> ErrorTypingRulePremiseList {cons("PremiseBase")}
    ErrorTypingJudgment ErrorTypingRulePremiseList                    -> ErrorTypingRulePremiseList {cons("PremiseCons"), layout("1.first.col == 2.first.col")}

    TypingRulePremiseList RuleSepName TypingRuleConsequence   -> TypingRule            {cons("TypingRule"), layout("1.first.col == 2.first.col && 2.first.col == 3.first.col")}
    TypingJudgment                                       -> TypingRuleConsequence
                                                         -> TypingRulePremiseList {cons("PremiseBase")}
    TypingJudgment TypingRulePremiseList                 -> TypingRulePremiseList {cons("PremiseCons"), layout("1.first.col == 2.first.col")}