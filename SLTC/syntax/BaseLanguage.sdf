module BaseLanguage[TypingJudgment]
imports Common

exports
  context-free syntax
    "module" MID                            -> ModuleDec      {cons("ModuleDec")}
    "imports" MID*							-> Imports        {cons("Imports")}
    "language" MID							-> Language       {cons("Language")}
    "meta-variables" MetaVariableDefinition*-> MetaVariables  {cons("MetaVariables")}
    "contexts" ContextDefinition*		    -> Contexts       {cons("Contexts")}
    "judgments" Judgment*                   -> Judgments      {cons("Judgments")}
    "rules" TypingRule*                     -> Rules          {cons("Rules")}
    "conjectures" TypingRule*               -> Conjectures    {cons("Conjectures")}
    
    %%TODO: When introducing imports it might make sense to treat most
    %% consituents as optional.
    ModuleDec Imports? Language MetaVariables Contexts Judgments Rules Conjectures? -> Module {cons("Module")}


  lexical syntax
	"\"" ~[\"]* "\"" -> Separator
	"I" -> Mode
	"O" -> Mode

  context-free syntax
	Name "{" Mode "}" -> Hole {cons("Hole")}

%% Meta-variables
  context-free syntax
  	"{" ID+ "}"-> Scope {cons("Scope")}
	"\"" PrefixChars "\"" -> Prefix {cons("MetaVariablePrefix")}
  	Name Prefix Scope -> MetaVariableDefinition {cons("MetaVariableDefinition")}
  	
%% Contexts
  context-free syntax
	ID ":=" {Hole "x"}+ -> ContextDefinition {cons("ContextDefinition")}
	
%% Judgments
  lexical syntax
    "Eq" -> Feature
    "Neq" -> Feature
    "Not" -> Feature

  context-free syntax
    %%FIXME: How do I avoid this warning: Non-terminal used as a list separator (use round braces for grouping non-terminals)
	Separator? {Hole Separator}+ Separator? BuiltIn? "." -> Judgment {cons("Judgment")}
	"is" Feature-> BuiltIn {cons("BuiltIn")}

%% Typing Rules
  lexical syntax
    "===" "="*     -> RuleSep
    
  lexical restrictions
    RuleSep -/- [\=]

  context-free syntax
    RuleSep Name?                                        -> RuleSepName           {cons("RuleName"), layout("1.first.line == 2.last.line")}
    TypingRulePremiseList RuleSepName TypingRuleConsequence -> TypingRule         {cons("TypingRule"), layout("1.first.col == 2.first.col && 2.first.col == 3.first.col")}
    RuleSepName TypingRuleConsequence                    -> TypingRule            {cons("TypingRule"), layout("1.first.col == 2.first.col")}
    TypingJudgment                                       -> TypingRuleConsequence 
    TypingJudgment                                       -> TypingRulePremiseList {cons("PremiseBase")}
    TypingJudgment TypingRulePremiseList                 -> TypingRulePremiseList {cons("PremiseCons"), layout("1.first.col == 2.first.col")}