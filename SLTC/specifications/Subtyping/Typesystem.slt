module Typesystem

language SimplyTypedLambdaCalculus

meta-variables 	Term "~" { Type Exp }
				Ctx "$" { Context }
				Id "%" { ID }
				R "$" {TRecordEntries RecordEntries}
				Num "&" { Int }

contexts Context := ID{I} x Type{O}

judgments
Context{I} "|-" Exp{I} ":" Type{O}.
Type{I} "<:" Type{I}.
ID{I} "!=" ID{I} is Neq.
Type{I} "!=" Type{I} is Neq.

rules

/* Typing rules */

============== T-int
$C |- &i : int

%x : ~T in $C
============== T-var
$C |- ~x : ~T

(%x : ~T1 ; $C) |- ~e : ~T2
================================= T-abs
$C |- \ %x : ~T1 . ~e : ~T1 -> ~T2

$C |- ~e1 : ~T11 -> ~T12
$C |- ~e2 : ~T2
~T2 <: ~T11
========================= T-app
$C |- ~e1 ~e2 : ~S

$C |- ~e : { %l : ~T $R }
========================= T-proj1
$C |- ~e . %l : ~T

$C |- {%m = ~e2 $R} : { %m : ~S $U }
%m != %l
$C |- { $R } . %l : ~T
============================= T-proj2
$C |- {%m = ~e1 $R} . %l : ~T

============= T-empty
$C |- {} : {}

$C |- ~e : ~T
$C |- { $R } : { $S }
=====================================  T-record
$C |- { %l = ~e $R } : { %l : ~T $S }

/* Definition of the subtyping relation */

======== S-refl
~S <: ~S 

~S <: ~T
~T <: ~U
======== S-trans
~S <: ~U

~T1 <: ~S1
~S2 <: ~T2
======================== S-arrow
~S1 -> ~S2 <: ~T1 -> ~T2

/* Record Subtyping */

============ S-top
{ $R } <: {}

~T <: ~S
{ $R } <: { $U }
=============================== S-depth
{ %l : ~T $R } <: { %l : ~S $U }

{ $R } <: { $S }
=============================== S-width
{ %l : ~T $R } <: { %l : ~T $S}

======================================================= S-perm
{ %l1 : ~T1 %l2 : ~T2 $R } <: { %l2 : ~T2 %l1 : ~T1 $R}

conjectures

===
{} <: {}

===
{ abc : int } <: {}

===
{ l : int m : int } <: { l : int}

===
{ l : {o : int} } <: { l : {}}

===
() |- {x=0 y=1} : {x : int y : int}

===
() |- {x=0 y=1}.x : int

===
() |- {y=0 x=1}.x : int

===
() |- \x : {y : int} . x : { y : int } -> { y : int }

===
() |- (\x : {y : int} . x) {y=1} : { y : int }

===
() |- (\x : {x : int} . x) {x=1} : { x : int }

===
() |- (\x : {y : int} . x) {y=1 x=1} : { y : int }

===
() |- (\x : {y : int} . x) {x=1 y=1} : { y : int }

===
(r : {x : int y : int} ; ()) |- r . x : int

===
() |- (\r : {x : int} . (r.x)) : { x : int } -> int

===
() |- (\r : {x : int} . (r.x)) {x=0 y=0} : int

===
() |- (\r : {x : int} . (r.x)) {y=0 x=0} : int

===
() |- (\x : {x : int} . (x.x)) {y=0 x=0} : int