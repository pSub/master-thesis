module test

language PCF

meta-variables	Term "~" { Type Exp }
				Ctx "$" { Context }
				Id "%" { ID }
				Num "&" { INT }

contexts Context := ID{I} x Type{O}

judgments 

Context{I} "|-" Exp{I} ":" Type{O}.
Type{I} "<:" Type{I}.

rules

%X : ~T in $C
=============== T-var
$C |- ~X : ~T
 
(%X : ~T1 ; $CTX) |- ~E : ~T2
===================================== T-abs
$CTX |- (fun %X : ~T1 (~E)) : ~T1 -> ~T2
 
$CTX |- ~E1 : ~T1 -> ~T2
$CTX |- ~E2 : ~T1
==================== T-app
$CTX |- ~E1 ~E2 : ~T2

(%f : ~T -> ~T ; $C) |- ~e : ~T -> ~T 
=========================================
$C |- fix %f : ~T -> ~T ( ~e ) : ~T -> ~T

$C |- ~e1 : ~T
(%x : ~T ; $C) |- ~e2 : ~U 
===============================
$C |- let %x : ~T = ~e1 in ~e2 : ~U

==============
$C |- &i : int

$C |- ~e1 : int
$C |- ~e2 : ~T
$C |- ~e3 : ~T
====================================
$C |- ifz ~e1 then ~e2 else ~e3 : ~T

$C |- ~e1 : int
$C |- ~e2 : int
====================
$C |- ~e1 + ~e2 : int

$C |- ~e1 : int
$C |- ~e2 : int
====================
$C |- ~e1 - ~e2 : int

$C |- ~e1 : int
$C |- ~e2 : int 
====================
$C |- ~e1 * ~e2 : int 

$C |- ~e1 : int
$C |- ~e2 : int
====================
$C |- ~e1 / ~e2 : int

conjectures


============= 
() |- 1 : int

===============================
(x0 : int ; ()) |- x0 + 3 : int

==================================
() |- fun x : int (x) : int -> int 

=============================
() |- fun x : int (x) 3 : int

=========================================================
() |- ((fun x : int (fun y : int (x))) 1) 1 : int

===============================
(x : int ; y : int ;  ()) |- x + y : int