module Typesystem

language SystemF

meta-variables 	Term "~" { Type Exp }
				Ctx "$" { TermBinding TypeBinding }
				Id "%" { ID }

contexts
TermBinding := ID{I} x Type{O}
TypeBinding := ID{I}

judgments
TermBinding{I} "|" TypeBinding{I} "|-" Exp{I} ":" Type{O}.
Type{O} "= [" ID{I} "->" Type{I} "]" Type{I}.
ID{I} "!=" ID{I} is Neq.

rules

/* Typing rules */

%x : ~T in $C1
=============== T-Var
$C1 | $C2 |- %x : ~T

(%x : ~T1 ; $C1) | $C2 |- ~t2 : ~T2
==================================== T-Abs
$C1 | $C2 |- \ %x : ~T1 . ~t2 : ~T1 -> ~T2

$C1 | $C2 |- ~t1 : ~T11 -> ~T12
$C1 | $C2 |- ~t2 : ~T11
================================ T-App
$C1 | $C2 |- ~t1 ~t2 : ~T12

/* How to encode the freshness condition */
$C1 | (%x ; $C2) |- ~t2 : ~T2
======================================= T-Tabs
$C1 | $C2 |- \ %x . ~t2 : all %x . ~T2

$C1 | $C2 |- ~e : all %x . ~T
~U = [ %x -> ~S ] ~T
============================== T-Tapp
$C1 | $C2 |- ~e [ ~S ] : ~U


/* Type substitution */

=====================
~S = [ %x -> ~S ] %x

%y != %x
====================
%y = [ %x -> ~S ] %y

~U = [ %x -> ~S ] ~T
================================
(all %y . ~U) = [ %x -> ~S ] (all %y . ~T)

======================
int = [ %x -> ~S ] int

~U1 = [ %x -> ~S ] ~T1
~U2 = [ %x -> ~S ] ~T2
====================================
~U1 -> ~U2 = [ %x -> ~S ] ~T1 -> ~T2

conjectures

===
() | () |- \ x . \ y : x . y : all x . (x -> x)

===
() | () |- \ x . \ f : x -> x . \ a : x . (f (f a)) : all x . ((x -> x) -> (x -> x))

===
() | () |- (\ x . \ y : x . y) [ int ] : int -> int

===
() | () |- (\ x . \ f : x -> x . \ a : x . (f (f a))) [ int ] : (int -> int) -> (int -> int)

===
() | () |- (\ x . \ f : x -> x . \ a : x . (f (f a))) [ int -> int ] : ((int -> int) -> (int -> int)) -> ((int -> int)-> (int -> int))

===
() | () |- (\ x . \ y . \ z : x . z) : all x . all y . (x -> x)

===
() | () |- (\ x . \ y . \ z : y . z) : all x . all y . (y -> y)

===
() | () |- (\ x . \ y . \ z : x . z) [ int ] : all y . (int -> int) 

===
() | () |- (\ x . \ y . \ z : x . z) [ int ] [ int ] : (int -> int)

===
() | () |- (\ x . \ x . \ y : x . y) : all x . all x . (x -> x)