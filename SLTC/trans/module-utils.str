module module-utils

imports names
imports utils
imports include/SLTC

rules
    
    resolve-imports : mod -> <fetch-imported-modules;
                              strip-annos;
                              merge-imported-modules(|<strip-annos> mod)> mod
    
    merge-imported-modules(|mod) : modules -> <foldl(debug; merge-imported-module)> (modules, mod)
    merge-imported-module : (Module(_,_,l1,c1,m1,j1,r1,t1),
                             Module(module-dec,imps,l2,c2,m2,j2,r2,t2)) ->
                             Module( module-dec
                                   , imps
                                   , <debug; merge-target-language; debug> (l1, l2)
                                   , <debug; merge-contexts> (c1, c2)
                                   , <merge-meta-variables> (m1, m2)
                                   , <merge-judgments> (j1, j2)
                                   , <merge-rules> (r1, r2)
                                   , <merge-conjectures> (t1, t2))

    // TODO: Extend to support multiple target languages            
    merge-target-language : (Some(_), Some(_)) -> <exit-with-error(|1, "Currently only one traget language is supported")>
    merge-target-language : (Some(l1), _) -> Some(l1)
    merge-target-language : (None(), l2) -> l2
    merge-target-language = <debug> "Failed"

    merge-contexts : (Contexts(c1), Contexts(c2)) -> Contexts(<conc> (c1, c2))

    merge-meta-variables : (MetaVariables(m1), MetaVariables(m2)) -> MetaVariables(<conc> (m1, m2))

    merge-judgments : (Judgments(j1), Judgments(j2)) -> Judgments(<conc> (j1, j2))

    merge-rules : (Rules(r1), Rules(r2)) -> Rules(<conc> (r1, r2))

    merge-conjectures : (Some(Conjectures(t1)), Some(Conjectures(t2))) -> Some(Conjectures(<conc> (t1, t2)))
    merge-conjectures : (None(), t2) -> t2
    merge-conjectures : (t1, None()) -> t1

    fetch-imported-modules : mod -> []
        where <get-imports; equal(|None())> mod
    // FIXME: Somehow transitive imports do not work.
    fetch-imported-modules : mod -> modules //, <fetch-imported-modules> modules)
        where Some(Imports(imports)) := <get-imports> mod;
        	  modules := <map(\Import(m, excluded-sections) ->
        	                       <get-module-ref; debug; reset-sections(|excluded-sections)> m
        	                  \)> imports

    get-imports = proj(Module|2)
    
    reset-sections(|maybe-sections) : m -> m
        where <equal(|None())> maybe-sections
    reset-sections(|maybe-sections) : mod -> <debug; foldl(reset-section)> (sections, mod)
        where Some(ExcludedSections(sections)) := maybe-sections
    reset-section : ("language", Module(a,b,c,d,e,f,g,h)) -> Module(a,b,None(),d,e,f,g,h)
    reset-section : ("meta-variables", Module(a,b,c,d,e,f,g,h)) -> Module(a,b,c,c,MetaVariables([]),f,g,h)
    reset-section : ("judgments", Module(a,b,c,d,e,f,g,h)) -> Module(a,b,c,d,e,Judgments([]),g,h)
    reset-section : ("conjectures", Module(a,b,c,d,e,f,g,h)) -> Module(a,b,c,d,e,f,g,None())
    reset-section : ("contexts", Module(a,b,c,d,e,f,g,h)) -> Module(a,b,c,Contexts([]),e,f,g,h)
    reset-section : ("rules", Module(a,b,c,d,e,f,g,h)) -> Module(a,b,c,d,e,f,Rules([]),h)