module generate-sdf

imports utils
imports include/SLTC
imports org/sugarj/languages/Sdf2

rules
	make-nodes : 
	    Module(_,
               _,
			   Language(t),
               MetaVariables(MetaVariableList(meta-variables)),
               Contexts(contexts),
               Judgments(judgments),
               _,
               _)
		  -> 'module("Generated",
		             [imports(t), imports("Common")], 
			         exports(
				        conc-grammars(context-free-syntax(<map(make-variable)> meta-variables),
                        conc-grammars(context-free-syntax(<map(make-context)> contexts),
				        context-free-syntax(<fanout; (length; range, id);
				                             zip; map(make-judgment)> judgments)))
			         )
		      )

	// Generate syntax of context definitons	
	make-context : ContextDefinition(Name, Definition) -> [
		prod("\"()\"", Name, <make-cons'> ["ContextEmpty-", Name]),
		prod(<concat-strings> [elem, " \";\" ", Name], Name,
							   <make-cons'> ["ContextBind-", Name]),
		prod(<concat-strings> ["\"(\" ", Name, " \")\""], Name, <make-attr> "bracket"),
		prod(<concat-strings> [elem, " \"in\" ", Name], "TypingJudgment", 
							   <make-cons'> ["ContextLookup-", Name])
	   ]
		where
			elem := <names; intersperse(|" \":\" "); concat-strings> Definition

	// Generate syntax of meta-variable definitions	
	make-variable : MetaVariableDefinition(Name, MetaVariablePrefix(prefix), Scope(ids)) ->
		<map(\scope -> prod(<concat-strings>["\"", prefix, "\" MetaVariable"],
						    scope,
						    <make-cons'> ["MetaVariable-", scope])\)> ids

	// Generate syntax of typing judgments
	make-judgment : (num, Judgment(s1, pos, s2, built-in))
	       -> prod(<names; intersperse(|" "); concat-strings> merged,
	               "TypingJudgment",
	               <maybe(\BuiltIn(s) -> <conc-strings> (typing-judgment, s)\
                         | <conc-strings> (typing-judgment, <int-to-string> num));
                    make-cons> built-in)
			where
				merged := <conc> ([<option-to-string> s1], pos, [<option-to-string> s2]);
				typing-judgment := "TypingJudgment-"

    // Extract position 1 (the name) of the hole for all elements of the list
	names : list -> <map(try(proj(Hole|1)))> list

    // Create a constructor attribute
	make-cons : name -> <concat-strings; make-attr> ["cons(\"", name , "\")"]

	// Concatenate a given list of strings and create a constructor attribute
	// from the result  
	make-cons' = concat-strings ; make-cons

	// Create an attribute from the given string
	make-attr : str  -> <concat-strings> ["{", str, "}"]

strategies
	toSdf = make-nodes