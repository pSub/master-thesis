module generate-constraints

imports utils
imports constraint-language
imports constraint-template-language
imports constraint-solving
imports constraint-utils
imports optimize-constraint-templates
imports generate-constraint-generator
imports store-utils
imports include/SLTC

signature
    sorts Constraint
    constructors
        ConstraintSet : List(Constraint)

rules
    generate-constraints :
        Module(ModuleDec(_),
                 imports,
                 Language(l),
                 MetaVariables(meta-variables),
                 Contexts(context-definitions),
                 Judgments(judgments),
                 Rules(typing-rules),
                 Some(Conjectures(conjectures)))
        -> <finally(map(finally(\TypingRule(_, conjecture) ->
                 // FIXME: Refactor/rewrite this initialization
                 (<get-inputs(|judgments);
                  \i -> <remove-all(node-is-ctx(|context-classes));
                         generate(|judgments, context-definitions, templates,
                                   <initialize-store(|store, context-definitions, context-classes)> i)> i
                  \;
                  try(\(Some(outputs), constraints) ->
                    (outputs, <conc> (<zip; map(\(a, b) -> <makeEq(|Some(Error(["Type", a, "does not match annotated type", b])))> (a, b)\)> (outputs, <get-outputs(|judgments)> conjecture), constraints))
                  \)
                  > conjecture, <get-outputs(|judgments)> conjecture)
                \, clear-store(|store))), tidy-up(|store))> conjectures
        where
            // Retrieve all context names
            context-names := <map(proj(ContextDefinition|1))> context-definitions;

            // Obtain a list of meta-variable names, that represent contexts and contexts only
            context-classes := <filter(\MetaVariableDefinition(name, _, Scope(scope)) ->
                                       <isect; not(equal(|[])); !name> (context-names, scope)
                                       \)> meta-variables;

            // Generate the constraint templates from the type system specification
            templates := <to-constraint-generator(|judgments, context-definitions, context-classes);
                          solve-which-ambiguities> typing-rules;
            
            // Initialize the store that contains the contexts
            empty-contexts := <map-with-index((id, !([], <new-hashtable>)))> context-definitions;
            store := <new-hashtable(|<length; inc> context-definitions, 100);
                             hashtable-putlist(|empty-contexts)>

    /**
     * Generates the set of constraints.
     *
     * @param judgments - judgment declarations
     * @param contexts - context declarations
     * @param templates - constraint templates
     * @param store - list of hashtables that store context information
     */
    generate(|judgments, contexts, templates, store) : inputs ->
             <generate'(|judgments, contexts, templates, inputs, store)> match
        with
            // Find the constraint template that matches the inputs of the given term
            // FIXME: Better error messages if no match is found.
            match := <find-match(|inputs, store)> templates

    /**
     * Helper rule for constraint generation. It pattern matches against the matching
     * template found in `generate` and does the actual constraint generation.
     *
     * @param j - judgment declarations
     * @param c - context declarations
     * @param t - constraint templates
     * @param term - input terms
     * @param s - hashtable containing hashtables that store context information
     */
    generate'(|j, c, t, term, s) : Rule__(name, (pattern, _), outputs, constraints) ->
            (Some(outputs), <conc> (iconstraints, <make-io-dependency-constraints(|pattern, term, name)> outputs,
                              <make-implicit-equality-constraints(|pattern, term, name)> pattern))
        where
            // Instantiate the variables in the error messages.
            iconstraints := <map(instantiate-error(|pattern, term))> constraints

    generate'(|j, c, t, term, s) : Binding__(xs, calls, Rule__(name, (pattern, ctx), outputs, constraints)) ->
           (Some(outputs'), new-constraints)
        where
            // Retrieve and remove elements from the context according to the context pattern.
            ctx' := <map(\(ctx, i, _) -> <pop(|s)> ctx \)> ctx;

            // Append the context pattern to the input pattern.
            pattern'' := <conc> (pattern, <map(\(_, i, o) -> (i, o)\)> ctx);

            // Append the instantiated context pattern to the input term.
            term'' := <conc> (term, ctx');

            // Use fresh variable names to instantiate the rule.
            // FIXME: Is there a better solution, than renaming?
            vars := <collect-om(\Var__(v) -> <(string-starts-with(|"X"); !Var__(v))> v\)> (xs, pattern'', term'', calls, constraints);
            (xs', pattern', term', calls', constraints', outputs') := <zip; replace-all(|(xs , pattern'', term'', calls, constraints, outputs))> (vars, <length; newnames(|"Y"); map(makeVar)> vars);

            // Execute the calls of the rule.
            outputs-constraints := <foldl(execute(|j, c, t, <hashtable-deep-copy> s, pattern', term', name))> (calls', []);

            // Make constraints for input-output dependencies in the conclusion of the rule.
            input-output-constraints := <filter(\Some(s) -> s\); make-io-dependency-constraints(|pattern', term', name)> outputs';

            // Make constraints for implicit equalities in the conclusion.
            implicit-equalities := <make-implicit-equality-constraints(|pattern', term', name)> pattern';

            // Instantiate the variables in the error messages.
            iconstraints := <map(instantiate-error(|pattern', term'))> constraints';

            // Associate the outputs of the calls with the variables of the binding.
            xs-outputs := <zip; filter(\(xs, Some(s)) -> (xs, s)\); mapconcat(zip)> (xs', <map(Fst)> outputs-constraints);

            // Replace all previously bound variables with their values in the constraint set.
            constraints'' := <replace-all(|iconstraints)> xs-outputs;

            // Merge all generated constraints.
            new-constraints := <conc> (constraints'', <mapconcat(Snd)> outputs-constraints, input-output-constraints, implicit-equalities)

    generate'(|j, c, t, term, s) : Fork__(rulez) ->
           // Apply all rules until the first one produces a solvable constraint set
           // apply the resulting mgu and return the term as an output. The constraint
           // set is empty, because all produced constraints are already solved.
           (<until(generate'(|j, c, t, term, <hashtable-deep-copy> s);
                   \(o, cs) -> <unify-internal; apply-mgu(|o)> cs\) < id + !None()> rulez,
           [])

    /**
     * Executes the calls specified in the rules.
     *
     * @param j - judgment declarations
     * @param c - context declarations
     * @param t - constraint templates
     * @param s - hashtable containing hashtables that store context information
     * @param pattern - the pattern of the conclusion
     * @param term - input terms
     * @param name - the name of the rule
     * @type ((call, dependencies), accumulator) -> (outputs, constraints)
     */
    execute(|j, c, t, s, pattern, term, name) : ((call, dep), accu) ->
                          // Update the pattern and the term according to
                          // the dependencies.
                 <finally(pattern' := <update-pattern(|pattern)> dep;
                          term' := <update-term(|term, accu)> dep;
                          switch !call
                          case ?Lookup__(_,_):
                              <to-tuple; instantiate-lookup(|pattern', term');
                               // FIXME: Wrap the output into Option
                               (lookup(|s) < \ o -> (Some(o), [])\ +
                                             \ (_, o) -> (None(), [CFail__(Error([o, " not found in context"]))])\)> call
                          case ?CEq__(a, b, info):
                              !(Some([]), [<instantiate-error(|pattern', term')>
                                        CEq__(<instantiate(|pattern', term')> [a],
                                              <instantiate(|pattern', term')> [b],
                                              info) ])
                          case ?CNeq__(a, b, info):
                              !(Some([]), [ <instantiate-error(|pattern', term')>
                                        CNeq__(<instantiate(|pattern', term')> [a],
                                               <instantiate(|pattern', term')> [b],
                                               info) ])
                          otherwise:
                            // Instantiate the judgment that shall be called.
                            (param, binding) := <to-tuple; instantiate-judgment(|pattern', term')> call;

                            // Create constraints for the variables in the context bindings.
                            binding-constraints := <make-binding-constraints(|name)> (<to-tuple; Snd> call, binding);

                            // Call generate for the instantiated judgment and the updated store.
                            <generate(|j, c, t, <update-store(|s)> binding)> param;

                            // Pass the outputs untouched and add the binding constraints to
                            // the resulting constraints.
                            (id, conc(|binding-constraints))
                          end;
                          singelton; conc(|accu), // Book keeping.
                          destroy-store(|s))>

    /**
     * Extracts the patterns out of the dependencies and appends those
     * to the pattern of the conclusion.
     *
     * @param pattern - the pattern of the conclusion
     * @type dependencies -> List(pattern) 
     */
    update-pattern(|pattern) = map(Snd); conc(|pattern)

    /**
     * Extracts the already computed outputs and constraints and unify those
     * that are listed in the given dependencies.
     *
     * @param term - an arbitary term
     * @param accu - the accumulator of `execute'
     * @type dependencies -> a
     */
    update-term(|term, accu) = map(Fst; \i -> <index(|i)> accu\;
                                   \(Some(o), cs) -> <unify-internal; apply-mgu(|o)> cs\); conc(|term)

    /**
     * Initialized the given store with the context bindings.
     *
     * @param store - a store
     * @type List(term) -> store
     */
    initialize-store(|store, context-definitions, context-classes) =
                               filter(node-is-ctx-bind);
                               mapconcat(ctx-bind-to-kv-list(|context-definitions, context-classes));
                               update-store(|store)


    /**
     * Cleans up everything that was needed during the constraint
     * generation. This includes:
     *
     *     - destroying the store
     *
     * @param store - a hashtable containing hashtables
     */
    tidy-up(|store) = destroy-store(|store)
