module generate-constraints

imports utils
imports constraint-language
imports constraint-template-language
imports constraint-solving
imports constraint-utils
imports generate-constraint-generator
imports include/SLTC

signature
    sorts Constraint
    constructors
        ConstraintSet : List(Constraint)

rules
    generate-constraints :
        Module(ModuleDec(_),
                 imports,
                 Language(l),
                 MetaVariables(meta-variables),
                 Contexts(context-definitions),
                 Judgments(judgments),
                 Rules(typing-rules),
                 Some(Conjectures(conjectures)))
        -> <map(\TypingRule(_, conjecture) ->
                 (<get-inputs(|judgments);
                  \i -> <remove-all(node-is-ctx(|context-classes));
                         generate(|judgments, context-definitions, templates,
                                   <filter(node-is-ctx-bind);
                                    mapconcat(ctx-bind-to-kv-list(|context-definitions, context-classes));
                                    update-store(|store)> i)> i
                  \> conjecture, <get-outputs(|judgments)> conjecture)
                \; clear-store(|store)); tidy-up(|store)> conjectures
        where
            // Retrieve all context names
            context-names := <map(proj(ContextDefinition|1))> context-definitions;

            // Obtain a list of meta-variable names, that represent contexts and contexts only
            context-classes := <filter(\MetaVariableDefinition(name, _, Scope(scope)) ->
                                       <isect; not(equal(|[])); !name> (context-names, scope)
                                       \)> meta-variables;

            // Generate the constraint templates from the type system specification
            templates := <to-constraint-generator(|judgments, context-definitions, context-classes)> typing-rules;
            
            // Initialize the store that contains the contexts
            empty-contexts := <length; range; Dupl; (id, map(new-hashtable)); zip> context-definitions;
            store := <new-hashtable(|<length; inc> context-definitions, 100);
                             hashtable-putlist(|empty-contexts)>

    /**
     * Generates the set of constraints.
     *
     * @param judgments - judgment declarations
     * @param contexts - context declarations
     * @param templates - constraint templates
     * @param store - list of hashtables that store context information
     */
    generate(|judgments, contexts, templates, store) : inputs ->
             <generate'(|judgments, contexts, templates, inputs, store)> match
        where
            // Find the constraint template that matches the inputs of the given term
            match := <find-match(|<debug> inputs)> templates

    /**
     * Helper rule for constraint generation. It pattern matches against the matching
     * template found in `generate` and does the actual constraint generation.
     *
     * FIXME: This code needs refactoring!
     *
     * @param j - judgment declarations
     * @param c - context declarations
     * @param t - constraint templates
     * @param term - input terms
     * @param s - hashtable containing hashtables that store context information
     */
    generate'(|j, c, t, term, s) : Rule(name, pattern, outputs, constraints) ->
            (outputs, <conc> (constraints, <make-io-dependency-constraints(|pattern, term, name)> outputs,
                              <make-implicit-equality-constraints(|pattern, term, name)> pattern))


    generate'(|j, c, t, term, s) : Binding(xs, calls, Rule(name, pattern, outputs, constraints)) ->
           (outputs', new-constraints)
        where
            // Execute the calls of the rule.
            outputs-constraints := <foldl(execute(|j, c, t, s, pattern, term, name))> (calls, []);

            // Make constraints for input-output dependencies in the conclusion of the rule.
            input-output-constraints := <make-io-dependency-constraints(|pattern, term, name)> outputs;

            // Make implicit equalities
            implicit-equalities := <make-implicit-equality-constraints(|pattern, term, name)> pattern;

            // Use fresh variable names to instantiate the rule.
            // FIXME: Is there a better solution, than renaming?
            vars := <collect-om(\Var__(v) -> <(string-starts-with(|"X"); !Var__(v))> v \)> (xs, outputs, constraints, outputs-constraints, input-output-constraints);
            (xs', outputs', constraints', outputs-constraints', io-constraints', implicit-equalities') := <zip; replace-all(|(xs, outputs, constraints, outputs-constraints, input-output-constraints, implicit-equalities))>
                                                                    (vars, <length; newnames(|"Y"); map(makeVar)> vars);

            // Assoziate the outputs of the calls with the variables of the binding.
            xs-outputs := <zip; mapconcat(zip)> (xs', <map(Fst)> outputs-constraints');

            // Replace all previously bound variables with their values in the constraint set.
            constraints'' := <replace-all(|constraints')> xs-outputs;

            // Merge all generated constraints.
            new-constraints := <conc> ( constraints'', <mapconcat(Snd)> outputs-constraints', io-constraints', implicit-equalities')

    /**
     *
     */
    execute(|j, c, t, s, pattern, term, name) : ((call, dep), accu) ->
                         <pattern' := <update-pattern(|pattern)> dep;
                          term' := <update-term(|term, accu)> dep;
                          switch !call
                          case ?Lookup(_,_):
                              <to-tuple; instantiate-lookup(|pattern', term'); lookup(|s); \ o -> (o, [])\> call
                          case ?CEq__(a, b, info):
                              !([], [CEq__(a, b, info)]) // FIXME: Needs instantiation.
                          case ?CNeq__(a, b, info):
                              !([], [CNeq__(a, b, info)]) // FIXME: Needs instantiation.
                          otherwise:
                            (param, binding) := <to-tuple; instantiate-judgment(|pattern', term')> call;
                            binding-constraints := <make-binding-constraints(|name)> (call, binding);
                            <generate(|j, c, t, <update-store(|s)> binding)> param;
                            (id, conc(|binding-constraints))
                          end; singelton; conc(|accu)>

    /**
     *
     */
    update-pattern(|pattern) = map(Snd); conc(|pattern)

    /**
     *
     */
    update-term(|term, accu) = map(Fst; \i -> <index(|i)> accu\;
                                   \(o, cs) -> <unify; Snd; apply-mgu(|o)> cs \); conc(|term)                    

    /**
     * Updates the store `s` with the provided context bindings. Context
     * bindings are a list of triples containing the context id, inputs 
     * and outputs. 
     *
     * @param s - a hashtable containing hashtables
     */
    update-store(|s) : ctx-binds -> <foldl(\((ctx, i, o), s') -> 
                                                <hashtable-put(|ctx, <hashtable-get(|ctx);
                                                                      hashtable-put(|i, o)> s'
                                                              )> s'
                                           \)> (ctx-binds, s)

    /**
     * Looks up the context `ctx` at `key`.
     *
     * @param s - a hashtable containing hashtables
     */
    lookup(|s) : (ctx, key) -> <hashtable-get(|ctx); hashtable-get(|key)> s

    /**
     * Clears all contexts in the store.
     *
     * @param store - a hashtable containing hashtables
     */
    clear-store(|store) = where(<hashtable-getlist; map((id, hashtable-clear))> store)

    /**
     * Cleans up everything that was needed during the constraint
     * generation. This includes:
     *
     *     - destroying the store
     *
     * @param store - a hashtable containing hashtables
     */
    tidy-up(|store) = where(<hashtable-destroy> store)