module generate-constraints

imports utils
imports constraint-language
imports generate-constraint-generator
imports include/SLTC

signature
    sorts Constraint
    constructors
        ConstraintSet : List(Constraint)

rules
    generate-constraints : 
        Module(ModuleDec(_),
                 imports,
                 Language(l),
                 MetaVariables(meta-variables),
                 Contexts(context-definitions),
                 Judgments(judgments),
                 Rules(typing-rules),
                 Some(Conjectures(conjectures)))
        -> <map(\TypingRule(_, conjecture) ->
                 <get-inputs(|judgments);
                  \i -> <remove-all(node-is-ctx(|context-classes));
                         generate(|judgments, context-definitions, templates,
                                   <filter(node-is-ctx-bind);
                                    mapconcat(ctx-bind-to-kv-list(|context-definitions, context-classes));
                                    topdown(try(\Output(n) -> n\)); update-store(|store)> i)> i\;
                  \(outputs, constraints) ->
                    (outputs, <conc>(<zip; map(makeEq(|Some("[Conjecture]")))> (outputs, <get-outputs'(|judgments)> conjecture), constraints))
                  \> conjecture
                \)> conjectures
        where
            context-names := <map(proj(ContextDefinition|1))> context-definitions;
            context-classes := <filter(\MetaVariableDefinition(name, _, Scope(scope)) ->
                                       <isect; not(equal(|[])); !name> (context-names, scope)
                                       \)> meta-variables;
            templates := <to-constraint-generator(|judgments, context-definitions, context-classes)> typing-rules;
            empty-contexts := <length; range; Dupl; (id, map(new-hashtable)); zip> context-definitions;
            store := <new-hashtable(|<add> (<length> context-definitions, 1), 100);
                             hashtable-putlist(|empty-contexts)>

    /**
     * Generates the set of constraints.
     *
     * @param judgments - judgment declarations
     * @param contexts - context declarations
     * @param templates - constraint templates
     * @param store - list of hashtables that store context information
     */
    generate(|judgments, contexts, templates, store) : inputs ->
             <generate'(|judgments, contexts, templates, inputs, store)> match
        where
            // Find the constraint template that matches the inputs of the given term
            match := <find-match(|inputs)> templates

    /**
     * Helper rule for constraint generation. It pattern matches against the matching
     * template found in `generate` and does the actual constraint generation.
     *
     * FIXME: This code needs refactoring!
     *
     * @param j - judgment declarations
     * @param c - context declarations
     * @param t - constraint templates
     * @param i - input terms
     * @param s - list of hashtables that store context information
     */
    generate'(|j, c, t, i, s) : Rule(name, pattern, outputs, constraints) -> (outputs, constraints)
    generate'(|j, c, t, i, s) : Binding(xs, calls, Rule(name, inputs, outputs, constraints)) ->
           (outputs', new-constraints) //(outputs', new-constraints)
        where
            // Abbreviations
            pattern := inputs;
            term := i;

            // // TODO: Do we actually need this? Skip this when doing the rewrite.
            // // Make equality constraints between the output variables of the bindings and
            // // the instantiated outputs.
            // binding-constraints := <(map(Snd; map(\(_, _, n) -> n\)), map(Snd; map(\(_, _, n) -> n\)));
            //                         (flatten-list, flatten-list);
            //                         zip; map(makeEq)> (calls, inputs-bindings);

            outputs-constraints := <foldl(execute(|j, c, t, s, pattern, term))> (calls, []);

            // FIXME: Is there a better solution, than renaming?
            vars := <collect-om(?Var__(_))> (xs, outputs, constraints);
            (xs', outputs', constraints', outputs-constraints') := <zip; replace-all(|(xs, outputs, constraints, outputs-constraints))>
                                                                    (vars, <length; newnames(|"Y"); map(makeVar)> vars);

            // Assoziate the outputs of the recursive calls with the variables of the binding.
            xs-outputs := <zip; mapconcat(zip)> (xs', <map(Fst)> outputs-constraints');

            // Replace all previously bound variables with their values.
            constraints'' := <replace-all(|constraints')> xs-outputs;

            // Merge all constraints.
            new-constraints := <conc> ( constraints'', <mapconcat(Snd)> outputs-constraints' )

    instantiate(|pattern, terms) = find-matching-positions(|pattern); extract-terms(|terms)
    instantiate-judgment(|pattern, terms) =
        (instantiate(|pattern, terms), map((id, instantiate(|pattern, terms),
                                            instantiate(|pattern, terms))))
    instantiate-lookup(|pattern, terms) = (id, instantiate(|pattern, terms), id)

    update-pattern(|pattern) = map(Snd); conc(|pattern)
    update-term(|term, accu) = map(Fst; \i -> <index(|i)> accu\; Fst); conc(|term)

    execute(|j, c, t, s, pattern, term) : ((call, dep), accu) ->
                         // FIXME: Type variables are not correctly represented in the bindings
                         <pattern' := <update-pattern(|pattern)> dep;
                          term' := <update-term(|term, accu)> dep;
                          switch !call
                          case ?Lookup(_,_,_):
                              <to-tuple; instantiate-lookup(|pattern', term'); lookup(|s); \ o -> (o, [])\> call
                          case ?CEq__(a, b, info):
                              !([], CEq__(a, b, info))
                          case ?CNeq__(a, b, info):
                              !([], CNeq__(a, b, info))
                          otherwise:
                            (param, binding) := <to-tuple; instantiate-judgment(|pattern', term')> call;
                            <generate(|j, c, t, <update-store(|s)> binding)> param
                          end; singelton; conc(|accu)>

    /**
     * Provided with a list of paths, this strategy returns the
     * elements in `terms` described by the paths. A path describes
     * contains the positions in the argument list to which should be
     * descended to.
     * 
     * @param terms - an list of arbitrary terms
     */
    extract-terms(|terms) = map(retrieve(|terms))
    
    /**
     * Finds the positions of the provided elements in the `pattern`.
     *
     * @param pattern - an arbitrary term
     */
    find-matching-positions(|pattern) = map(get-index < singelton + search(|pattern); reverse)

    /**
     * Traverses the pattern like a tree and records the path until `x` is
     * found literally in `pattern`. The recorded path contains the positions
     * in the argument list in which was descended.
     */
    search(|pattern) : x -> <search'> (x, [1], pattern)
    search' : (x, is, []) -> <fail>
    search' : (x, [i|is], [v@c#([]) | pattern]) -> <if <equal> (x, v)
                                                    then <id> [i|is]
                                                    else <search'> (x, <add; singelton> (i, 1), pattern)
                                                    end>
    search' : (x, is, [c#(args) | pattern]) -> <get-index < \ i -> [i|is] \ + <search'> (x, [1|is], <conc> (args, pattern)) > (x, args)

    /**
     * Walks along the paths in `term` and returns to element
     * at the end of the path.
     */
    retrieve(|term) : [p] -> <index> (p, <get-arguments> term)
    retrieve(|term) : [p|path] -> <index; \ node -> <retrieve(|node)> path\> (p, <get-arguments> term)

    /**
     * Search for the matching pattern for `inputs` in the constraint templates. 
     *
     * FIXME: What if multiple rules match?
     *
     * @param inputs - a list of arbitary terms
     */    
    find-match(|inputs) : [] -> <singelton; error> "No match found!"
    find-match(|inputs) : [t|ts] -> <if equal(|<length> inputs, <get-pattern; length> t)
                                     then if <zip; Dupl; (filter(match-constructors); length,
                                                            length); equal> (inputs, <get-pattern> t)
                                           then <id> t
                                           else <find-match(|inputs)> ts
                                           end
                                     else <find-match(|inputs)> ts
                                     end>
    
    /**
     * Defines when two terms match
     */
    match-constructors : (t, s) -> < equal(|t-cons, s-cons) <+
                                     <where(is-meta-variable)> s-cons <+
                                     <?Var__(_)> s>
        where
            s-cons := <get-constructor> s;
            t-cons := <get-constructor> t

    /**
     * Updates the store `s` with the provided context bindings. Context
     * bindings are a list of triples containing the context id, inputs 
     * and outputs. 
     *
     * @param s - a hashtable containing hashtables
     */
    update-store(|s) : ctx-binds -> <foldl(\((ctx, i, o), s') -> 
                                                <hashtable-put(|ctx, <hashtable-get(|ctx);
                                                                      hashtable-put(|i, o)> s'
                                                              )> s'
                                           \)> (ctx-binds, s)

    /**
     * Looks up the context `ctx` at `key` and assigns the result to `vars`.
     *
     * @param s - a hashtable containing hashtables
     */
    lookup(|s) : (ctx, key, vars) -> <hashtable-get(|ctx); hashtable-get(|key)> s