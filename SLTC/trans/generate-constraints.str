module generate-constraints

imports utils
imports generate-constraint-generator
imports include/SLTC

signature
    sorts Constraint
    constructors
                
        ConstraintSet : List(Constraint)
        
        
rules
    generate-constraints : 
        Module(ModuleDec(_),
                 imports,
                 Language(l),
                 MetaVariables(m),
                 Contexts(ContextDefinitions),
                 Judgments(judgments),
                 Rules(typing-rules),
                 Some(Conjectures(conjectures)))
        -> <map(\TypingRule(_, conjecture) ->
                 <get-inputs(|judgments); generate(|judgments, templates)> conjecture
                \)> conjectures
        where
            templates := <to-constraint-generator(|judgments, typing-rules)>
             
    generate(|judgments, templates) : inputs -> <generate'(|judgments, templates, inputs)> match
        where
             match := <find-match(|inputs)> templates
             
    generate'(|j, t, i) : Rule(pattern, outputs , constraints) -> (outputs, constraints)
    generate'(|j, t, i) : Binding(xs, calls, Rule(pattern, outputs, constraints)) ->
            (outputs, constraints')
        where
            positions := <map(find-matching-positions(|pattern))> calls;
            input-terms := <map(extract-terms(|i))> positions;
            outputs-constraints := <map(generate(|j, t))> input-terms;
            xs-outputs := <zip; mapconcat(zip)> (xs, <map(Fst)> outputs-constraints);
            constraints' := <foldl(\(xo, cs) -> <replace(|cs)> xo\)> (xs-outputs, constraints)
            
    extract-terms(|inputs) = map(\pos -> <fetch> (inputs, pos)\)
    find-matching-positions(|c-pattern) = map(get-position(|c-pattern); reverse)
    get-position(|pattern) : x -> <get-index < singelton + search> (x, pattern)

    search : (x, pattern) -> <search_> (x, [1], pattern)
    search_ : (x, is, []) -> <fail>
    search_ : (x, [i|is], [v@c#([]) | pattern]) -> <if <equal> (x, v)
                                                    then <id> [i|is]
                                                    else <search_> (x, <add; singelton> (i, 1), pattern)
                                                    end>
    search_ : (x, is, [c#(args) | pattern]) -> <get-index < \ i -> [i|is] \ + <search_> (x, [1|is], <conc> (args, pattern)) > (x, args)

    fetch : (cons#(args), [p]) -> <index> (p, args)
    fetch : (cons#(args), [p|path]) -> <index; \ n -> <fetch> (n, path)\> (p, args)

    // FIXME: What if multiple rules match?    
    find-match(|inputs) : [] -> <singelton; error> "No match found!"
    find-match(|inputs) : [t|ts] -> <if equal(|<length> inputs, <get-pattern; length> t)
                                     then if <zip; fanout; (filter(match-constructors); length,
                                                            length);equal> (inputs, <get-pattern> t)
                                           then <id> t
                                           else <find-match(|inputs)> ts
                                           end
                                     else <find-match(|inputs)> ts
                                     end>
    
    match-constructors : (t, s) -> < equal(|t-cons, s-cons) <+
                                     <is-meta-variable> s-cons>
        where
            s-cons := <explode-term; Fst> s;
            t-cons := <explode-term; Fst> t
            
    is-meta-variable = string-tokenize(|<singelton> '-'); Hd; \ cons -> <equal> (cons, "MetaVariable") \