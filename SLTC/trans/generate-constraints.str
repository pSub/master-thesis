module generate-constraints

imports utils
imports constraint-language
imports constraint-template-language
imports constraint-solving
imports constraint-utils
imports optimize-constraint-templates
imports generate-templates
imports store-utils
imports include/SLTC

rules
    generate-constraints : Module(_, _, _, _,
                                  Contexts(context-definitions),
                                  Judgments(judgments),
                                  Rules(typing-rules), _) -> <generate-constraints(|templates)>
        where
            // Generate the constraint templates from the type system specification
            templates := <to-templates(|judgments, context-definitions);
                          optimize-templates(|context-definitions)> typing-rules

    generate-constraints(|templates) : Module(_, _, _, _, _, _, _, None()) ->
         <exit-with-error(|"Not conjectures found", 1)>
    generate-constraints(|templates) :
        Module(ModuleDec(_),
                 imports,
                 Language(l),
                 MetaVariables(meta-variables),
                 Contexts(context-definitions),
                 Judgments(judgments),
                 Rules(typing-rules),
                 Some(Conjectures(conjectures)))
        -> <finally(
              map(finally(
                 \TypingRule(PremiseBase(), RuleName(type,_), conjecture) ->
                    // Prepare the input and initialize the store.
                    <prepare-generation(|judgments, context-definitions, store);
                    \input ->
                        // Generate the constraints.
                        <generate(|templates, store, <get-outputs(|judgments)> conjecture)> (<get-judgment-id> conjecture, input)
                    \; \result -> (result, type)\
                    > conjecture
                 \, clear-store(|store))),
            tidy-up(|store))> conjectures
        where
            if <[]> typing-rules then exit-with-error(|"No typing rules found", 1) else id end;
            
            // Initialize the store that contains the contexts
            context-number := <collect-om(is-ctx-modification; get-ctx-id); list-max> templates;
            empty-contexts := <inc; range; Tl; map-with-index((id, !([], <new-hashtable>)))> context-number;
            store := <new-hashtable(|context-number, 100); hashtable-putlist(|empty-contexts)>

    /**
     * Pepares the inputs for the constraint generation and initializes the store.
     */
    prepare-generation(|judgments, context-definitions, store) =
        get-inputs(|judgments); where(initialize-store(|store, context-definitions));
        remove-all(node-is-ctx)
    /**
     * Generates the set of constraints.
     *
     * @param templates - constraint templates
     * @param store - list of hashtables that store context information
     */
    generate(|templates, store, expected-outputs) : (judg-number, inputs) ->
             // Find the constraint template that matches the inputs of the given term
             // if a matching rule could be found evaluate that, otherwise return an error.
             <find-match(|inputs, judg-number, store) < generate'(|templates, inputs, store, expected-outputs)
                                                      + !(None(), [CFail__(Error(["No rule found that matches", inputs]))])> templates

    // generate(|templates, store) : (judg-number, inputs) ->
    //          // Find the constraint template that matches the inputs of the given term
    //          // if a matching rule could be found evaluate that, otherwise return an error.
    //          <find-match(|inputs, judg-number, store) < generate'(|templates, inputs, store)
    //                                                   + !(None(), [CFail__(Error(["No rule found that matches", inputs]))])> templates

    // add-assertion(|expected-outputs) : Template__(a, b, Conclusion__(c, d, e, outputs), constraints) ->
    //     Template__(a, b, Conclusion__(c, d, e, outputs), <conc> (<zip; map(\(a, b) -> <makeCEq(|Some([Error(["Type", a, "does not match annotated type", b])]))> (a, b)\)> (outputs, expected-outputs), constraints))
    // add-assertion(|expected-outputs) : Fork__(ts) -> Fork__(<map(add-assertion(|expected-outputs))> ts)

    /**
     * Helper rule for constraint generation. It pattern matches against the matching
     * template found in `generate` and does the actual constraint generation.
     *
     * @param t - constraint templates
     * @param term - input terms
     * @param s - hashtable containing hashtables that store context information
     */
    generate'(|t, term, s, expected-outputs) :
         Template__(calls, Conclusion__(judg-name, name, (pattern, ctx), outputs), constraints) ->
         (Some(outputs'), new-constraints)
        where
            <debug> name;
            // Retrieve and remove elements from the context according to the context pattern.
            ctx' := <filter(\Binding__(ctx, i, _) -> <pop(|s)> ctx \ <+
                            where(\Reset__(ctx) -> <clear-context(|s, ctx)> \); skip)> ctx;

            // Append the context pattern to the input pattern.
            pattern'' := <conc> (pattern, <filter(\Binding__(_, i, o) -> (i, o)\)> ctx);

            // Append the instantiated context pattern to the input term.
            term'' := <conc> (term, ctx');

            // Use fresh variable names to instantiate the rule.
            // FIXME: Is there a better solution, than renaming?
            vars := <collect-om(\Var__(v) -> <(string-starts-with(|"X"); !Var__(v))> v\)> (pattern'', term'', calls, constraints);
            (pattern', term', calls', constraints', outputs') := <zip; replace-all(|(pattern'', term'', calls, constraints, outputs))> (vars, <length; newnames(|"Y"); map(makeVar)> vars);

            // Execute the calls of the rule.
            outputs-constraints := <foldl(execute(|t, <where(<equal(|[])> ctx) <+ hashtable-deep-copy> s, pattern', term', name))> (calls', []);

            // Make constraints for input-output dependencies in the conclusion of the rule.
            input-output-constraints := <make-io-dependency-constraints(|pattern', term', name)> outputs';

            // Instantiate the variables in the error messages.
            iconstraints := <map(instantiate-error(|pattern', term'))> constraints';

            // Associate the outputs of the calls with the variables of the binding.
            //xs-outputs := <zip; filter(\(xs, Some(s)) -> (xs, s)\); mapconcat(zip)> (xs', <map(Fst)> outputs-constraints);

            // Replace all previously bound variables with their values in the constraint set.
            //constraints'' := <replace-all(|iconstraints)> xs-outputs;

            assertion := <zip; map(\(a, b) -> <makeCEq(|Some([Error(["Type", a, "does not match annotated type", b])]))> (a, b)\)> (outputs', expected-outputs);

            // Merge all generated constraints.
            new-constraints := <conc> (
                // constraints'',
                assertion,
                 <mapconcat(Snd)> outputs-constraints,
                                       input-output-constraints)

    generate'(|ts, term, s, expected-outputs) : Fork__(rulez) ->
           // Apply all rules until the first one produces a solvable constraint set
           // apply the resulting mgu and return the term as an output.
           // FIXME: destroy the store copies
           <until(\t -> <generate'(|ts, term, <hashtable-deep-copy> s, expected-outputs)> t\;
                   \(Some(o), cs) -> (<conc(|<zip; map(\(a, b) -> <makeCEq(|Some([Error(["Type", a, "does not match annotated type", b])]))> (a, b)\)> (o, expected-outputs)); unify-internal; apply-mgu(|o)> cs, cs)\)
                   < \(x, cs) -> (Some(x), cs)\
                   + !(None(), [CFail__(Error(term))])> rulez

    /**
     * Executes the calls specified in the rules.
     *
     * @param t - constraint templates
     * @param s - hashtable containing hashtables that store context information
     * @param pattern - the pattern of the conclusion
     * @param term - input terms
     * @param name - the name of the rule
     * @type ((call, dependencies), accumulator) -> (outputs, constraints)
     */
    execute(|t, s, pattern, term, name) : ((call, dep), accu) ->
                          // Update the pattern and the term according to
                          // the dependencies.
                <finally((term', pattern') := <update(|pattern, term, accu)> dep;
                          switch !call
                          case ?Lookup__(_,_, outputs):
                              // FIXME
                              <to-tuple; instantiate-lookup(|pattern', term');
                               (lookup(|s) < \ o -> (Some(o), <zip; map(makeCEq(|""))> (o, outputs))\ +
                                             \ (_, o, _) -> (None(), [CFail__(Error([o, " not found in context"]))])\)> call
                          case ?Eq__(a, b, error):
                              !(None(), [<instantiate-error(|pattern', term')>
                                        CEq__(<instantiate(|pattern', term')> [a],
                                              <instantiate(|pattern', term')> [b],
                                              error) ])
                          case ?Neq__(a, b, error):
                              !(None(), [ <instantiate-error(|pattern', term')>
                                        CNeq__(<instantiate(|pattern', term')> [a],
                                               <instantiate(|pattern', term')> [b],
                                               error) ])
                          case ?Judgment__(num, inputs, ctx, _):
                            // FIMXE
                            // Instantiate the judgment that shall be called.
                            (judg-number, param, binding, outputs) := <to-tuple; instantiate-judgment(|pattern', term')> call;

                            // Create constraints for the variables in the context bindings.
                            binding-constraints := <make-binding-constraints(|name)> (<to-tuple; Third> call, binding);

                            // Call generate for the instantiated judgment and the updated store.
                            <generate(|t, <update-store(|s)> binding, outputs)> (judg-number, param);

                            // Pass the outputs untouched and add the binding constraints to
                            // the resulting constraints.
                            (id, conc(|binding-constraints));
                            try(\(Some(o), cs) -> (Some(o), <conc(|binding-constraints); conc(|<zip;map(makeCEq(|""))> (o, outputs))> cs)\)
                            otherwise:
                                exit-with-error(|"Encountered a maleformed template", 1)
                          end;
                          singelton; conc(|accu), // Book keeping.
                          destroy-store(|s))>
    /**
     * Extracts the patterns out of the dependencies and appends those
     * to the pattern of the conclusion.
     * Extracts the already computed outputs and constraints and unify those
     * that are listed in the given dependencies.
     *
     * @param pattern - the pattern of the conclusion
     * @param term - an arbitary term
     * @param accu - the accumulator of `execute'
     * @type dependencies -> List(pattern) 
     */                      
    update(|pattern, term, accu) = filter(Dupl;(Fst; \i -> <index(|i)> accu\;
                                           \(Some(o), cs) -> <unify-internal; apply-mgu(|o)> cs\,
                                           Snd)); unzip; (conc(|term), conc(|pattern))

    /**
     * Initialized the given store with the context bindings.
     *
     * @param store - a store
     * @type List(term) -> store
     */
    initialize-store(|store, context-definitions) =
                               filter(node-is-ctx-bind);
                               mapconcat(ctx-bind-to-kv-list(|context-definitions));
                               update-store(|store)


    /**
     * Cleans up everything that was needed during the constraint
     * generation. This includes:
     *
     *     - destroying the store
     *
     * @param store - a hashtable containing hashtables
     */
    tidy-up(|store) = destroy-store(|store)
