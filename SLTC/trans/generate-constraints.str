module generate-constraints

imports utils
imports constraint-language
imports constraint-template-language
imports constraint-solving
imports constraint-utils
imports optimize-constraint-templates
imports generate-constraint-generator
imports store-utils
imports include/SLTC

signature
    sorts Constraint
    constructors
        ConstraintSet : List(Constraint)

rules
    generate-constraints :
        Module(ModuleDec(_),
                 imports,
                 Language(l),
                 MetaVariables(meta-variables),
                 Contexts(context-definitions),
                 Judgments(judgments),
                 Rules(typing-rules),
                 Some(Conjectures(conjectures)))
        -> <map(\TypingRule(_, conjecture) ->
                 // FIXME: Refactor/rewrite this initialization
                 (<get-inputs(|judgments);
                  \i -> <remove-all(node-is-ctx(|context-classes));
                         generate(|judgments, context-definitions, templates,
                                   <initialize-store(|store, context-definitions, context-classes)> i)> i
                  \;
                  \(outputs, constraints) ->
                    (outputs, <conc> (<zip; map(makeEq(|Some("[Conjecture]")))> (outputs, <get-outputs(|judgments)> conjecture), constraints))
                  \> conjecture, <get-outputs(|judgments)> conjecture)
                \; clear-store(|store)); tidy-up(|store)> conjectures
        where
            // Retrieve all context names
            context-names := <map(proj(ContextDefinition|1))> context-definitions;

            // Obtain a list of meta-variable names, that represent contexts and contexts only
            context-classes := <filter(\MetaVariableDefinition(name, _, Scope(scope)) ->
                                       <isect; not(equal(|[])); !name> (context-names, scope)
                                       \)> meta-variables;

            // Generate the constraint templates from the type system specification
            templates := <to-constraint-generator(|judgments, context-definitions, context-classes);
                          solve-which-ambiguities> typing-rules;
            
            // Initialize the store that contains the contexts
            empty-contexts := <map-with-index((id, !([], <new-hashtable>)))> context-definitions;
            store := <new-hashtable(|<length; inc> context-definitions, 100);
                             hashtable-putlist(|empty-contexts)>

    /**
     * Generates the set of constraints.
     *
     * @param judgments - judgment declarations
     * @param contexts - context declarations
     * @param templates - constraint templates
     * @param store - list of hashtables that store context information
     */
    generate(|judgments, contexts, templates, store) : inputs ->
             <generate'(|judgments, contexts, templates, inputs, store)> match
        where
            // Find the constraint template that matches the inputs of the given term
            // FIXME: Better error messages if no match is found.
            match := <find-match(|inputs, store)> templates

    /**
     * Helper rule for constraint generation. It pattern matches against the matching
     * template found in `generate` and does the actual constraint generation.
     *
     * @param j - judgment declarations
     * @param c - context declarations
     * @param t - constraint templates
     * @param term - input terms
     * @param s - hashtable containing hashtables that store context information
     */
    generate'(|j, c, t, term, s) : Rule(name, (pattern, _), outputs, constraints) ->
            (outputs, <conc> (iconstraints, <make-io-dependency-constraints(|pattern, term, name)> outputs,
                              <make-implicit-equality-constraints(|pattern, term, name)> pattern))
        where
            iconstraints := <map(instantiate-error(|pattern, term))> constraints

    generate'(|j, c, t, term, s) : Binding(xs, calls, Rule(name, (pattern, ctx), outputs, constraints)) ->
           (outputs', new-constraints)
        where
            ctx' := <map(\(ctx, i, _) -> <pop(|s)> ctx \)> ctx;

            pattern' := <conc> (pattern, <map(\(_, i, o) -> (i, o)\)> ctx);
            term' := <conc> (term, ctx');

            // Execute the calls of the rule.
            outputs-constraints := <foldl(execute(|j, c, t, <hashtable-deep-copy> s, pattern', term', name))> (calls, []);

            // Make constraints for input-output dependencies in the conclusion of the rule.
            input-output-constraints := <make-io-dependency-constraints(|pattern', term', name)> outputs;

            // Make implicit equalities
            implicit-equalities := <make-implicit-equality-constraints(|pattern', term', name)> pattern;

            // The constraint set with instantiated errors.
            iconstraints := <map(instantiate-error(|pattern', term'))> constraints;

            // Use fresh variable names to instantiate the rule.
            // FIXME: Is there a better solution, than renaming?
            vars := <collect-om(\Var__(v) -> <(string-starts-with(|"X"); !Var__(v))> v \)> (xs, outputs, constraints, outputs-constraints, input-output-constraints);
            (xs', outputs', constraints', outputs-constraints', io-constraints', implicit-equalities') := <zip; replace-all(|(xs, outputs, iconstraints, outputs-constraints, input-output-constraints, implicit-equalities))>
                                                                    (vars, <length; newnames(|"Y"); map(makeVar)> vars);

            // Assoziate the outputs of the calls with the variables of the binding.
            xs-outputs := <zip; mapconcat(zip)> (xs', <map(Fst)> outputs-constraints');

            // Replace all previously bound variables with their values in the constraint set.
            constraints'' := <replace-all(|constraints')> xs-outputs;

            // Merge all generated constraints.
            new-constraints := <conc> ( constraints'', <mapconcat(Snd)> outputs-constraints', io-constraints', implicit-equalities')

    generate'(|j, c, t, term, s) : Fork(rulez) -> (<until(generate'(|j, c, t, term, <hashtable-deep-copy> s);
                                                          \(o, cs) ->
                                                             <unify-internal; apply-mgu(|o)> cs
                                                          \)> rulez,
                                                   [])

    /**
     * Executes the calls specified in the rules.
     *
     * @param j - judgment declarations
     * @param c - context declarations
     * @param t - constraint templates
     * @param s - hashtable containing hashtables that store context information
     * @param pattern - the pattern of the conclusion
     * @param term - input terms
     * @param name - the name of the rule
     * @type ((call, dependencies), accumulator) -> (outputs, constraints)
     */
    execute(|j, c, t, s, pattern, term, name) : ((call, dep), accu) ->
                         <pattern' := <update-pattern(|pattern)> dep;
                          term' := <update-term(|term, accu)> dep;
                          switch !call
                          case ?Lookup(_,_):
                              <to-tuple; instantiate-lookup(|pattern', term'); lookup(|s); \ o -> (o, [])\> call
                          case ?CEq__(a, b, info):
                              !([], [<instantiate-error(|pattern', term')>
                                        CEq__(<instantiate(|pattern', term')> [a],
                                              <instantiate(|pattern', term')> [b],
                                              info) ])
                          case ?CNeq__(a, b, info):
                              !([], [ <instantiate-error(|pattern', term')>
                                        CNeq__(<instantiate(|pattern', term')> [a],
                                               <instantiate(|pattern', term')> [b],
                                               info) ])
                          otherwise:
                            (param, binding) := <to-tuple; instantiate-judgment(|pattern', term')> call;
                            binding-constraints := <make-binding-constraints(|name)> (<to-tuple; Snd> call, binding);
                            <generate(|j, c, t, <update-store(|s)> binding)> param;
                            (id, conc(|binding-constraints))
                          end; singelton; conc(|accu); destroy-store(|s)>

    /**
     * Extracts the patterns out of the dependencies and appends those
     * to the pattern of the conclusion.
     *
     * @param pattern - the pattern of the conclusion
     * @type dependencies -> List(pattern) 
     */
    update-pattern(|pattern) = map(Snd); conc(|pattern)

    /**
     * Extracts the already computed outputs and constraints and unify those
     * that are listed in the given dependencies.
     *
     * @param term - an arbitary term
     * @param accu - the accumulator of `execute'
     * @type dependencies -> a
     */
    update-term(|term, accu) = map(Fst; \i -> <index(|i)> accu\;
                                   \(o, cs) -> <unify-internal; apply-mgu(|o)> cs\); conc(|term)

    /**
     * Initialized the given store with the context bindings.
     *
     * @param store - a store
     * @type List(term) -> store
     */
    initialize-store(|store, context-definitions, context-classes) =
                               filter(node-is-ctx-bind);
                               mapconcat(ctx-bind-to-kv-list(|context-definitions, context-classes));
                               update-store(|store)


    /**
     * Cleans up everything that was needed during the constraint
     * generation. This includes:
     *
     *     - destroying the store
     *
     * @param store - a hashtable containing hashtables
     */
    tidy-up(|store) = destroy-store(|store)