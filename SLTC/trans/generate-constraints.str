module generate-constraints

imports utils
imports constraint-language
imports generate-constraint-generator
imports include/SLTC

signature
    sorts Constraint
    constructors
                
        ConstraintSet : List(Constraint)
        
        
rules
    generate-constraints : 
        Module(ModuleDec(_),
                 imports,
                 Language(l),
                 MetaVariables(meta-variables),
                 Contexts(context-definitions),
                 Judgments(judgments),
                 Rules(typing-rules),
                 Some(Conjectures(conjectures)))
        -> <map(\TypingRule(_, conjecture) ->
                 <get-inputs(|judgments); remove-all(node-is-ctx(|context-classes));
                  generate(|judgments, context-definitions, templates, store)> conjecture
                \)> conjectures
        where
            context-names := <map(proj(ContextDefinition|1))> context-definitions;
            context-classes := <filter(\MetaVariableDefinition(name, _, Scope(scope)) ->
                                       <isect; not(equal(|[])); !name> (context-names, scope)\)>
                                       meta-variables;
            templates := <to-constraint-generator(|judgments, typing-rules, context-classes)>;
            empty-contexts := <length; range; fanout; (id, map(new-hashtable)); zip> context-definitions;
            // FIXME: Set correct initial size
            store := <new-hashtable; hashtable-putlist(|empty-contexts)>

    generate(|judgments, contexts, templates, store) : inputs ->
             <generate'(|judgments, contexts, templates, inputs, store)> match
        where
             match := <find-match(|inputs)> templates
             
    generate'(|j, c, t, i, s) : Rule(pattern, outputs , constraints) -> (outputs, constraints)
    generate'(|j, c, t, i, s) : Binding(xs, calls, Rule(pattern, outputs, constraints)) ->
            (outputs', <conc> (<mapconcat(Snd)> outputs-constraints', constraints''))
        where
            positions := <map((find-matching-positions(|pattern), id))> calls;
            input-terms := <map((extract-terms(|i), id))> positions;
            outputs-constraints := <map(debug; \(term, b) -> <generate(|j, c, t, <update-store(|s, c)> b)> term\)> input-terms;
            // FIXME: Is there a better solution, than renaming?
            vars := <collect-om(?Var__(_))> (xs, constraints);
            (xs', outputs', constraints', outputs-constraints') := <zip; replace-all(|(xs, outputs, constraints, outputs-constraints))> 
                                                                    (vars, <length; newnames(|"Y"); map(makeVar)> vars);
            xs-outputs := <zip; mapconcat(zip)> (xs', <map(Fst)> outputs-constraints');
            constraints'' := <replace-all(|constraints')> xs-outputs

    extract-terms(|inputs) = map(fetch(|inputs))
    find-matching-positions(|c-pattern) = map(get-position(|c-pattern); reverse)
    get-position(|pattern) : x -> <get-index < singelton + search> (x, pattern)

    // FIXME: What if x is not entirely containted in pattern?
    search : (x, pattern) -> <search'> (x, [1], pattern)
    search' : (x, is, []) -> <fail>
    search' : (x, [i|is], [v@c#([]) | pattern]) -> <if <equal> (x, v)
                                                    then <id> [i|is]
                                                    else <search'> (x, <add; singelton> (i, 1), pattern)
                                                    end>
    search' : (x, is, [c#(args) | pattern]) -> <get-index < \ i -> [i|is] \ + <search'> (x, [1|is], <conc> (args, pattern)) > (x, args)

    // FIXME overwrites a library function
    fetch(|node) : [p] -> <index> (p, <get-arguments> node)
    fetch(|node) : [p|path] -> <index; \ node -> <fetch(|node)> path\> (p, <get-arguments> node)

    // FIXME: What if multiple rules match?    
    find-match(|inputs) : [] -> <singelton; error> "No match found!"
    find-match(|inputs) : [t|ts] -> <if equal(|<length> inputs, <get-pattern; length> t)
                                     then if <zip; fanout; (filter(match-constructors); length,
                                                            length);equal> (inputs, <get-pattern> t)
                                           then <id> t
                                           else <find-match(|inputs)> ts
                                           end
                                     else <find-match(|inputs)> ts
                                     end>

    match-constructors : (t, s) -> < equal(|t-cons, s-cons) <+
                                     <is-meta-variable> s-cons>
        where
            s-cons := <get-constructor> s;
            t-cons := <get-constructor> t

    // FIXME: Implement
    update-store(|s, c) : ctx-binds -> <foldl(\(b, s') -> <update-store'(|s', c)> b\)> (ctx-binds, s)
    update-store'(|s, c) : ctx-bind -> <fail>
        where
            <node-is-ctx-bind> ctx-bind;
            ctx := <get-generic-name; string-to-int; \ i -> <hashtable-get(|i)> s \> ctx-bind

    ctx-bind-to-kv-list(|c) : node -> []
        where <node-is-ctx-empty> node
    ctx-bind-to-kv-list(|c) : node -> [(inputs, outputs) | <ctx-bind-to-kv-list(|c)> tail]
        where <node-is-ctx-bind> node;
              inputs := <get-inputs(|c)> node;
              outputs := <get-outputs(|c)> node;
              tail := <get-arguments; last> node