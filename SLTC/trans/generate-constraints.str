module generate-constraints

imports utils
imports constraint-language
imports constraint-template-language
imports constraint-solving
imports constraint-utils
imports optimize-constraint-templates
imports generate-constraint-generator
imports store-utils
imports include/SLTC

rules
    generate-constraints :
        Module(ModuleDec(_),
                 imports,
                 Language(l),
                 MetaVariables(meta-variables),
                 Contexts(context-definitions),
                 Judgments(judgments),
                 Rules(typing-rules),
                 Some(Conjectures(conjectures)))
        -> <finally(
              map(finally(
                 \TypingRule(PremiseBase(), _, conjecture) ->
                    // Prepare the input and initialize the store.
                    <prepare-generation(|judgments, context-definitions, context-classes, store);
                    \input ->
                        // Generate the constraints.
                        <generate(|judgments, context-definitions, templates, store)> (<get-generic-name; string-to-int> conjecture, input)
                    \;
                    // Append a constraint for the ouputs in the conjecture.
                    try(\(Some(outputs), constraints) ->
                      (outputs, <conc(|constraints)> <zip; map(\(a, b) -> <makeCEq(|Some(Error(["Type", a, "does not match annotated type", b])))> (a, b)\)> (outputs, <get-outputs(|judgments)> conjecture))
                    \)> conjecture
                 \, clear-store(|store))),
            tidy-up(|store))> conjectures
        where
            // Retrieve all context names
            context-names := <map(proj(ContextDefinition|1))> context-definitions;

            // Obtain a list of meta-variable names, that represent contexts and contexts only
            context-classes := <filter(\MetaVariableDefinition(name, _, Scope(scope)) ->
                                       <isect; not(equal(|[])); !name> (context-names, scope)
                                       \)> meta-variables;

            // Generate the constraint templates from the type system specification
            templates := <to-constraint-generator(|judgments, context-definitions, context-classes);
                          optimize-templates(|context-definitions)> typing-rules;
            
            // Initialize the store that contains the contexts
            empty-contexts := <map-with-index((id, !([], <new-hashtable>)))> context-definitions;
            store := <new-hashtable(|<length; inc> context-definitions, 100);
                             hashtable-putlist(|empty-contexts)>

    /**
     * Pepares the inputs for the constraint generation and initializes the store.
     */
    prepare-generation(|judgments, context-definitions, context-classes, store) =
        get-inputs(|judgments); where(initialize-store(|store, context-definitions, context-classes));
        remove-all(node-is-ctx(|context-classes))
    /**
     * Generates the set of constraints.
     *
     * @param judgments - judgment declarations
     * @param contexts - context declarations
     * @param templates - constraint templates
     * @param store - list of hashtables that store context information
     */
    generate(|judgments, contexts, templates, store) : (judg-number, inputs) ->
             // Find the constraint template that matches the inputs of the given term
             // if a matching rule could be found evaluate that, otherwise return an error.
             <find-match(|inputs, judg-number, store) < generate'(|judgments, contexts, templates, inputs, store)
                                         + !(None(), [CFail__(Error(["No rule found that matches", inputs]))])> templates

    /**
     * Helper rule for constraint generation. It pattern matches against the matching
     * template found in `generate` and does the actual constraint generation.
     *
     * @param j - judgment declarations
     * @param c - context declarations
     * @param t - constraint templates
     * @param term - input terms
     * @param s - hashtable containing hashtables that store context information
     */
    generate'(|j, c, t, term, s) : Binding__(xs, calls, Conjecture__(judg-name, name, (pattern, ctx), outputs, constraints)) ->
           (Some(outputs'), new-constraints)
        where
            // Retrieve and remove elements from the context according to the context pattern.
            ctx' := <filter(\(ctx, i, _) -> <pop(|s)> ctx \ <+
                            where(\Reset__(ctx) -> <clear-context(|s, ctx)> \); skip)> ctx;

            // Append the context pattern to the input pattern.
            pattern'' := <conc> (pattern, <filter(\(_, i, o) -> (i, o)\)> ctx);

            // Append the instantiated context pattern to the input term.
            term'' := <conc> (term, ctx');

            // Use fresh variable names to instantiate the rule.
            // FIXME: Is there a better solution, than renaming?
            vars := <collect-om(\Var__(v) -> <(string-starts-with(|"X"); !Var__(v))> v\)> (xs, pattern'', term'', calls, constraints);
            (xs', pattern', term', calls', constraints', outputs') := <zip; replace-all(|(xs , pattern'', term'', calls, constraints, outputs))> (vars, <length; newnames(|"Y"); map(makeVar)> vars);

            // Execute the calls of the rule.
            outputs-constraints := <foldl(execute(|j, c, t, <hashtable-deep-copy> s, pattern', term', name))> (calls', []);

            // Make constraints for input-output dependencies in the conclusion of the rule.
            input-output-constraints := <make-io-dependency-constraints(|pattern', term', name)> outputs';

            // Instantiate the variables in the error messages.
            iconstraints := <map(instantiate-error(|pattern', term'))> constraints';

            // Associate the outputs of the calls with the variables of the binding.
            xs-outputs := <zip; filter(\(xs, Some(s)) -> (xs, s)\); mapconcat(zip)> (xs', <map(Fst)> outputs-constraints);

            // Replace all previously bound variables with their values in the constraint set.
            constraints'' := <replace-all(|iconstraints)> xs-outputs;

            // Merge all generated constraints.
            new-constraints := <conc> (constraints'', <mapconcat(Snd)> outputs-constraints,
                                       input-output-constraints)

    generate'(|j, c, t, term, s) : Fork__(rulez) ->
           // Apply all rules until the first one produces a solvable constraint set
           // apply the resulting mgu and return the term as an output. The constraint
           // set is empty, because all produced constraints are already solved.
           (<until(generate'(|j, c, t, term, <hashtable-deep-copy> s);
                   \(Some(o), cs) -> <unify-internal; apply-mgu(|o)> cs\) < \x -> Some(x)\ + !None()> rulez,
           [])

    /**
     * Executes the calls specified in the rules.
     *
     * @param j - judgment declarations
     * @param c - context declarations
     * @param t - constraint templates
     * @param s - hashtable containing hashtables that store context information
     * @param pattern - the pattern of the conclusion
     * @param term - input terms
     * @param name - the name of the rule
     * @type ((call, dependencies), accumulator) -> (outputs, constraints)
     */
    execute(|j, c, t, s, pattern, term, name) : ((call, dep), accu) ->
                          // Update the pattern and the term according to
                          // the dependencies.
                <finally((term', pattern') := <update(|pattern, term, accu)> dep;
                          switch !call
                          case ?Lookup__(_,_):
                              <to-tuple; instantiate-lookup(|pattern', term');
                               (lookup(|s) < \ o -> (Some(o), [])\ +
                                             \ (_, o) -> (None(), [CFail__(Error([o, " not found in context"]))])\)> call
                          case ?Eq__(a, b, info):
                              !(Some([]), [<instantiate-error(|pattern', term')>
                                        CEq__(<instantiate(|pattern', term')> [a],
                                              <instantiate(|pattern', term')> [b],
                                              info) ])
                          case ?Neq__(a, b, info):
                              !(Some([]), [ <instantiate-error(|pattern', term')>
                                        CNeq__(<instantiate(|pattern', term')> [a],
                                               <instantiate(|pattern', term')> [b],
                                               info) ])
                          otherwise:
                            // Instantiate the judgment that shall be called.
                            (judg-number, param, binding) := <to-tuple; instantiate-judgment(|pattern', term')> call;

                            // Create constraints for the variables in the context bindings.
                            binding-constraints := <make-binding-constraints(|name)> (<to-tuple; Third> call, binding);

                            // Call generate for the instantiated judgment and the updated store.
                            <generate(|j, c, t, <update-store(|s)> binding)> (judg-number, param);

                            // Pass the outputs untouched and add the binding constraints to
                            // the resulting constraints.
                            (id, conc(|binding-constraints))
                          end;
                          singelton; conc(|accu), // Book keeping.
                          destroy-store(|s))>
    /**
     * Extracts the patterns out of the dependencies and appends those
     * to the pattern of the conclusion.
     * Extracts the already computed outputs and constraints and unify those
     * that are listed in the given dependencies.
     *
     * @param pattern - the pattern of the conclusion
     * @param term - an arbitary term
     * @param accu - the accumulator of `execute'
     * @type dependencies -> List(pattern) 
     */                      
    update(|pattern, term, accu) = filter(Dupl;(Fst; \i -> <index(|i)> accu\;
                                           \(Some(o), cs) -> <unify-internal; apply-mgu(|o)> cs\,
                                           Snd)); unzip; (conc(|term), conc(|pattern))

    /**
     * Initialized the given store with the context bindings.
     *
     * @param store - a store
     * @type List(term) -> store
     */
    initialize-store(|store, context-definitions, context-classes) =
                               filter(node-is-ctx-bind);
                               mapconcat(ctx-bind-to-kv-list(|context-definitions, context-classes));
                               update-store(|store)


    /**
     * Cleans up everything that was needed during the constraint
     * generation. This includes:
     *
     *     - destroying the store
     *
     * @param store - a hashtable containing hashtables
     */
    tidy-up(|store) = destroy-store(|store)
