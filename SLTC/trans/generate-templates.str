module generate-templates

imports constraint-language
imports constraint-template-language
imports template-utils
imports sdf-utils
imports utils

imports org/sugarj/languages/Sdf2
imports include/SLTC
imports lib/editor-common.generated

imports optimize-constraint-templates
       
rules
    
    wrapped-generate-templates = io-wrap(generate-templates)

    generate-templates :
        Module(ModuleDec(_),
               imports,
               Language(target-language),
               Contexts(context-definitions),
               MetaVariables(meta-variables),
               Judgments(judgments),
               Rules(typing-rules),
               conjectures)
        -> <to-templates(|judgments, context-definitions, target-language);
            optimize-templates(|judgments, target-language, context-definitions)> typing-rules

    /**
     * Rule that transforms a typing rule into a constraint template.
     *
     * @param j - judgment declarations
     * @param c - context declarartions
     */
    to-template(|j, c, l) : TypingRule(premisses-struct, RuleName(_, name), conclusion) ->
        <{|Fresh: replace-meta-variables|}>
          Template__(name,
                     <map(switch (get-typing-judgment, id)
                         case (node-is-ctx-lookup, id):
                              \(lookup, deps) ->
                                (Lookup__(<get-typing-judgment; get-context-id> lookup,
                                          <get-typing-judgment; get-inputs(|c)> lookup,
                                          <get-typing-judgment; get-outputs(|c)> lookup,
                                          <get-error-message> lookup)
                                 , <map(Dupl; (id, \i -> <index(|i)> sorted-premisses\; Fst; get-typing-judgment; get-outputs(|j)))> deps)\
                         case where((get-generic-name; equal(|"Eq"), id)):
                              \(j, dep) -> (<get-typing-judgment; to-tuple; makeEq(|<get-error-message; option(filter(?Error(_)))> j)> j, dep) \
                         case where((get-generic-name; equal(|"Neq"), id)):
                              \(j, dep) -> (<get-typing-judgment; to-tuple; makeNeq(|<get-error-message> j)> j, dep) \
                         otherwise:
                              \(judgment, deps) ->
                                 (Judgment__(<get-typing-judgment; get-judgment-id> judgment,
                                            <get-typing-judgment; get-inputs(|j); filter(not(node-is-ctx))> judgment,
                                            <get-typing-judgment; get-inputs(|j); filter(node-is-ctx); mapconcat(ctx-bind-to-kv-list(|c))> judgment,
                                            <get-typing-judgment; get-outputs(|j)> judgment,
                                            <get-error-message> judgment)
                                 , <map(Dupl; (id, \i -> <index(|i)> sorted-premisses\; Fst; get-typing-judgment; get-outputs(|j)))> deps) \
                         end)> sorted-premisses,
                     Conclusion__(
                         <get-typing-judgment; get-judgment-id> conclusion,
                         <get-typing-judgment; get-inputs(|j); partition(not(node-is-ctx), node-is-ctx);
                         (id, mapconcat(ctx-bind-to-kv-list(|c)))> conclusion',
                         <get-typing-judgment; get-outputs(|j)> conclusion'))
        where
            // Convert premisses into a list.
            premisses-list := <to-list(PremiseBase, PremiseCons)> premisses-struct;

            judgment-types := <get-judgment-types(!"I" | <get-typing-judgment; get-judgment-id> conclusion)> j;

            // Transform implicit equalities in the conclusion into explicit equalities. Implicit
            // equalities are removed by introducing fresh variables and equality constraints
            // between them. This results in a list of variable substitutions and a list of premisses.
            (substitutions, (equalities, judgment-definitions)) :=
                    <get-typing-judgment; get-inputs(|j);
                     make-implicit-equalities-explicit(true | <get-error-message> conclusion, conclusion, judgment-types, l)> conclusion;

            // Replace each occurence with the corresponding new meta-variable.
            conclusion' := <concat; replace-once(|conclusion)> substitutions;

            // Replace every occurence with only one representative of the new meta-variables.
            premisses-list' := <map(Hd); replace-all(meta-variable-equal|premisses-list)> substitutions;

            // Transform implicit equalities in the premisses into explicit equalities.
            premisses-impl-eq := <map(\premise -> <get-typing-judgment; (node-is-ctx-lookup < get-inputs(|c) + get-inputs(|j));
                                      make-implicit-equalities-explicit(false | <get-error-message> premise, conclusion', [], l)> premise\)> premisses-list';

            // Replace every occurence with only one representative of the new meta-variables.
            premisses-list'' := <zip; map(\(premise, subst) -> <concat; replace-once(|premise)> subst\)> (premisses-list', <map(Fst)> premisses-impl-eq);

            // Add the explicit equalities to the list of premisses.
            premisses-with-equalities := <conc> (premisses-list'', equalities, <mapconcat(Snd; Fst)> premisses-impl-eq);
            
            number-of-judgments := <length> j;
            
            new-judgment-defs := <conc> (judgment-definitions, <mapconcat(Snd; Snd)> premisses-impl-eq);
            
            new-judgment-defs' := <map-with-index(\(i, d) -> <replace(|d)> (<conc-strings> ("J", <int-to-string> i), <add; int-to-string> (i, number-of-judgments))\)> new-judgment-defs;
            
            // Add new judgment definitions for the implicit equaltities
            j' := <conc> (j, judgment-definitions, new-judgment-defs');

            // Enumerate the premisses.
            enum-premisses := <add-indices> premisses-with-equalities;

            // Compute the dependencies between the premisses.
            dependencies := <map((id, get-typing-judgment; (node-is-ctx-lookup < get-inputs(|c) + get-inputs(|j)));
                                 (id, compute-dependencies(|enum-premisses, conclusion', j, c)))> enum-premisses;

            // Create a topological order of the premisses according to their dependencies.
            eval-order := <zip> (<map(Fst)> enum-premisses, <top-sort <+ exit-with-error(|<conc-strings> ("Cyclic dependencies in rule ", <option-to-string> name), 1)> dependencies);
            
            // Assign the dependencies to the premisses.
            premisses := <zip> (premisses-with-equalities, <map(Snd)> dependencies);
            
            // Sort the premisses according to the topological order. This includes updating references
            // to premisses in the dependencies.
            sorted-premisses := <map(\ (i, k) -> <index(|k); (id, replace(|i, k))> premisses\)> eval-order

    /**
     * Replaces all meta-variables with fresh variables of the constraint language.
     * This way the unification has to deal only with one kind of variables.
     */
    replace-meta-variables : ast -> <collect-om(node-is-meta-variable); Dupl;
                                     (id, length; newnames(|"X"); map(makeVar));
                                     zip; replace-all(|ast)> ast

    /**
     * Transforms context bindings as they occur in the specification language into
     * a key-value list. This list contains triples with the context identifier, the inputs
     * and the outputs.
     *
     * @param c - context declarartions
     */
    ctx-bind-to-kv-list(|c) : node -> [Ctx__(ctx)]
        where <node-is-ctx-var> node;
              ctx := <get-context-id> node
    ctx-bind-to-kv-list(|c) : node -> [Reset__(ctx)]
        where <node-is-ctx-empty> node;
              ctx := <get-context-id> node
    ctx-bind-to-kv-list(|c) : node -> [Binding__(ctx, inputs, outputs) | <ctx-bind-to-kv-list(|c)> tail]
        where <node-is-ctx-bind> node;
              ctx := <get-context-id> node;
              inputs := <get-inputs(|c)> node;
              outputs := <get-outputs(|c)> node;
              tail := <get-arguments; last> node
              
    /**
     * Returns the subset of the passed judgments that contain
     * at least one of the `inputs`.
     *
     * @param terms - judgments
     * @param decls - judgment declarations
     */
    compute-dependencies(|terms, conclusion, judgments, contexts) : inputs ->
        <filter(where(Snd; get-typing-judgment; (node-is-ctx-lookup < get-outputs(|contexts) + get-outputs(|judgments));
                \ os -> <foldl(\ (i, l) -> <collect-om(?i); conc(|l)> os
                               \)> (input-meta-variables, [])
                \; diff(|conclusion-meta-variables); not(equal([]))); Fst)> terms
        where input-meta-variables := <collect-om(node-is-meta-variable)> inputs;
              conclusion-meta-variables := <get-typing-judgment; get-inputs(|judgments); collect-om(node-is-meta-variable)> conclusion

    /**
     * Generates from implicit equalities equality premisses.
     */
    make-implicit-equalities-explicit(is-conclusion | errors, conclusion, types, l) =
        ?inputs; <zip> (inputs, types);
        mapconcat(where(Snd; resolvable(is-conclusion | conclusion))
                  < singelton 
                  + Snd; collect-meta-variables(is-conclusion | conclusion, l));
        group(Snd; meta-variable-equal); filter(where(length; gt(|1)));
        Dupl; (id, map(map(make-new-meta-variable))); zip;
        Dupl; (map((map(Fst), id); zip), mapconcat(make-eq-judgments(|errors)); partition(Fst, Snd))
        
    collect-meta-variables(is-conclusion | conclusion, language) : cons#([]) -> []
    collect-meta-variables(is-conclusion | conclusion, language) : cons#(args) ->
        <conc> (vars-types, <collect-meta-variables(is-conclusion | conclusion, language)> nodes)
        where arg-count := <length> args;
              (vars, nodes) := <partition(resolvable(is-conclusion | conclusion),
                                          not(resolvable(is-conclusion | conclusion)))> args;
              productions := <get-productions-for-constructor(|language)> cons;
              productions' := <filter(to-tuple; Fst; filter(?sort(_)))> productions;
              matching-productions := <filter(where(length; equal(|arg-count)))>;
              transposed-matching-productions := <matrix-transpose> matching-productions;
              vars-types := <zip; map(where(Snd; length; equal(|1))
                                 < (id, Hd; ?sort(type); !type)
                                 + exit-with-error(|999, "not implemented"))> (vars, transposed-matching-productions)
              
        
    resolvable(is-conclusion | conclusion) =
        and(node-is-meta-variable, is-conclusion <+ \n -> <collect(?n); equal(|[])> conclusion\)

    /**
     * Creates a new meta-variable of the same class.
     */
    make-new-meta-variable : (meta-variable, type) -> <mkterm> (<get-constructor> meta-variable,
                                                                [<newname> "X", None()])

    /**
     * Creates from a given list of meta-variables a list of equality judgments.
     */
    make-eq-judgments(|errors) : ((old, type), new) -> <zip; make-eq-judgments'(|relevant-errors)> (new, type)
        where relevant-errors := <option(filter(where(\error ->
                                                        <subseteq> (<collect-om(node-is-meta-variable)> error,
                                                                  old)
                                                      \);
                                                \Implicit(error) ->
                                                  Error(<zip; replace-all(|error)> (old, new))
                                                \))> errors
    make-eq-judgments'(|errors) : [] -> []
    make-eq-judgments'(|errors) : [(x, type)] -> []
    make-eq-judgments'(|errors) : [(x, t), (y, s) | xs] ->
        [(eq-judgment, judgment-definition) | <make-eq-judgments'(|errors)> [y | xs]]
        where eq-judgment := ErrorTypingJudgment(<mkterm> (<conc-strings> ("Eq-", <make-fresh> "J"), [x, y]), errors);
              judgment-definition := Judgment(None(), [Hole(t, "I"), Hole(s, "I")], None(), Some(BuiltIn("Eq")))
    
strategies
    to-templates(|judgments, context-definitions, target-language) =
         innermost(to-template(|judgments, context-definitions, target-language))