module generate-fof

imports libstratego-lib
imports utils
imports include/SLTC

signature
	//FIXME: What is the advantage of defining the sorts explicitly
	sorts Prop Type FOF File
	constructors
		False : Prop
    	True  : Prop
    	Not   : Prop -> Prop
    	And   : Prop * Prop -> Prop
    	Or    : Prop * Prop -> Prop
    	Impl  : List(Prop) * Prop -> Prop
    	BiImpl : Prop * Prop -> Prop
    	Eq    : Prop * Prop -> Prop
    	Neq : Prop * Prop -> Prop
    	Var   : String -> Prop
    	Pred  : String * List(Prop) -> Prop
    	Term  : String * List(Prop) -> Prop 
    	All   : List(Var) * Prop -> Prop
	    Exists : List(Var) * Prop -> Prop
    	
    	Axiom : Type
    	Conjecture : Type
    	
    	Formula : String * Type * Prop -> FOF
	    Formula : String * Prop -> FOF
		FOFGoal : List(Formula) * List(Formula) * Formula -> File
		
		AuxCons : String * String * List(Prop) -> Prop
    	
 rules 	
 	//TODO: Generate a separate file for each test
	makeGoal : Module(ModuleDec(_),
			   Language(l),
			   MetaVariables(m),
			   Contexts(Contexts(ContextDefinitions)),
			   Judgments(j),
			   Rules(TypingRules),
			   Tests) -> FOFGoal(<map(makeContexts); flatten-list> ContextDefinitions,
			   <trans; map(\Formula(name, prop) -> Formula(name, Axiom(), prop)\)> TypingRules, True())
	          
    makeNeq : (x,y) -> Neq(x,y)
    makeVar : x -> Var(x)
    
    // FIXME: When using topdown we have MetaVariable-* instead of Var
    free-vars : v@Var(_) -> [<strip-annos> v]
    free-vars : All(vars, prop) -> <diff> (<free-vars> prop, <free-vars> vars)
    free-vars : Exists(vars, prop) -> <diff> (<free-vars> prop, <free-vars> vars)
    free-vars : cons#(xs) -> <map(free-vars);unions> xs
	
	// Generate context definitions
	makeContexts : ContextDefinition(Name, Consituents) -> [
	    Formula("lookup base", Axiom(), All([NAME|<conc>(inputs, outputs)],
	                                            Pred(lookup,
	                                            <conc> (inputs, [Pred(bind, [NAME|<conc> (inputs, outputs)])], outputs)))),
	    Formula("lookup step", Axiom(), All([NAME|<concat> [inputs, inputs2, outputs, outputs2]],
	                                            Impl(<map(makeNeq)><zip> (inputs, inputs2), 
	                                                 Pred(lookup, <conc>(inputs, [Pred(bind, [Name|<conc> (inputs, outputs)])], outputs))
	                                            )
	    ))
	]
	   where
	       lookup := <conc-strings> ("lookup-", Name);
	       bind := <conc-strings> ("bind-", Name);
	       NAME := <upper-case;makeVar> Name;
	       indexedConsituents := <zip> (<newnames(|"X")><length> Consituents, Consituents);
	       inputs := <filter(?(_, Hole(_, "I")); fst; makeVar)> indexedConsituents;
	       outputs := <filter(?(_, Hole(_, "O")); fst; makeVar)> indexedConsituents;
	       inputs2 := <map(\ Var(s) -> Var(<conc-strings> (s, "_")) \)> inputs;
	       outputs2 := <map(\ Var(s) -> Var(<conc-strings> (s, "_")) \)> outputs
	       
    // Translate all generic construtors into an auxillary data structure
    makeAuxCons : Constructor#(Args) -> AuxCons(cons, name, Args)
        where
            [cons, name] := <string-tokenize(|['-'])> Constructor;
            <is-bin-op> cons
            is-bin-op = "ContextEmpty" <+ "ContextBind" <+ "ContextLookup" <+ "TypingJudgment" <+ "MetaVariable"
    
    makeMetaVariable : AuxCons("MetaVariable", scope, name) -> Var(<concat-strings; upper-case> name)
	
	// Contexts in typing rules
	makeContextEmpty : AuxCons("ContextEmpty", name, []) -> Pred(<concat-strings> ["empty-", name], [])
	makeContextBind : AuxCons("ContextBind", name, args) -> Pred(<concat-strings> ["bind-", name], args)
	makeContextLookup : AuxCons("ContextLookup", name, args) -> Pred(<concat-strings> ["lookup-", name], args)
	makeContext = makeContextEmpty <+ makeContextBind <+ makeContextLookup

	// Typing judgments
	makeTypingJudgment : AuxCons("TypingJudgment", name, args) -> Pred(<conc-strings>("tcheck-", name), args)
			
	// Typing rules
	makeTypingRule : TypingRule(RuleName(_, Name), Consequence) -> Formula(<option-to-string-newname(|"formula")> Name, All(<free-vars> Consequence, Consequence))
	makeTypingRule : TypingRule(Premises, RuleName(_, Name), Consequence) -> Formula(<option-to-string-newname(|"formula")> Name, All(free-vars-in-rule, Impl(Premises, Consequence)))
		with free-vars-in-rule := <union> (<free-vars> Premises, <free-vars> Consequence)
	
	// Wrap terms of the programming language into construtors
    // FIXME: Distinguishing between strings and constructors with zero arguments is hacky
	makeTerm : v@cons#([]) -> v
	   where <string-starts-with(|"\"")> cons
	   prop-construtor = "False" <+ "True" <+ "Axiom" <+ "Conjecture"
	makeTerm : cons#([]) -> Term(cons,[])
	   where <if [] then fail else id end> cons
    makeTerm : v@cons#(args) -> Term(<lower-case> cons, args)
      where <if [] then fail else id end> cons;
            <if prop-constructor then fail else id end> cons 
      prop-constructor = "All" <+ "Not" <+ "And" <+ "Or"   <+ "Impl" <+ "BiImpl" <+
                         "Eq"  <+ "Neq" <+ "Var" <+ "Pred" <+ "Term" <+ "All"    <+ "Exists"
    
	// TODO: Conjectures
	// T : Formula(N, _, P) -> Formula(N, Conjecture(), P)

strategies
	toFOF = makeGoal
	
	rewriteAuxCons = makeContext <+ makeTypingJudgment <+ makeMetaVariable
	trans = topdown(makeAuxCons < rewriteAuxCons + try(makeTypingRule <+ makeTerm))