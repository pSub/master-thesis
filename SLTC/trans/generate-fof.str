module generate-fof

imports libstratego-lib
imports utils
imports include/SLTC

signature
	//FIXME: What is the advantage of defining the sorts explicitly
	sorts Prop Type FOF File
	constructors
		False : Prop
    	True  : Prop
    	Not   : Prop -> Prop
    	And   : Prop * Prop -> Prop
    	Or    : Prop * Prop -> Prop
    	Impl  : List(Prop) * Prop -> Prop
    	BiImpl : Prop * Prop -> Prop
    	Eq    : Prop * Prop -> Prop
    	Neq : Prop * Prop -> Prop
    	Var   : String -> Prop
    	Pred  : String -> Prop
    	Pred  : String * List(Prop) -> Prop
    	Term  : String -> Prop
    	Term  : String * List(Prop) -> Prop 
    	All   : List(Var) * Prop -> Prop
	    Exists : List(Var) * Prop -> Prop
    	
    	Axiom : Type
    	Conjecture : Type
    	
    	Formula : String * Type * Prop -> FOF
	    Formula : String * Prop -> FOF
		FOFGoal : List(Formula) * List(Formula) * Formula -> File
		
		AuxCons : String * String * List(Prop) -> Prop
    	
 rules 	
	makeGoals : Module(ModuleDec(_),
			    imports,
			    Language(l),
			    MetaVariables(m),
			    Contexts(ContextDefinitions),
			    Judgments(j),
			    Rules(TypingRules),
			    Some(Conjectures(Goals))) -> <map(\goal -> FOFGoal(<concat> [context-formulas, helper],
			                                                       typing-rule-formulas,
			                                                       <makeGoal> goal)\)> Goals
        where
            context-formulas := <map(makeContexts); flatten-list> ContextDefinitions;
            typing-rule-formulas := <map(makeTypingRule)> TypingRules;
            helper := <collect-all(?Term(name, args));
                       nub;
            		   mapconcat(\Term(name, args) ->
            		   			 [<makeInjectivity> (name, <length> args),
            		   			  <makeUnivalence> (name, <length> args)] \)> typing-rule-formulas

    makeNeq : (x,y) -> Neq(x,y)
    makeEq : (x,y) -> Eq(x,y)
    makeVar : x -> Var(x)
    
    //TODO: Is the formulation important? What about using the contraposition?
    makeInjectivity : (name, n) -> Formula(<conc-strings> (name, "-injective"),
    									   Axiom(),
    									   Impl(<zip; map(makeNeq)> (Xs, Ys), Neq(Term(name, Xs), Term(name, Ys)))
    									   )
    	where Xs := <newnames(|"X")> n;
    		  Ys := <newnames(|"Y")> n
    makeUnivalence : (name, n) -> Formula(<conc-strings> (name, "-univalent"),
    									  Axiom(),
    									  Impl([Eq(Term(name, Xs), Var("Y")), Eq(Term(name, Xs), Var("Z"))],
    									       Eq(Var("Y"), Var("Z")))
    									 )
    	where Xs := <newnames(|"X")> n
    

    // Collect free variables
    free-vars : v@Var(_) -> [<strip-annos> v]
    free-vars : All(vars, prop) -> <diff> (<free-vars> prop, <free-vars> vars)
    free-vars : Exists(vars, prop) -> <diff> (<free-vars> prop, <free-vars> vars)
    free-vars : cons#(xs) -> <map(free-vars); unions> xs
	
	// Generate context definitions
	makeContexts : ContextDefinition(Name, Consituents) -> [
	    Formula("lookup base",
	            Axiom(),
	            All([NAME|<conc>(inputs, outputs)],
	                Pred(lookup, <conc> (inputs, outputs, [Pred(bind, <conc> (consituents, [NAME]))])))),
	    Formula("lookup step",
	            Axiom(),
	            All([NAME|<concat> [inputs, inputs2, outputs, outputs2]],
	                // FIXME: Having constaints for inequality of variables as premises breaks typechecking
	                Impl([Pred(lookup, <concat> [inputs, outputs, [NAME]])], //| <zip; map(makeNeq)> (inputs, inputs2)],
	                Pred(lookup, <conc>(inputs, outputs, [Pred(bind, <conc> (<map(append(|"_"))> consituents, [NAME]))])))))
	]
	   where
	       lookup := <conc-strings> ("lookup", Name);
	       bind := <conc-strings> ("bind", Name);
	       NAME := <upper-case; makeVar> Name;
	       indexedConsituents := <zip> (<newnames(|"X")><length> Consituents, Consituents);
	       consituents := <map(Fst; makeVar)> indexedConsituents;
	       inputs := <filter(?(_, Hole(_, "I")); Fst; makeVar)> indexedConsituents;
	       outputs := <filter(?(_, Hole(_, "O")); Fst; makeVar)> indexedConsituents;
	       inputs2 := <map(append(|"_"))> inputs;
	       outputs2 := <map(append(|"_"))> outputs
           append(|p) = \ Var(s) -> <conc-strings; makeVar> (s, p) \

	       
    // Translate all generic construtors into an auxillary data structure
    makeAuxCons : Constructor#(Args) -> AuxCons(cons, name, Args)
        where
            [cons, name] := <string-tokenize(|['-'])> Constructor;
            <is-generic> cons
            is-generic = "ContextEmpty" <+ "ContextBind" <+ "ContextLookup" <+ "TypingJudgment" <+ "MetaVariable"
    
    // Meta-variables
    makeMetaVariable : AuxCons("MetaVariable", scope, name) -> <concat-strings; upper-case; makeVar> name
	
	// Contexts in typing rules
	makeContextEmpty : AuxCons("ContextEmpty", name, []) -> Pred(<concat-strings> ["empty", name])
	makeContextBind : AuxCons("ContextBind", name, args) -> Pred(<concat-strings> ["bind", name], args)
	makeContextLookup : AuxCons("ContextLookup", name, args) -> Pred(<concat-strings> ["lookup", name], args)
	makeContext = makeContextEmpty <+ makeContextBind <+ makeContextLookup

	// Typing judgments
	makeTypingJudgment : AuxCons("TypingJudgment", "Neq", [arg1, arg2]) -> Neq(arg1, arg2)
	makeTypingJudgment : AuxCons("TypingJudgment", "Eq", [arg1, arg2]) -> Eq(arg1, arg2)
	makeTypingJudgment : AuxCons("TypingJudgment", name, args) -> Pred(<conc-strings>("'tcheck", name, "'"), args)
			
	// Typing rules
	makeTypingRule : TypingRule(RuleName(_, Name), consequence) -> Formula(<option-to-string-newname(|"formula")> Name, Axiom(), prop)
	   with consequence' := <trans> consequence;
	        free-vars-in-rule := <free-vars> consequence';
	        prop := <if [] then <id> consequence' else <id> All(free-vars-in-rule, consequence') end> free-vars-in-rule
	        
	makeTypingRule : TypingRule(PremiseList(premises), RuleName(_, Name), consequence) -> Formula(<option-to-string-newname(|"formula")> Name, Axiom(), prop)
	   with consequence' := <trans> consequence;
            premises' := <to-list(PremiseBase, PremiseCons); trans> premises;
	        free-vars-in-rule := <union> (<free-vars> premises', <free-vars> consequence');
	        implication := Impl(premises', consequence');
	        prop := <if [] then <id> implication else <id> All(free-vars-in-rule, implication) end> free-vars-in-rule
	        
	// Conjectures
	makeGoal : TypingRule(RuleName(_, Name), consequence) -> Formula(<option-to-string-newname(|"goal")> Name, Conjecture(), consequence')
       with consequence' := <trans> consequence            
    makeGoal : TypingRule(PremiseList(premises), RuleName(_, Name), consequence) -> Formula(<option-to-string-newname(|"goal")> Name, Conjecture(), implication)
       with consequence' := <trans> consequence;
            premises' := <to-list(PremiseBase, PremiseCons); trans> premises;
            implication := Impl(premises', consequence')
            
	// Wrap terms of the programming language into construtors
    // FIXME: Distinguishing between strings and constructors with zero arguments is hacky
	makeTerm : v@cons#([]) -> v
	   where <string-starts-with(|"\"")> cons;
	         <not(prop-constructor)> cons
	   prop-construtor = "False" <+ "True"
	makeTerm : cons#([]) -> Term(<lower-case> cons)
	   where <not([])> cons
    makeTerm : v@cons#(args) -> Term(<lower-case> cons, args)
       where <not([])> cons;
             <not(prop-constructor)> cons
       prop-constructor = "All" <+ "Not" <+ "And" <+ "Or"   <+ "Impl" <+ "BiImpl" <+
                         "Eq"  <+ "Neq" <+ "Var" <+ "Pred" <+ "Term" <+ "All"    <+ "Exists"

strategies
	toFOF = makeGoals
	
	rewriteAuxCons = makeContext <+ makeTypingJudgment <+ makeMetaVariable
	trans = topdown(makeAuxCons < rewriteAuxCons + try(makeTerm))