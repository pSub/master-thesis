module optimize-constraint-templates

imports utils
imports constraint-language
imports constraint-template-language
imports constraint-utils
imports generate-fof
imports verification

signature
    sorts DummyVar
    constructors
        DummyVar__ : DummyVar

rules
    
    // FIXME: Currently there is no distinction between which and when ambiguities!
    solve-which-ambiguities(|context-definitions) : templates -> 
        <conc> (<map(mkFork; optimize-fork(|context-definitions, templates))> equality-classes,
               <diff(eq)> (templates,
                           <flatten-list> equality-classes))
        where equality-classes :=  <group(equal-mod-var)> templates
    
    /**
     * Extracts the pattern from the rules and compares the results modulo
     * variable names.
     *
     * @param a - Rule
     * @type Rule -> Rule
     */
    equal-mod-var =
        ?(a, b);
        where(equal(|<Dupl; (get-pattern, get-ctx-pattern); make-dummy-vars> a,
                     <Dupl; (get-pattern, get-ctx-pattern); make-dummy-vars> b))
    
    /**
     * Replaces all occurences of Var(_) with DummyVar(). This strategy
     * is used to implement equal-mod-var.
     * 
     * @internal
     * @type a -> a
     */
    make-dummy-vars = innermost(?Var__(_); !DummyVar__())

    /**
     * Stub for checking whether a rule within a Fork is redundant.
     */
    optimize-fork(|context-definitions, templates) : Fork__(rulez) ->
        <if <equal> (<length> rulez'', 1)
         then <Hd> rulez''
         else !Fork__(rulez'')
         end>
        where vars := <Hd; get-pattern; collect-om(?Var__(_))> rulez;
              // Make the conclusions of the rules equal.
              rulez' := [<Hd> rulez | <Tl; map(\rule -> <zip; replace-all(|rule)> (<get-pattern; collect-om(?Var__(_))> rule, vars)\)> rulez];
              rulez-premisses := <zip> (rulez', <map(\r -> <filter(not(?r); premisses-to-props)> rulez'\)> rulez');
              rulez'' := <remove-all(\(rule, premisses) ->
                                    <fetch-elem(
                                      \ps -> <premisses-to-props; add-indices;
                                         remove-all(
                                          \(i, p') ->
                                             <map(\p ->
                                                     Formula__(<get-rule-name; option-to-string-newname(|"Goal")> rule, Impl__(p', p))
                                                  \);
                                              fof-from-templates(|context-definitions, templates); verify-vampire(|"2", <conc-strings> (<int-to-string> i, <get-rule-name; option-to-string-newname(|"Goal")> rule)); some(?VerificationSuccess(_))> ps
                                          \); equal(|[])> rule
                                     \)> premisses
                                 \); map(Fst)> rulez-premisses

    optimize-templates(|context-definitions) = solve-which-ambiguities(|context-definitions)