module optimize-constraint-templates

imports utils
imports constraint-language
imports constraint-template-language
imports constraint-utils
imports fof-language
imports generate-fof
imports verification
imports sdf-utils
imports template-utils
imports org/sugarj/languages/Sdf2

imports include/SLTC

signature
    sorts DummyVar
    constructors
        DummyVar__ : DummyVar

rules
    
    /**
     * Main strategy that optimizes which-ambiguities.
     * @param context definitions of the specification 
     * @type List(Template) -> List(Template)
     */
    solve-which-ambiguities(|judgments, context-definitions) : templates ->
        <conc> (<map(mkFork;
                optimize-fork(|judgments, context-definitions, templates);
                remove-trivial-fork)> equivalence-classes,
                <diff(eq)> (templates, <flatten-list> equivalence-classes))
        where equivalence-classes := <group(equal-mod-var); filter(where(or(length; gt(|1), some(?Fork__(_)))))> templates
    
    /**
     * Extracts the pattern from the rules and compares the results modulo
     * variable names.
     *
     * @param a - Rule
     * @type Rule -> Rule
     */
    equal-mod-var =
        ?(a, b);
        where(equal(|<Trpl; (get-pattern, get-ctx-pattern, get-judgment-number); make-dummy-vars> a,
                     <Trpl; (get-pattern, get-ctx-pattern, get-judgment-number); make-dummy-vars> b))
    
    /**
     * Replaces all occurences of Var(_) with DummyVar(). This strategy
     * is used to implement equal-mod-var.
     * 
     * @internal
     * @type a -> a
     */
    make-dummy-vars = innermost(?Var__(_); !DummyVar__())

    /**
     * Checks whether a template in a Fork is redundant. Only applicable to Forks in which
     * all templates have patterns that are equal modulo variable names.
     *
     * Checks for each template if all premisses are implied by the premisses of a singel other
     * template. If this is the case the template is removed.
     *
     * @type Fork__(Template) -> Fork__(Template)
     */
    optimize-fork(|judgments, context-definitions, templates) : Fork__(ts) -> Fork__(ts'')
        where ts' := <make-conclusions-equal(newnames(|"Z"); map(makeVar))> ts;
              rulez-premisses := <zip> (ts', <map(\r -> <filter(not(?r))> ts'\)> ts');
              ts'' := <remove-all(\(rule, premisses) ->
                                        <is-subsumed(|judgments, context-definitions, templates, language)> (rule, premisses)
                                  \); map(Fst)> rulez-premisses

    make-conclusions-equal(wrap) =
        ?templates;
        vars := <Hd; get-pattern; collect-om(?Var__(_)); length; wrap> templates;
        <map(\rule -> <zip; replace-all(|rule)> (<get-pattern; collect-om(?Var__(_))> rule, vars)\); nub> templates

    is-subsumed(|judgments, context-definitions, templates) =
        ?(rule, templates);
        templates-without-rule := <diff> (templates, [rule]);
        premisses := <map(premisses-to-props)> templates-without-rule;
        rule-premisses := <premisses-to-props> rule;
        map(\ps -> Formula__("", Impl__(And__(rule-premisses), And__(ps)))\);
        direct-proof(|<get-template-name> rule, templates-without-rule, context-definitions);
        some(?VerificationSuccess)

    /**
     * Main strategy that optimizes when-ambiguities.
     *
     * @param judgments of the specification
     * @param target-language of the specification
     * @param context definitions of the specification
     * @type List(Template) -> List(Template)
     */
    solve-when-ambiguities(|judgments, target-language, context-definitions) =
        ?templates;
        where(equivalence-classes := <create-classes> templates);
        <conc> (<map(mkFork; optimize-relation(|judgments, context-definitions, target-language); remove-trivial-fork)> equivalence-classes,
                <diff(eq)> (templates, <flatten-list> equivalence-classes))

    /**
     * Optimize relations. A relation is a set of templates that define
     * a judgment with only input positions.
     *
     * FXIME: Take care of contexts.
     */
    optimize-relation(|judgments, context-definitions, target-language) =
        is-relation; where(get-non-syntax-directed-templates; not(equal(|[])));
        where(get-ctx-pattern; equal(|[]))
        < optimize-relation'(|judgments, context-definitions, target-language) + id
    optimize-relation'(|judgments, context-definitions, target-language) :
        f@Fork__(ts) -> Fork__(ts')
        where non-syntax-directed-ts := <get-non-syntax-directed-templates> f;
              judgment-number := <Hd; get-judgment-number> non-syntax-directed-ts;
              non-terminals := <get-judgment-types(|judgment-number)> judgments;
              substructures := <map(get-immediate-substructures(|target-language))> non-terminals;
              ts' := <foldl(derive-syntax-directed-rules(|substructures, non-terminals, context-definitions));
                      remove-unsatisfiable-templates(|context-definitions);
                      remove-valid-premisses(|context-definitions)> (non-syntax-directed-ts, ts)
              
              // base-constructors := <map(filter(where(get-arguments; equal(|[]))))> substructures;
              // base-cons-product := <cartesian-product> base-constructors;
              // pos-base-goals := <map(\args -> Formula__("", Pred__(<conc-strings> ("tcheck", <int-to-string> judgment-number), args))\)> base-cons-product;
              // neg-base-goals := <map(\args -> Formula__("", Not__(Pred__(<conc-strings> ("tcheck", <int-to-string> judgment-number), args)))\)> base-cons-product;
              // pos-proofs := <fof-from-templates(|context-definitions, ts); verify-vampire(|"2", "pos-base-goal")> pos-base-goals;
              // neg-proofs := <fof-from-templates(|context-definitions, ts); verify-vampire(|"2", "neg-base-goal")> neg-base-goals;
              // proofs := <zip> (pos-proofs, neg-proofs);
              // <not(some((?VerificationFailure(_), ?VerificationFailure(_))))> proofs;
              // base-templates := <zip; filter(\(goal, (VerificationSuccess(_),_)) -> <make-base-template> (judgment-number, goal)\)> (base-cons-product, proofs)
              
    derive-syntax-directed-rules(|substructures, non-terminals, context-definitions) =
        ?(property, templates);
        substructures-with-vars := <collect-om(?sort(_), conc); Dupl;
                                             (id, length; newnames(|"Z"); map(makeVar));
                                             zip; replace-once(|substructures)> substructures;
        instances := <cartesian-product; map(zip(|<get-pattern> property); replace-all(|property))> substructures-with-vars;
        !<conc> (<diff> (templates, [property]), instances)

    remove-unsatisfiable-templates(|context-definitions) =
        ?templates;
        <remove-all(where(premisses-to-props;
                     map(\p -> Formula__("", Not__(p))\);
                     direct-proof(|Some("neg-premise"), templates, context-definitions); all(?VerificationSuccess(_))
                   ))> templates
                     
    remove-valid-premisses(|context-definitions) =
        ?templates; <map(remove-valid-premisses(|context-definitions, templates))> templates
        
    remove-valid-premisses(|context-definitions, templates) =
        ?template;
        indices := <premisses-to-props; map(\p -> Formula__("", p)\);
                    direct-proof(|Some("valid-premise"), templates, context-definitions);
                    add-indices; remove-all(Snd;?VerificationSuccess(_)); map(Fst)> template;
        premisses := <get-premisses> template;
        <set-premisses(|<map(\i -> <index(|i)> premisses\)> indices)> template
        
    /**
     * Attempts a direct proofs of the given formula
     * given the template and context-definitions
     *
     * @param name of the goal
     * @param templates
     * @param context definitions
     * @type Formula -> Formula
     */
    direct-proof(|name, templates, context-definitions) =
        direct-proof(|"2", name, templates, context-definitions)
    direct-proof(|timeout, name, templates, context-definitions) =
        fof-from-templates(|context-definitions, templates);
        verify-vampire(|timeout, <option-to-string-newname(|"Goal")> name)
                     
    solve-which-ambiguities-with-induction-hypothesis(|substructures, non-terminals, templates, context-definitions, property) =
        ?which-ambiguities;
        which-ambiguities' := <make-conclusions-equal(newnames(|"c"))> which-ambiguities;
        conclusion := <Hd; get-pattern> which-ambiguities';
        step-pattern := <Hd; get-pattern; zip(|substructures);
                         map(\(pattern, term) ->
                                <fetch-elem(where(\p -> <match-constructors(?sort(_), false)> (term, p)\))> pattern
                             \);
                         zip(|non-terminals);
                         {|Fresh: map(\(nt, pattern) ->
                                        <collect-om(?sort(nt), conc); Dupl;
                                             (id, length; newnames(|"Z"); map(makeVar));
                                             zip; replace-once(|pattern)> pattern
                                      \) |}> which-ambiguities';
        induction-hypothesis := <zip; map-with-index(\(i, (pattern, term)) ->
                                                    <collect-om(?Var__(_)); instantiate(|[pattern], [term]);
                                                     map(\t -> <replace(|property)> (<get-pattern; index(|i)> property, t) \)> pattern
                                                \); concat> (step-pattern, conclusion);
        ambiguities-premisses := <zip> (which-ambiguities', <map(\r -> <filter(not(?r))> which-ambiguities'\)> which-ambiguities');
        ambiguities := <zip; filter(where(Snd; is-subsumed(|[], context-definitions, <conc> (<diff> (templates, [property]), induction-hypothesis))); Fst)> (which-ambiguities, ambiguities-premisses)


    /**
     * Creates a template for the judgment corresponding to the judgment number
     * with the given pattern as a term pattern and no premisses.
     *
     * Example template:
     *
     * ==========
     * int <: int
     * 
     * @type (Int, ATerm) -> Template
     */
    make-base-template : (judgment-number, pattern) -> Template__(None(), [], Conclusion__(judgment-number, (pattern, []), []))

    /**
     * The templates within a fork define a relation if they have no output positions.
     * Strategy succeeds if the templates define a relation and fails otherwise.
     */
    is-relation : Fork__([t|ts]) -> Fork__([t|ts])
        where <get-outputs; option(equal(|[]))> t

    /**
     * Returns all templates of a fork that contain only variables in their conclusion.
     *
     * @type Fork(List(Template)) -> List(Template)
     */
    get-non-syntax-directed-templates : Fork__(ts) -> <filter(where(get-pattern; all(?Var__(_))))> ts

    /**
     * Strategy that groups all templates that are when-ambiguous to each other.
     *
     * @type List(Template) -> List(List(Template))
     */
    create-classes : [] -> []
    create-classes : [t | ts] -> [class | <create-classes> ts']
        where class := <create-class; nub> (t, ts);
              ts' := <diff> (ts, class)

    /**
     * Strategy that selects all templates `ts' that are when-ambigous
     * to the template `t'. 
     *
     * @type (Template, List(Template)) -> List(List(Template))
     */
    create-class =
        ?(t, ts);
        where(subsumed := <filter(where(\t' -> <subsume-mod-var(true)> (t, t')\))> ts;
              ts' := <diff> (ts, subsumed));
        if <equal> (ts, ts')
        then ![t]
        else <conc> ([t | subsumed], <mapconcat(\t' -> <create-class> (t', ts')\)> subsumed)
        end

    /**
     *  Strategy succeeds if template t1 and t2 are chosen such that
     *
     *      m(t1) \subseteq m(t2)
     *
     * where m(t) computes the set of terms that match the conclusion of t and such
     * that the judgment numbers are equal. If the strategy `sym' succeeds the strategy
     * also succeeds if
     *
     *      m(t2) \subseteq m(t1)
     *
     * @param strategy that succeeds when the comparison should be symmetric and fails otherwise
     */
    subsume-mod-var(sym) =
        ?(a, b);
        where(equal(|<get-judgment-number> a, <get-judgment-number> b));
        where(<zip; map(match-constructors(?Ctx__(_) <+ ?DummyVar__(), sym))> (<make-dummy-vars; get-ctx-pattern> a, <make-dummy-vars; get-ctx-pattern> b));
        where(<zip; map(match-constructors(?DummyVar__(), sym))> (<make-dummy-vars;get-pattern> a, <make-dummy-vars; get-pattern> b))

    /**
     * Sorts all templates within forks according to subsume-mod-var(false).
     *
     * @type List(Template) -> List(Template)
     */
    order-forks-by-subsumption = map(try(\Fork__(ts) -> Fork__(<qsort(subsume-mod-var(false))> ts)\))

    /**
     * Extract templates from singelton forks.
     * @type List(Template) -> List(Template)
     */
    remove-forks : [Fork__(ts) | ts'] -> <conc> (ts, <remove-forks> ts')
    remove-forks : [t | ts] ->  [t | <remove-forks> ts]
    remove-forks : [] -> []

    /**
     * Unpacks a Fork if it only contains a single template.
     */
    remove-trivial-fork : Fork__(ts) ->
         <if <equal> (<length> ts, 1)
          then <Hd> ts
          else !Fork__(ts)
          end>

    /**
     * Main strategy that composes all optimizations.
     *
     * @param judgments of the specification
     * @param target-language of the specification
     * @param context definitions of the specification 
     * @type List(Template) -> List(Template)
     */
    optimize-templates(|target-language, context-definitions) =
        ?(templates, judgments);
        {|Fresh:
        <solve-which-ambiguities(|judgments, context-definitions);
        solve-when-ambiguities(|judgments, target-language, context-definitions);
        order-forks-by-subsumption> templates |}