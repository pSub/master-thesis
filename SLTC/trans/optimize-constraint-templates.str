module optimize-constraint-templates

imports utils
imports constraint-language
imports constraint-template-language
imports constraint-utils
imports generate-fof
imports verification
imports sdf-utils

imports include/SLTC

signature
    sorts DummyVar
    constructors
        DummyVar__ : DummyVar

rules
    
    solve-which-ambiguities(|context-definitions) : templates -> 
        <conc> (<map(mkFork;
        // optimize-fork(|context-definitions, templates);
           remove-trivial-fork)> equivalence-classes,
                <diff(eq)> (templates, <flatten-list> equivalence-classes))
        where equivalence-classes := <group(equal-mod-var)> templates
    
    /**
     * Extracts the pattern from the rules and compares the results modulo
     * variable names.
     *
     * @param a - Rule
     * @type Rule -> Rule
     */
    equal-mod-var =
        ?(a, b);
        where(equal(|<Trpl; (get-pattern, get-ctx-pattern, get-judgment-number); make-dummy-vars> a,
                     <Trpl; (get-pattern, get-ctx-pattern, get-judgment-number); make-dummy-vars> b))
    
    /**
     * Replaces all occurences of Var(_) with DummyVar(). This strategy
     * is used to implement equal-mod-var.
     * 
     * @internal
     * @type a -> a
     */
    make-dummy-vars = innermost(?Var__(_); !DummyVar__())

    /**
     * Checks whether a template in a Fork is redundant. Only applicable to Forks in which
     * all templates have patterns that are equal modulo variable names.
     *
     * Checks for each template if all premisses are implied by the premisses of a singel other
     * template. If this is the case the template is removed.
     *
     * @type Fork_(Template) -> Fork__(Template)
     */
    optimize-fork(|context-definitions, templates) : Fork__(rulez) -> Fork__(rulez'')
        where vars := <Hd; get-pattern; collect-om(?Var__(_))> rulez;
              // Make the conclusions of the rules equal.
              rulez' := [<Hd> rulez | <Tl; map(\rule -> <zip; replace-all(|rule)> (<get-pattern; collect-om(?Var__(_))> rule, vars)\)> rulez];
              rulez-premisses := <zip> (rulez', <map(\r -> <filter(not(?r); premisses-to-props)> rulez'\)> rulez');
              rulez'' := <remove-all(\(rule, premisses) ->
                                    <fetch-elem(
                                      \ps -> <premisses-to-props; add-indices;
                                         remove-all(
                                          \(i, p') ->
                                             <map(\p ->
                                                     Formula__(<get-template-name; option-to-string-newname(|"Goal")> rule, Impl__(p', p))
                                                  \);
                                              fof-from-templates(|context-definitions, templates); verify-vampire(|"2", <conc-strings> (<int-to-string> i, <get-template-name; option-to-string-newname(|"Goal")> rule)); some(?VerificationSuccess(_))> ps
                                          \); equal(|[])> rule
                                     \)> premisses
                                 \); map(Fst)> rulez-premisses

    solve-when-ambiguities(|judgments, target-language, context-definitions) =
        ?templates;
        where(equivalence-classes := <create-classes> templates);
        <conc> (<map(mkFork; optimize-relation(|judgments, context-definitions, target-language); remove-trivial-fork)> equivalence-classes,
                <diff(eq)> (templates, <flatten-list> equivalence-classes))

    // FXIME: Take care of contexts.
    optimize-relation(|judgments, context-definitions, target-language) =
        is-relation; where(get-non-syntax-directed-templates; not(equal(|[])));
        where(get-ctx-pattern; equal(|[]))
        < optimize-relation'(|judgments, context-definitions, target-language) + id
    optimize-relation'(|judgments, context-definitions, target-language) : f@Fork__(ts) -> Fork__(<conc> (ts, base-templates))
        where non-syntax-directed-ts := <get-non-syntax-directed-templates> f;
              judgment-number := <Hd; get-judgment-number> non-syntax-directed-ts;
              non-terminals := <index(|judgment-number); collect-om(?Hole(non-terminal, _); !non-terminal, conc)> judgments;
              substructures := <map(get-immediate-substructures(|target-language))> non-terminals;
              base-constructors := <map(filter(where(get-arguments; equal(|[]))))> substructures;
              base-cons-product := <cartesian-product> base-constructors;
              base-goals := <map(\args -> Formula__("", Pred__(<conc-strings> ("tcheck", <int-to-string> judgment-number), args))\)> base-cons-product;
              proofs := <fof-from-templates(|context-definitions, ts); verify-vampire(|"2", "base-goal")> base-goals;
              base-templates := <zip; filter(\(goal, VerificationSuccess(_)) -> <make-base-template> (judgment-number, goal) \)> (base-cons-product, proofs)

    make-base-template : (judgment-number, pattern) -> Template__(None(), [], Conclusion__(judgment-number, (pattern, []), []))

    is-relation : Fork__([t|ts]) -> Fork__([t|ts])
        where <get-outputs; option(equal(|[]))> t

    get-non-syntax-directed-templates : Fork__(ts) -> <filter(where(get-pattern; all(?Var__(_))))> ts

    create-classes : [] -> []
    create-classes : [t | ts] -> [class | <create-classes> ts']
        where class := <create-class; nub> (t, ts);
              ts' := <diff> (ts, class)

    create-class =
        ?(t, ts);
        where(subsumed := <filter(where(\t' -> <subsume-mod-var(true)> (t, t')\))> ts;
              ts' := <diff> (ts, subsumed));
        if <equal> (ts, ts')
        then ![t]
        else <conc> ([t | subsumed], <mapconcat(\t' -> <create-class> (t', ts')\)> subsumed)
        end

    subsume-mod-var(sym) =
        ?(a, b);
        where(equal(|<get-judgment-number> a, <get-judgment-number> b));
        where(<zip; map(match-constructors(?Ctx__(_) <+ ?DummyVar__(), sym))> (<make-dummy-vars; get-ctx-pattern> a, <make-dummy-vars; get-ctx-pattern> b));
        where(<zip; map(match-constructors(?DummyVar__(), sym))> (<make-dummy-vars;get-pattern> a, <make-dummy-vars; get-pattern> b))

    order-forks-by-subsumption = map(try(\Fork__(ts) -> Fork__(<qsort(subsume-mod-var(false))> ts)\))

    remove-forks : [Fork__(ts) | ts'] -> <conc> (ts, <remove-forks> ts')
    remove-forks : [t | ts] ->  [t | <remove-forks> ts]
    remove-forks : [] -> []

    /**
     * Unpacks a Fork if it only contains a single template.
     */
    remove-trivial-fork : Fork__(ts) ->
         <if <equal> (<length> ts, 1)
          then <Hd> ts
          else !Fork__(ts)
          end>

    optimize-templates(|judgments, target-language, context-definitions) =
        solve-which-ambiguities(|context-definitions);
        solve-when-ambiguities(|judgments, target-language, context-definitions);
        order-forks-by-subsumption