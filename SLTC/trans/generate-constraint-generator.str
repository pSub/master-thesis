module generate-constraint-generator

imports constraint-language
imports utils
imports include/SLTC

signature
    sorts
    constructors
       Rule : Pattern * Outputs * Constraints -> Rule
       Binding : List(List(var)) * List(Call) * lookups * List(ctx, inputs, outputs) -> Rule
       Call : List(term) * List(term) -> Call
       Pattern : term
       Outputs : List(term)
       Output : term -> Output
       
       ConstraintGenerator : List(Rule)
       
rules
    
    // FIXME: The where clause of this rule duplicates code.
    make-constraint-generator :
        Module(ModuleDec(_),
               imports,
               Language(l),
               MetaVariables(meta-variables),
               Contexts(context-definitions),
               Judgments(judgments),
               Rules(typing-rules),
               conjectures)
        -> <innermost(base(|judgments, context-classes) <+
                      step(|judgments, context-definitions, context-classes))> typing-rules
        where
            context-names := <map(proj(ContextDefinition|1))> context-definitions;
            context-classes := <filter(\MetaVariableDefinition(name, _, Scope(scope)) ->
                                       <isect; not(equal(|[])); !name> (context-names, scope)\)>
                                       meta-variables
    
    /**
     * Extracts the pattern from Rule or Binding
     */
    get-pattern : Rule(pattern, _, _) -> pattern
    get-pattern : Binding(_, _, _, Rule(pattern, _, _)) -> pattern

    /**
     * Wraps the given term with the constructor Output
     */
    mkOutput : n -> Output(n)

    /**
     * Extacts all consituents from the given term that are marked
     * as inputs in the declaration.
     *
     * @param declarations - either a list of context of judgment declarations
     *                       or something of equivalent structure
     */
    get-inputs(|declarations) = filter-hole-positions(?(_, "I") | declarations)

    /**
     * Extacts all consituents from the given term that are marked
     * as outputs in the declaration and wraps those with Output. The
     * wrapping is used for identifying output terms in step.
     *
     * @param declarations - either a list of context of judgment declarations
     *                       or something of equivalent structure
     */
    get-outputs(|declarations) = filter-hole-positions(?(_, "O") | declarations); map(mkOutput)

    /**
     * Like `get-outputs` but does not wrap everything into Output constructors.
     *
     * @param declarations - either a list of context of judgment declarations
     *                       or something of equivalent structure
     */
    get-outputs'(|declarations) = filter-hole-positions(?(_, "O") | declarations)

    /**
     * Extracts all consituents from a given term that satisfy the given
     * condition `cond`.
     *
     * @param cond - an arbitrary strategy
     * @param declarations - either a list of context of judgment declarations
     *                       or something of equivalent structure
     */
    filter-hole-positions(cond|declarations) : node -> consituents
        where
            args := <get-arguments> node;
            positions := <get-hole-positions(|declarations); filter(cond); map(Fst)> node;
            consituents := <map(\n -> <index(|<add>(n, 1))> args\)> positions

    /**
     * Fetches the declaration for the given node and provides a list of
     * holes together with their positions.
     *
     * @param declarations - either a list of context of judgment declarations
     *                       or something of equivalent structure
     */
    get-hole-positions(|declarations) : cons#(args) -> <enum> holes
        where
            [constant, generic] := <string-tokenize(|<singelton> '-')> cons;
            declaration-number := <string-to-int; \n -> (n, 1)\; add> generic;
            declaration := <index(|declaration-number)> declarations;
            holes := <collect-all(?Hole(_,_)); map(proj(Hole|2))> declaration

    /**
     * Rule that transforms axioms, i.e. typing rules without premisses into
     * a constraint template.
     *
     * @param j - judgment declarations
     * @param cc - meta-variable classes that represent contexts
     */
    base(|j, cc) : TypingRule(_, conclusion) ->
        <replace-meta-variables>
           Rule(<get-inputs(|j); remove-all(node-is-ctx(|cc))> conclusion,
                <get-outputs(|j)> conclusion,
                [])

    /**
     * Rule that transforms typing rules with premisses into a constraint template.
     *
     * FIXME: Allow checks for empty contexts
     *
     * @param j - judgment declarations
     * @param c - context declarartions
     * @param cc - meta-variable classes that represent contexts
     */
    step(|j, c, cc) : TypingRule(premisses-struct, _, conclusion) ->
        <replace-meta-variables>
            Binding(<map(Fst)> vars-outputs,
                    <map((get-inputs(|j), id)); partition(not((node-is-ctx(|cc), id)), (node-is-ctx(|cc), id));
                         (id, mapconcat((ctx-bind-to-kv-list(|c, cc), id)))> premisses,
                    <map((fanout3, id); ((get-context-id, get-inputs(|c), get-outputs(|c)), id))> lookups,
                    // FIXME: Allow context-binds in conclusion, too.
                    Rule(<get-inputs(|j); remove-all(node-is-ctx(|cc))> conclusion,
                         <get-outputs(|j)> conclusion,
                         <mapconcat(zip(makeEq))> vars-outputs))
        where
            premisses-list := <to-list(PremiseBase, PremiseCons)> premisses-struct;
            enum-premisses := <enum> premisses-list;
            dependencies := <map((id, get-inputs(|j)); (id, compute-dependencies(|enum-premisses, j)))> enum-premisses;
            eval-order := <top-sort> dependencies;
            sorted-premisses := <map(\ i -> <index(|<add> (i, 1))> premisses-list\)> eval-order;
            dep-premisses := <zip> (sorted-premisses, <map(Snd)> dependencies);
            (premisses, lookups) := <partition(not((node-is-ctx-lookup, id)), (node-is-ctx-lookup, id))> dep-premisses;
            vars-outputs := <map(Fst; get-outputs(|j); fanout; (length; newnames(|"X"); map(makeVar), id))> premisses

    /**
     * Replaces all meta-variables that occur within Output constructors
     * with fresh variables of the constraint language. This way the unification
     * has to deal only with one kind of variables.
     */
    replace-meta-variables : ast -> <collect-om(?Output(_); collect-om(node-is-meta-variable));
                                     flatten-list; fanout; (id, length; newnames(|"X"); map(makeVar));
                                     zip; replace-all(|ast); topdown(try(\Output(n) -> n\))> ast

    /**
     * Transforms context bindings as they occur in the specification language into
     * a key-value list. This list contains triples with the context identifier, the inputs
     * and the outputs.
     *
     * @param c - context declarartions
     * @param cc - meta-variable classes that represent contexts
     */
    ctx-bind-to-kv-list(|c, cc) : node -> []
        where <node-is-ctx-empty <+ node-is-ctx-var(|cc)> node
    ctx-bind-to-kv-list(|c, cc) : node -> [(ctx, inputs, outputs) | <ctx-bind-to-kv-list(|c, cc)> tail]
        where <node-is-ctx-bind> node;
              ctx := <get-context-id> node;
              inputs := <get-inputs(|c)> node;
              outputs := <get-outputs(|c)> node;
              tail := <get-arguments; last> node
              
    /**
     * Returns the subset of the passed judgments that contain
     * at least one of the `inputs`.
     *
     * @param terms - judgments
     * @param decls - judgment declarations
     */
    compute-dependencies(|terms, decls) : inputs -> 
        <filter(where(Snd; get-outputs'(|decls);
               \ os -> <foldl(\ (i, l) -> <collect-om(?i); conc(|l)> os
                            \)> (inputs, [])
               \; not(equal([]))); Fst)> terms
    
strategies
    to-constraint-generator(|judgments, context-definitions, context-classes) =
         innermost(base(|judgments, context-classes) <+
                   step(|judgments, context-definitions, context-classes))