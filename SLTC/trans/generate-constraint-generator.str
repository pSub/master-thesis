module generate-constraint-generator

imports constraint-language
imports utils
imports include/SLTC

signature
    sorts
    constructors
       Rule : Pattern * Outputs * Constraints -> Rule
       Binding : List(List(Var)) * List(Term) * Rule -> Rule 
       Pattern : Term
       Outputs : List(Term)
       
       ConstraintGenerator : List(Rule)
       
rules
    
    make-constraint-generator :
        Module(ModuleDec(_),
               imports,
               Language(l),
               MetaVariables(m),
               Contexts(ContextDefinitions),
               Judgments(judgments),
               Rules(typing-rules),
               conjectures)
        -> <innermost(base(|judgments) <+ step(|judgments))> typing-rules
        
    make-term = id
    
    get-pattern : Rule(pattern, _, _) -> pattern
    get-pattern : Binding(_, _, Rule(pattern, _, _)) -> pattern

    get-outputs : Rule(_, outputs, _) -> outputs
    get-outputs : Binding(_, _, Rule(_, outputs, _)) -> outputs

    get-constraints : Rule(_, _, constraints) -> constraints
    get-constraints : Binding(_, _, Rule(_, _, constraints)) -> constraints

    get-inputs(|judgments) = filter-hole-positions(?(_, "I") | judgments)        
    get-outputs(|judgments) = filter-hole-positions(?(_, "O") | judgments)
            
    filter-hole-positions(cond|judgments) : node@cons#(args) -> <map(\n -> <index(|<add>(n, 1))> args\)> result
        where
            result := <get-hole-positions(|judgments); filter(cond); map(Fst)> node
    
    get-hole-positions(|judgments) : cons#(args) -> <fanout; (length; range, id); zip> holes
        where
            [constant, generic] := <string-tokenize(|<singelton> '-')> cons;
            judgment-number := <string-to-int; \n -> (n, 1)\; add> generic; 
            judgment := <index(|judgment-number)> judgments;
            holes := <collect-all(?Hole(_,_)); map(proj(Hole|2))> judgment

    base(|j) : TypingRule(_, conclusion) -> Rule(<get-inputs(|j)> conclusion,
                                                 <get-outputs(|j)> conclusion,
                                                 [])
    // TODO: Use indexed.str or hashtable for contexts
    step(|j) : TypingRule(premisses, _, conclusion) -> 
            Binding(<map(Fst)> vars-outputs,
                    <map(get-inputs(|j))> premisses',
                    Rule(<get-inputs(|j)> conclusion,
                         <get-outputs(|j)> conclusion,
                         <mapconcat(zip(\(a,b) -> Eq(a,b)\))> vars-outputs))
        where
            premisses' := <to-list(PremiseBase, PremiseCons)> premisses;
            vars-outputs := <map(get-outputs(|j); fanout; (length; newnames(|"X"); map(makeVar), id))> premisses'

    // Preparation for constraint generator generation:
    // 1) Rewrite all language constructs into a Term strukture that
    //    is easily analyzable. Do this in a modular way, as input
    //    programs need to be transformed as well.
    // 2) Analyize typing rules and create rewrite rules that transform
    //    typing rules into constraint generation rules.
    // 3) Adapt the format of the rules if neccessary.
    
    // After a prototype works:
    // 1) Postfix constructors of the specification language with dubble
    //    underscores to avoid collision.
    // 2) Search for ways to optimize the constraint generation rules
    //    2.1) Make not syntax directed rules work
    //    2.2) Exploid facts that can be proven easily
    
strategies
    to-constraint-generator(|judgments, typing-rules) = <innermost(base(|judgments) <+ step(|judgments))> typing-rules