module generate-constraint-generator

imports constraint-language
imports utils
imports include/SLTC

signature
    sorts
    constructors
       Rule : Pattern * Outputs * Constraints -> Rule
       Binding : List(List(Var)) * List(Call) * lookups * Rule -> Rule
       Call : List(Term) * List(Term) -> Call
       Pattern : Term
       Outputs : List(Term)
       Output : a -> Output
       
       ConstraintGenerator : List(Rule)
       
rules
    
    make-constraint-generator :
        Module(ModuleDec(_),
               imports,
               Language(l),
               MetaVariables(meta-variables),
               Contexts(context-definitions),
               Judgments(judgments),
               Rules(typing-rules),
               conjectures)
        -> <innermost(base(|judgments, context-definitions, context-classes) <+ step(|judgments, context-definitions, context-classes))> typing-rules
        where
            context-names := <map(proj(ContextDefinition|1))> context-definitions;
            context-classes := <filter(\MetaVariableDefinition(name, _, Scope(scope)) ->
                                       <isect; not(equal(|[])); !name> (context-names, scope)\)>
                                       meta-variables
    
    get-pattern : Rule(pattern, _, _) -> pattern
    get-pattern : Binding(_, _, _, Rule(pattern, _, _)) -> pattern

    mkOutput : n -> Output(n)

    // TODO: Rename parameter to indicate it works also for contexts
    get-inputs(|judgments) = filter-hole-positions(?(_, "I") | judgments)        
    get-outputs(|judgments) = filter-hole-positions(?(_, "O") | judgments); map(mkOutput)
            
    filter-hole-positions(cond|judgments) : node@cons#(args) -> <map(\n -> <index(|<add>(n, 1))> args\)> result
        where
            result := <get-hole-positions(|judgments); filter(cond); map(Fst)> node
    
    get-hole-positions(|judgments) : cons#(args) -> <fanout; (length; range, id); zip> holes
        where
            [constant, generic] := <string-tokenize(|<singelton> '-')> cons;
            judgment-number := <string-to-int; \n -> (n, 1)\; add> generic; 
            judgment := <index(|judgment-number)> judgments;
            holes := <collect-all(?Hole(_,_)); map(proj(Hole|2))> judgment

    base(|j, c, cc) : TypingRule(_, conclusion) ->
        <topdown(try(\Output(n) -> n\))>
           Rule(<get-inputs(|j); remove-all(node-is-ctx(|cc))> conclusion,
                <get-outputs(|j)> conclusion,
                [])

    // FIXME: Allow checks for empty contexts
    step(|j, c, cc) : TypingRule(premisses-struct, _, conclusion) ->
        <replace-meta-variables; topdown(try(\Output(n) -> n\))>
            Binding(<map(Fst)> vars-outputs,
                    <map(get-inputs(|j); partition(not(node-is-ctx(|cc)), node-is-ctx(|cc));
                         (id, mapconcat(ctx-bind-to-kv-list(|c, cc))))> premisses,
                    <map(fanout3;(get-generic-name; string-to-int, get-inputs(|c), get-outputs(|c)))> lookups,
                    // FIXME: Allow context-binds in conclusion, too.
                    Rule(<get-inputs(|j); remove-all(node-is-ctx(|cc))> conclusion,
                         <get-outputs(|j)> conclusion,
                         <mapconcat(zip(makeEq))> vars-outputs))
        where
            premisses-list := <to-list(PremiseBase, PremiseCons)> premisses-struct;
            (premisses, lookups) := <partition(not(node-is-ctx-lookup), node-is-ctx-lookup)> premisses-list;
            vars-outputs := <map(get-outputs(|j); fanout; (length; newnames(|"X"); map(makeVar), id))> premisses

    replace-meta-variables : ast -> <collect-om(?Output(_); collect-om(node-is-meta-variable)); flatten-list; fanout;
                                    (id, length; newnames(|"X"); map(makeVar));
                                    zip; replace-all(|ast)> ast

    ctx-bind-to-kv-list(|c, cc) : node -> []
        where <node-is-ctx-empty <+ node-is-ctx-var(|cc)> node
    ctx-bind-to-kv-list(|c, cc) : node -> [(ctx, inputs, outputs) | <ctx-bind-to-kv-list(|c, cc)> tail]
        where <node-is-ctx-bind> node;
              ctx := <get-generic-name; string-to-int> node;
              inputs := <get-inputs(|c)> node;
              outputs := <get-outputs(|c)> node;
              tail := <get-arguments; last> node

strategies
    to-constraint-generator(|judgments, context-definitions, context-classes) =
         innermost(base(|judgments, context-definitions, context-classes) <+
                   step(|judgments, context-definitions, context-classes))