module generate-constraint-generator

imports constraint-language
imports constraint-template-language
imports utils
imports include/SLTC
       
rules
    
    // FIXME: The where clause of this rule duplicates code.
    make-constraint-generator :
        Module(ModuleDec(_),
               imports,
               Language(l),
               MetaVariables(meta-variables),
               Contexts(context-definitions),
               Judgments(judgments),
               Rules(typing-rules),
               conjectures)
        -> <to-constraint-generator(|judgments, context-definitions, context-classes)> typing-rules
        where
            context-names := <map(proj(ContextDefinition|1))> context-definitions;
            context-classes := <filter(\MetaVariableDefinition(name, _, Scope(scope)) ->
                                       <isect; not(equal(|[])); !name> (context-names, scope)\)>
                                       meta-variables

    /**
     * Extracts the typing judgment.
     *
     * @type ErrorTypingJudgment -> TypingJudgment
     */
    get-typing-judgment = proj(ErrorTypingJudgment|1)

    /**
     * Extracts the error message.
     *
     * @type ErrorTypingJudgment -> List(MessagePart)
     */
    get-error-message = proj(ErrorTypingJudgment|2)

    /**
     *
     */
    eq-inputs = where(get-generic-name; equal(|"Eq")); get-arguments
    eq-outputs = where(get-generic-name; equal(|"Eq")); ![]
    neq-inputs = where(get-generic-name; equal(|"Neq")); get-arguments
    neq-outputs = where(get-generic-name; equal(|"Neq")); ![]


    /**
     * Extacts all consituents from the given term that are marked
     * as inputs in the declaration.
     *
     * @param declarations - either a list of context of judgment declarations
     *                       or something of equivalent structure
     */
    get-inputs(|declarations) = eq-inputs <+ neq-inputs <+ filter-hole-positions(?(_, "I") | declarations)

    /**
     * Extacts all consituents from the given term that are marked
     * as outputs in the declaration.
     *
     * @param declarations - either a list of context of judgment declarations
     *                       or something of equivalent structure
     */
    get-outputs(|declarations) = eq-outputs <+ neq-outputs <+ filter-hole-positions(?(_, "O") | declarations)

    /**
     * Extracts all consituents from a given term that satisfy the given
     * condition `cond`.
     *
     * @param cond - an arbitrary strategy
     * @param declarations - either a list of context of judgment declarations
     *                       or something of equivalent structure
     */
    filter-hole-positions(cond|declarations) : node -> consituents
        where
            args := <get-arguments> node;
            positions := <get-hole-positions(|declarations); filter(cond); map(Fst)> node;
            consituents := <map(\n -> <index(|n)> args\)> positions

    /**
     * Fetches the declaration for the given node and provides a list of
     * holes together with their positions.
     *
     * @param declarations - either a list of context of judgment declarations
     *                       or something of equivalent structure
     */
    get-hole-positions(|declarations) : cons#(args) -> <add-indices> holes
        where
            [constant, generic] := <string-tokenize(|<singelton> '-')> cons;
            declaration-number := <string-to-int> generic;
            declaration := <index(|declaration-number)> declarations;
            holes := <collect-all(?Hole(_,_), conc); map(proj(Hole|2))> declaration

    /**
     * Rule that transforms axioms, i.e. typing rules without premisses into
     * a constraint template.
     *
     * @param j - judgment declarations
     * @param cc - meta-variable classes that represent contexts
     */
    base(|j, c, cc) : TypingRule(RuleName(_, name), conclusion) ->
        <replace-meta-variables>
           Rule__(name,
                <get-inputs(|j); partition(not(node-is-ctx(|cc)), node-is-ctx(|cc));
                 (id, mapconcat(ctx-bind-to-kv-list(|c, cc)))> conclusion,
                <get-outputs(|j)> conclusion,
                [])

    /**
     * Rule that transforms typing rules with premisses into a constraint template.
     *
     * FIXME: This code needs refactoring
     *
     * @param j - judgment declarations
     * @param c - context declarartions
     * @param cc - meta-variable classes that represent contexts
     */
    step(|j, c, cc) : TypingRule(premisses-struct, RuleName(_, name), conclusion) ->
        <replace-meta-variables>
          Binding__(<map(Fst; Fst)> vars-outputs,
                    <map(switch (get-typing-judgment, id)
                         case (node-is-ctx-lookup, id):
                              (get-typing-judgment; Dupl, map(Dupl; (id, \i -> <index(|i)> sorted-premisses\; Fst; get-typing-judgment; get-outputs(|j))));
                              ((get-context-id, get-inputs(|c)); mkLookup, id)
                         case where((get-generic-name; equal(|"Eq"), id)):
                              \(j, dep) -> (<get-typing-judgment; to-tuple; makeEq(|<get-error-message> j)> j, dep) \
                         case where((get-generic-name; equal(|"Neq"), id)):
                              \(j, dep) -> (<get-typing-judgment; to-tuple; makeNeq(|<get-error-message> j)> j, dep) \
                         otherwise: (get-typing-judgment; get-inputs(|j), map(Dupl; (id, \i -> <index(|i)> sorted-premisses\; Fst; get-typing-judgment; get-outputs(|j))));
                              (partition(not(node-is-ctx(|cc)), node-is-ctx(|cc)), id);
                              ((id, mapconcat(ctx-bind-to-kv-list(|c, cc))); mkJudgment, id)
                         end)> sorted-premisses,
                  Rule__(name,
                         <get-inputs(|j); partition(not(node-is-ctx(|cc)), node-is-ctx(|cc));
                         (id, mapconcat(ctx-bind-to-kv-list(|c, cc)))> conclusion',
                         <get-outputs(|j)> conclusion',
                         <mapconcat(\(var-out, err) -> <zip(\(v, o) -> <makeEq(|<replace(|"INFTYPE", v)> err)> (v, o)\)> var-out\)> vars-outputs))
        where
            premisses-list := <to-list(PremiseBase, PremiseCons)> premisses-struct;
            (substitutions, equalities) := <get-inputs(|j); make-implicit-equalities-explicit> conclusion;
            premisses-list' := <replace-once(|premisses-list)> substitutions;
            conclusion' := <replace-once(|conclusion)> substitutions;
            premisses-with-equalities := <conc> (premisses-list', equalities);
            enum-premisses := <add-indices> premisses-with-equalities;
            dependencies := <map((id, get-typing-judgment; get-inputs(|j)); (id, compute-dependencies(|enum-premisses, conclusion', j)))> enum-premisses;
            eval-order := <zip> (<map(Fst)> enum-premisses, <top-sort> dependencies);
            premisses := <zip> (premisses-with-equalities, <map(Snd)> dependencies);
            sorted-premisses := <map(\ (i, k) -> <index(|k); (id, replace(|i, k))> premisses\)> eval-order;
            vars-outputs := <map(Fst; Dupl; (get-typing-judgment; (node-is-ctx-lookup < get-outputs(|c) + get-outputs(|j)); Dupl, id);
                                 ((length; newnames(|"X"); map(makeVar), id), get-error-message; option(filter(where(?Error(None(), _))))))> sorted-premisses

    /**
     * Replaces all meta-variables with fresh variables of the constraint language.
     * This way the unification has to deal only with one kind of variables.
     */
    replace-meta-variables : ast -> <collect-om(node-is-meta-variable); Dupl;
                                     (id, length; newnames(|"X"); map(makeVar));
                                     zip; replace-all(|ast)> ast

    /**
     * Transforms context bindings as they occur in the specification language into
     * a key-value list. This list contains triples with the context identifier, the inputs
     * and the outputs.
     *
     * @param c - context declarartions
     * @param cc - meta-variable classes that represent contexts
     */
    ctx-bind-to-kv-list(|c, cc) : node -> []
        where <node-is-ctx-var(|cc)> node
    ctx-bind-to-kv-list(|c, cc) : node -> [Reset__(ctx)]
        where <node-is-ctx-empty> node;
              ctx := <get-context-id> node
    ctx-bind-to-kv-list(|c, cc) : node -> [(ctx, inputs, outputs) | <ctx-bind-to-kv-list(|c, cc)> tail]
        where <node-is-ctx-bind> node;
              ctx := <get-context-id> node;
              inputs := <get-inputs(|c)> node;
              outputs := <get-outputs(|c)> node;
              tail := <get-arguments; last> node
              
    /**
     * Returns the subset of the passed judgments that contain
     * at least one of the `inputs`.
     *
     * @param terms - judgments
     * @param decls - judgment declarations
     */
    compute-dependencies(|terms, conclusion, decls) : inputs ->
        <filter(where(Snd; get-typing-judgment; get-outputs(|decls);
               \ os -> <foldl(\ (i, l) -> <collect-om(?i); conc(|l)> os
                              \)> (input-meta-variables, [])
               \; diff(|conclusion-meta-variables); not(equal([]))); Fst)> terms
        where input-meta-variables := <collect-om(node-is-meta-variable)> inputs;
              conclusion-meta-variables := <get-inputs(|decls); collect-om(node-is-meta-variable)> conclusion

    /**
     * Generates from implicit equalities equality premisses.
     */
    make-implicit-equalities-explicit = collect-om(node-is-meta-variable, conc);
                                        group(gt(|1)); Dupl; (id, map(map(make-new-meta-variable)));
                                        zip; Dupl; (mapconcat(zip), mapconcat(Snd; make-eq-judgments))

    /**
     * Creates a new meta-variable of the same class.
     */
    make-new-meta-variable : meta-variable -> <mkterm> (<get-constructor> meta-variable,
                                                        <newname; singelton> "X")

    /**
     * Creates from a given list of meta-variables a list of equality judgments.
     */
    make-eq-judgments : [] -> []
    make-eq-judgments : [x] -> []
    make-eq-judgments : [x, y | xs] -> [eq-judgment | <make-eq-judgments> [y | xs]]
        where eq-judgment := ErrorTypingJudgment(<mkterm> ("TypingJudgment-Eq", [x, y]), Some(Error(None(), "Implicit Equalitiy mismatch")))
    
strategies
    to-constraint-generator(|judgments, context-definitions, context-classes) =
         innermost(base(|judgments, context-definitions, context-classes) <+
                   step(|judgments, context-definitions, context-classes))