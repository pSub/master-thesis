module constraint-solving

imports constraint-language
imports utils
imports include/SLTC

rules
    // Occurs check
    occurs : (x, Var__(x)) -> <id>
    occurs : (x, name#([])) -> <fail>
    occurs : (x, name#(ts@[_|_])) -> <map(occurs)> ts

    // Robinson unification
    unify : cs -> <unify'> (cs, [])
    unify' : ([], mgu) -> ([], mgu)
    unify' : ([CEq__(t, t, info) | cs], mgu) -> <unify'> (cs, mgu)
    unify' : ([CNeq__(t, s, info)| cs], mgu) -> <unify'> (cs, mgu)
        where <not(equal)> (t, s)
    unify' : ([CEq__(t, Var__(x), info) | cs], mgu) ->
         <unify'> (<conc> (cs, <singelton> CEq__(Var__(x), t, info)), mgu)
    unify' : ([CEq__(v@Var__(x), t, info) | cs], mgu) -> <if <occurs> (x, t)
                                     then <error> [x, " occurs in", t]
                                     else <unify'> (<replace(|cs)> (v, t), [(v, t)|mgu])
                                     end>
    unify' : ([CEq__(n#(ts), n#(ts'), info) | cs], mgu) -> <unify'> (<conc> (cs, cs'), mgu)
        where <equal>(<length> ts, <length> ts');
              cs' := <zip; map(makeEq(|info))> (ts, ts')
    unify' = get-info; singelton; error

    // Apply mgu
    apply-mgu(|t) : mgu -> <foldl(\((x, s), t') -> <subst> (x, s, t')\)> (mgu, t)
    subst : (x, s, x) -> s
    subst : (x, s, Var(y)) -> Var(y)
    subst : (x, s, n#(args)) -> <mkterm> (n, args')
        where args' := <map(\t -> <subst> (x, s, t)\)> args