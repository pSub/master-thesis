module utils
	
rules
    
    skip = fail

    /**
     * Inserts between every two elements of the given list `s`.
     *
     * @param s - an arbitary term
     * @type List(a) -> List(a)
     */
    intersperse(|s) : [] -> []
    intersperse(|s) : [x] -> [x]
    intersperse(|s) : [x|y] -> [x,s| <intersperse(|s)> y]

    /**
     * Group
     */
    group(s) = foldr(![], \(x, bag) -> <bag-insert> ((x, 1), bag)\);
               filter(\(x, n) -> <where(s); range; map(!x)> n \)

    /**
     *
     */
    gt(|y) : x -> <gt> (x, y)

    /**
     * String representation for Option values. Some(s) is projected
     * to s and None() is projected to the empty string.
     *
     * @type Option(a) -> a | String
     */
    option-to-string : Some(s) -> s
    option-to-string : None()  -> ""

    /**
     * String representation for Option values. Some(s) is projected
     * to s and None() is projected to a random string prefixed with `l`.
     * The random string is created with <newname>.
     *
     * @param l - prefix for random string
     * @type Option(a) -> a | String
     */
    option-to-string-newname(|l) : Some(s) -> s
    option-to-string-newname(|l) : None() -> <newname> l

    /**
     * Takes a rule `f` and a default value `s`. None() is rewritten to
     * the default value. Some(s') is rewritten to `f` applied to `s'`.
     *
     * @param f - some arbitary strategy
     * @param s - some arbitary term
     * @type Option(a) -> b
     */
    maybe(f|s) : None() -> s
    maybe(f|s) : Some(s') -> <f> s' 

    /**
     * Creates a list of `n` random strings prefixed with `l`.
     *
     * @param l - an arbitary string
     * @type Int -> [String]
     */
    newnames(|l) : 0 -> []
    newnames(|l) : n -> [<newname> l | <newnames(|l)> <subt> (n, 1)]

    /**
     * Converts a list like data structure into a list.
     *
     * `c1` is the constructor representing `Nil`. It can possibly have
     * one argument. `c2` is the constructor representing `Cons`. It has
     * exactly two arguments, the first is arbitary and the second is
     * either `c1` or `c2`.
     *
     * @param c1 - an constructor with zero or one argument
     * @param c2 - an constructor with exactly two arguments
     * @type a -> [b]
     */
    to-list(c1, c2) : c1#([]) -> []
    to-list(c1, c2) : c1#([arg1]) -> [arg1]
    to-list(c1, c2) : c2#([arg1, arg2]) -> [arg1 | <to-list(c1,c2)> arg2]

    /**
     * Projects the `n`-th argument of constructor `c`.
     *
     * @param c - an constructor with at least `n` arguments
     * @param n - a natural number
     * @type a -> b
     */
    proj(c|n) : c#(args) -> <index(|n)> args

    /**
     * Replaces all `old-node` with `new-node` in `ast`.
     *
     * @param old-node - an arbitrary term
     * @param new-node - an arbitrary term
     * @param ast - an arbitrary term
     * @type a
     */
    replace(|old-node, new-node, ast) = <innermost(?old-node; !new-node)> ast

    /**
     * Replaces all `old-node` with `new-node` in `ast`.
     *
     * @param old-node - an arbitrary term
     * @param new-node - an arbitrary term
     * @type a -> b
     */
    replace(|old-node, new-node) : ast -> <replace(|old-node, new-node, ast)>

    /**
     * Replaces all `old-node` with `new-node` in `ast`.
     *
     * @param ast - an arbitrary term
     * @type (a, b) -> c
     */
    replace(|ast) : (old-node, new-node) -> <replace(|old-node, new-node, ast)>

    /**
     * Wraps around `replace`. Recieves a list of substitution pairs and replaces
     * those in `ast` from left to right.
     *
     * @param ast - an arbitrary term
     * @type List((a, b)) -> c
     */
    replace-all(|ast) : substitutions -> <foldl(\(subst, ast') -> <replace(|ast')> subst\)> (substitutions, ast)

    /**
     *
     */
    replace-once(|ast) : substitutions -> <foldl(\((x, t), i) -> <try(oncetd(?x; !t))> i\)> (substitutions, ast)

    /** 
     * Duplicate a term into a three-element tuple
     *
     * @type a -> Tuple(a, a, a)
     */  
    Trpl : v -> (v, v, v)

    /**
     * Computes all tails of the given list.
     *
     * @type List(a) -> List(List(a))
     */
    tails : xs -> [xs | <if [] then [] else <Tl; tails> xs end> xs]

    /**
     * Creates a list containing soely the passed term. Same as `MkSingelton'
     * which is declared internal.
     *
     * @type a -> List(a)
     */
    singelton : x -> [ x ]

    /**
     * Convenience wrapper around `isect`.
     *
     * @param set1 - some arbitary list
     * @type List(a) -> List(a)
     */
    isect(|set1) : set2 -> <isect> (set1, set2)

    /**
     *
     */
    diff(|set2) : set1 -> <diff> (set1, set2)

    /**
     * Convenience wrapper around `conc`.
     *
     * @param l - some arbitary list
     * @type List(a) -> List(a)
     */
    conc(|l) : l' -> <conc> (l, l')

    /**
     * Forget about the constructor and return the
     * arguments as a tuple.
     *
     * @type a -> (a, b, ...)
     */
    to-tuple = get-arguments; ListToTuple

    /**
     * Wraps around equal to provide the result as a string.
     *
     * @param t - some arbitrary term
     * @type a -> String
     */
    equal-to-string(|t) = equal(|t) < !"Success" + !"Failure"

    /**
     * Topological sort of the passed graph.
     *
     * The graph is represented as a list of tuples. The first element
     * is the node and the second is a list of nodes to which outgoing
     * edges exist.
     *
     * Warning: This is the usual topological sort algorithm, but traverses
     * the graph in reversed order, since the input graph is defined by
     * its outgoing edges. Therefore the resulting ordering is reversed.
     *
     * @type List(a, List(a)) -> List(a)
     */
    top-sort : graph -> <top-sort'; reverse> (graph, <filter(where(Snd; equal([])); Fst)> graph, [])

    /** @internal */
    top-sort' : (graph, [], L) -> <if <has-edges> graph
                                   then <singelton; error; fail> "Cyclic dependencies"
                                   else !L
                                   end>
    top-sort' : (graph, [n|S], L) -> <top-sort'> (graph', S', [n|L])
        where graph' := <filter((not(?n), id)); map((id, filter(not(?n))))> graph;
              S' := <filter(where(Snd; equal([])); Fst)> graph'

    /**
     * Checks whether the input graph contains at least one edge.
     *
     * @type a -> a
     */
    has-edges = some(Snd; not(equal([])))

    /**
     * A version of `set-index' that is 1-indexed.
     */
    set-index' : (i, x, xs) -> <set-index> (<dec> i, x, xs)

    /**
     * Computes all indices of occurences of `y' in the list `xs'.
     *
     * @type (a, List(a)) -> List(Int)
     */
    get-indices : (y, xs) -> <filter(where(Snd; equal(|y)); Fst)> xs

    /**
     * Applys strategy `s' to the elements of the list until it succeeds
     * and returns the result. Fails otherwise
     *
     * @param s - an arbitary startegy
     * @type List(a) -> b
     */
    until(s) : [] -> <fail>
    until(s) : [x | xs] -> <<s> x < id + <until(s)> xs>

    /**
     * Deletes at most one occurence of the element in the list.
     *
     * @type (a, List(a)) -> List(a)
     */
    delete : (y, []) -> []
    delete : (y, [y | xs]) -> xs
    delete : (y, [x | xs]) -> [x | <delete> (y, xs)]

    /**
     * A version of `hashtable-copy' that can deal with hashtables that
     * contain hashtables.
     *
     * @type HashTable(K, V) -> HashTable(K,V)
     */
    hashtable-deep-copy = hashtable-getlist; map(alltd(?Hashtable(_); hashtable-deep-copy)); hashtable-init

    /**
     * Checks whether the given string is a meta-variable constructor name.
     *
     * @type String -> String
     */
    is-meta-variable = is-generic(|"MetaVariable")

    /**
     * Checks whether the given string is a context binding constructor name.
     *
     * @type String -> String
     */
    is-ctx-bind = is-generic(|"ContextBind")

    /**
     * Checks whether the given string is a context lookup constructor name.
     *
     * @type String -> String
     */
    is-ctx-lookup = is-generic(|"ContextLookup")

    /**
     * Checks whether the given term is a meta-variable.
     *
     * @type a -> a
     */
    node-is-meta-variable = node-is-generic(|"MetaVariable")

    /**
     * Checks whether the given term is a context binding.
     *
     * @type a -> a
     */
    node-is-ctx-bind = node-is-generic(|"ContextBind")

    /**
     * Checks whether the given term is a context lookup.
     *
     * @type a -> a
     */
    node-is-ctx-lookup = node-is-generic(|"ContextLookup")

    /**
     * Checks whether the given node is an empty context.
     *
     * @type a -> a
     */
    node-is-ctx-empty = node-is-generic(|"ContextEmpty")

    /**
     * Checks whether the given node is a context meta-variable.
     *
     * @param cc - context classes
     * @type a -> a
     */
    node-is-ctx-var(|cc) : node -> <where(<elem> (<get-generic-name> node, cc))>

    /**
     * Checks whether the given node is some form of context.
     *
     * @param cc - context classes (hast type List(String))
     * @type a -> a
     */
    node-is-ctx(|cc) = node-is-ctx-bind <+
                  node-is-ctx-lookup <+
                  node-is-ctx-empty <+
                  node-is-ctx-var(|cc)

    /**
     * Splits the given string at '-' and compares the first part with `name'.
     *
     * @param name - an arbitrary string
     * @type String -> String
     */
    is-generic(|name) = string-tokenize(|<singelton> '-'); Hd; equal(|name)

    /**
     * Applies `is-generic' to the constructor of the node. If is-generic succeeds
     * it behaves like `id'.
     *
     * @param name - an arbitrary string
     * @type a -> a
     */
    node-is-generic(|name) = where(get-constructor; is-generic(|name))

    /**
     * Splits the construtor name of the given node at '-' and returns the last part.
     *
     * @type a -> String
     */
    get-generic-name = get-constructor; string-tokenize(|<singelton> '-'); last

    /**
     * The generic name of contexts is a number. This strategy retrieves the
     * generic name as a real integer.
     *
     * @type a -> Int
     */
    get-context-id = get-generic-name; string-to-int