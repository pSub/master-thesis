module utils
	
rules
    intersperse(|s) : [] -> []
    intersperse(|s) : [x] -> [x]
    intersperse(|s) : [x|y] -> [x,s| <intersperse(|s)> y]

    option-to-string : Some(s) -> s
    option-to-string : None()  -> ""
    
    option-to-string-newname(|l) : Some(s) -> s
    option-to-string-newname(|l) : None() -> <newname> l
    
    maybe(f|s) : None() -> s
    maybe(f|s) : Some(s') -> <f> s' 
    
    newnames(|l) : 0 -> []
    newnames(|l) : n -> [<newname> l | <newnames(|l)> <subt> (n, 1)]

    to-list(c1,c2) : c1#([arg1]) -> [arg1]
    to-list(c1,c2) : c2#([arg1, arg2]) -> [arg1 | <to-list(c1,c2)> arg2]
    
    proj(c|n) : c#(args) -> <index(|n)> args

    replace(|old-node, new-node, ast) = <innermost(?old-node; !new-node)> ast
    replace(|ast) : (old-node, new-node) -> <innermost(?old-node; !new-node)> ast
    
    replace-all(|ast) : substitutions -> <foldl(\(subst, ast') -> <replace(|ast')> subst\)> (substitutions, ast)

    fanout : v -> (v, v)
    fanout3 : v -> (v, v, v)
    
    tails : xs -> [xs | <if [] then [] else <Tl; tails> xs end> xs]
    
    singelton : x -> [ x ]

    enum = fanout; (length; range, id); zip

    conc(|l) : l' -> <conc> (l, l')

    top-sort : graph -> <top-sort'; reverse> (graph, <filter(where(Snd; equal([])); Fst)> graph, [])
    top-sort' : (graph, [], L) -> <singelton; error> "Cyclic dependencies"
        where <has-edges> graph
    top-sort' : (graph, [], L) -> L
    top-sort' : (graph, [n|S], L) -> <top-sort'> (graph', S', [n|L])
        where graph' := <filter((not(?n), id)); map((id, filter(not(?n))))> graph;
              S' := <filter(where(Snd; equal([])); Fst)> graph'

    has-edges = not(all(Snd; equal([])))

    is-meta-variable = is-generic(|"MetaVariable")
    is-ctx-bind = is-generic(|"ContextBind")
    is-ctx-lookup = is-generic(|"ContextLookup")

    node-is-meta-variable = node-is-generic(|"MetaVariable")
    node-is-ctx-bind = node-is-generic(|"ContextBind")
    node-is-ctx-lookup = node-is-generic(|"ContextLookup")
    node-is-ctx-empty = node-is-generic(|"ContextEmpty")
    node-is-ctx-var(|cc) : node -> <where(<elem> (<get-generic-name> node, cc))>
    node-is-ctx(|cc) = node-is-ctx-bind <+
                  node-is-ctx-lookup <+
                  node-is-ctx-empty <+
                  node-is-ctx-var(|cc)

    is-generic(|string) = string-tokenize(|<singelton> '-'); Hd; \ cons -> <equal> (cons, string) \
    node-is-generic(|string) = where(get-constructor; is-generic(|string))

    get-generic-name = get-constructor; string-tokenize(|<singelton> '-'); last
    get-context-id = get-generic-name; string-to-int